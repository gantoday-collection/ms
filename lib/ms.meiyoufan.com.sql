/*
Navicat MySQL Data Transfer

Source Server         : TXY
Source Server Version : 50725
Source Host           : 58.87.123.142:3306
Source Database       : ms.meiyoufan.com

Target Server Type    : MYSQL
Target Server Version : 50725
File Encoding         : 65001

Date: 2019-07-25 17:47:29
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for admin
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `gid` int(11) unsigned NOT NULL DEFAULT '0',
  `name` varchar(50) NOT NULL,
  `email` varchar(50) DEFAULT NULL,
  `phone` varchar(50) DEFAULT NULL,
  `password` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `remember_token` varchar(100) DEFAULT NULL,
  `status` smallint(3) unsigned NOT NULL DEFAULT '1',
  `created_at` timestamp NOT NULL,
  `updated_at` timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_user_name_unique` (`name`) USING BTREE,
  UNIQUE KEY `users_user_email_unique` (`email`) USING BTREE,
  UNIQUE KEY `users_user_phone_unique` (`phone`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of admin
-- ----------------------------
INSERT INTO `admin` VALUES ('1', '0', 'root', 'test@163.com', null, 'test', null, null, '1', '2019-01-12 11:02:29', '2019-01-23 11:36:01');
INSERT INTO `admin` VALUES ('2', '0', 'admin', 'admin@163.com', null, 'KCbclviUUrLB30xN5c3ektC4F+xv1GYJK/Pjb0DIAbXHI3GGr3Dh2dPWGfuF85so5Ipj+/sHcSXP8dss3qWi9IrlFQYmcTKLnSUZkMHdV6kFHDm2IJNH0+HuHKsMMXxwLtllOHQ9VeuCXbVX9yqoocmU307jvzHbSp/pUR8HdNE=', null, null, '1', '2019-01-12 03:13:41', '2019-01-12 03:13:41');
INSERT INTO `admin` VALUES ('31', '0', 'xiaowu', 'admin01@163.com', null, 'vWs1YeMDBYKhXF6gJl7pY/EjH1e4bA7Ec0c5fYenawlhzvmqNGN7nY0jSk1l5g2ip/9HhDgx8sITHNpG7FxJzX81Mhuw3xfZTXqb+bqQrsAaxtB/aG+28dp370hUP/ON3Xw8glRYIsQHQPEf5/JMs74z7gv9YjsjWu4zzJzMk0g=', null, null, '1', '2019-01-12 03:34:12', '2019-01-23 11:35:40');
INSERT INTO `admin` VALUES ('33', '0', 'wuqingbao', 'admin02@163.com', null, 'ZYtAb5KqQ1YBenq9FMQ3Z2zZR3sxDBPh3kGlafmE80/V3/XW6asZoa41X7bguTsAdJr9V+g84t+Wno1GIVzNUYL8GC6rIDCvMPXB+/QG8yT9qrLoI/Q3EfAzRmmAWmP4Aoecid5KlsyneqHGNTFjH+E8+apAZqEDG6sqlF9Mjco=', null, null, '1', '2019-01-12 03:36:39', '2019-01-23 11:35:45');
INSERT INTO `admin` VALUES ('34', '0', 'wuxiumu', '', null, 'kW1Tl2knHTvf9ectQw7dnJuCu+XrLseqkHbJ24ZiCGm4us6IkzQa7dQIrnMWtz1ZHvapIShCLA7coL/ji2Ae1+5DD5f8lJ14zOXtSHv6SSZgLBCeWMKoW0nWmQBNs4dV8Mxqiwg2lc72uOKutJBGA9b8Ah5l6MMq8187l8gvu6I=', null, null, '1', '2019-01-12 07:31:35', '2019-01-23 11:35:54');
INSERT INTO `admin` VALUES ('38', '0', 'hum4q', 'hum4q@163.com', null, 'QpB2fMsoqcZ75sfWFbnmOVHb2PeYanAGktdHNb8XETOq+3V64iqquVOl4QK5oOA43vVEHQrIBHhgsQ6j65cAGCo/t96woOhOqNkw4T/hOvUEr5hZpi48rczs/YPFyhi5QpBtixpQL9h2vtSs0v2hpotosjAmW7P6F2kS/bIyl0Y=', null, null, '1', '2019-01-13 14:42:35', '2019-01-13 14:42:35');
INSERT INTO `admin` VALUES ('39', '0', 'puf5h', 'puf5h@163.com', null, 'rF1QSGcjeugwiTAZr/JeQqvpVupuI3Wnz0gLj2P9Rmn4JlHsnCqBg0NfFLs6U8wMTI5c5BfF7+9Xb0+1ZEydZ3ohkTiSD22WsciOBMbGaTTuj5RaJz6YfIzTV8xkjo0bt1HbzpEkGj9hPrsAIn03G599SdkHGNiE86PdCNIrGqI=', null, null, '1', '2019-01-13 14:43:13', '2019-01-13 14:43:13');
INSERT INTO `admin` VALUES ('40', '0', 'xiaobao', 'xiaobao@163.com', null, 'MaTOU8BKZnMZl8XBfQPYVMpsdqtDYrAYTjoPfVY0b0fOM79Ahjypg+3g4jK2prUwZxJIxy4V6vRhq+OZ1ky/QyfqGZKshUpElOZAdk57WfspNEsFes+WBmlxCi+pRTBpatXwnQ7Lfrp3wXPCIab1+woMDq3m5pw4ind6DELgPOc=', null, null, '1', '2019-01-15 16:48:21', '2019-01-15 16:48:21');

-- ----------------------------
-- Table structure for column
-- ----------------------------
DROP TABLE IF EXISTS `column`;
CREATE TABLE `column` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `type_id` smallint(5) unsigned DEFAULT '1' COMMENT '//1导航，2，文章，3.表单',
  `pid` smallint(5) unsigned NOT NULL DEFAULT '0',
  `path` varchar(100) NOT NULL DEFAULT '',
  `name` varchar(100) NOT NULL,
  `content` text,
  `keywords` varchar(255) NOT NULL,
  `description` varchar(255) NOT NULL DEFAULT '',
  `image` varchar(255) DEFAULT NULL,
  `picid` smallint(5) unsigned NOT NULL DEFAULT '0',
  `audit` smallint(1) unsigned NOT NULL DEFAULT '1',
  `ord` smallint(3) unsigned NOT NULL DEFAULT '0',
  `display` smallint(3) unsigned NOT NULL DEFAULT '1',
  `c_mod` varchar(255) DEFAULT NULL,
  `s_name` varchar(255) DEFAULT NULL,
  `url` text,
  `status` smallint(3) unsigned NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=82 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of column
-- ----------------------------
INSERT INTO `column` VALUES ('17', '1', '0', '0', '分类', null, '', '', null, '0', '1', '58', '1', null, null, null, '9');
INSERT INTO `column` VALUES ('18', '1', '17', '0-17', '首页底部广告', null, '', '默认6张广告，排序', null, '0', '0', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('19', '1', '17', '0-19', '网站公告 ', null, '', '网站公告 \r\n               ', null, '0', '1', '0', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('20', '1', '17', '0-17', '首页顶部轮播', null, '', '首页顶部轮播', null, '0', '1', '0', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('21', '1', '20', '0-17-20', '精品推荐1', null, '', '首页精品推荐1', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('22', '1', '20', '0-17-20', '精品推荐2', null, '', '首页精品推荐', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('23', '1', '20', '0-17-23', '精品推荐3   ', null, '', '首页精品推荐  \r\n               ', null, '0', '1', '0', '2', null, null, null, '2');
INSERT INTO `column` VALUES ('40', '1', '0', '0-40', '读书   ', null, '篮球', '世上无难事，只要肯攀登。\r\n读万卷书，行万里路。\r\n樊登读书 \r\n                \r\n                \r\n               ', null, '0', '1', '4', '1', null, null, null, '9');
INSERT INTO `column` VALUES ('41', '1', '40', '0-40-41', '心灵', null, '', '《终身成长》固定思维决定你能用多长时间进入一个专业领域，成长思维决定你能在决定领域...\r\n《少有人走的路》只有承认人生苦难重重，才能躲开尽量多的苦难。少有人走的路，才通向最美的...\r\n《心流》积极心理学开山之作，提升效率和幸福的指南。幸福可以量化，走向它还有科学...\r\n《幸福的方法》如果生活不幸，那就学习如何幸福，幸福是衡量一切的最高标准，但目标是意义...', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('42', '1', '40', '0-40-42', '管理', null, '', '《可复制的领导力》轻松掌握领导力，打造核心竞争力\r\n《权利：为什么只为某些人所拥有》权利是”争“来的，不是”等“来的\r\n《经营者养成笔记》人人都在经营，但唯有取得成果，才算是真的经营\r\n《危机领导力》掌握10大关键策略，让你的团队抗得过危机', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('43', '1', '40', '0-40-43', '职场', null, '', '《刻意练习》挑战一万小时理论的朴实真理--看似天赋的技能，也可以通过正确的练习方式...\r\n《关键对话》本书将帮助你以四两拨千斤的方式，利用各种沟通技巧，解决生活中难以应对的...\r\n《非暴力沟通》马歇尔·卢森堡博士发现，依照非暴力沟通的方法谈话和聆听，能使人情意相同...\r\n《销售洗脑》这是一本教你洞察销售技巧，将逛街者变成购买者，让销售业绩如火箭般飞升的...', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('44', '1', '40', '0-40-44', '家庭', null, '', '《亲密关系》让爱情回到最初的模样，无须心有灵犀，你一个人的单边改善也能做到，这正是...\r\n《正面管教》家里自从有个孩子，教育就成了头等大事，怎么样才能做到既不骄纵也不严厉...\r\n《如何培养孩子的社会能力》社会能力是孩子人生幸福的基础，教会孩子怎么做，而不是替他做！\r\n《不吼不叫》破解”父母吼“的【武林秘籍】，让孩子平静地与你合作，你的育儿方式是时候练...', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('45', '1', '40', '0-40-45', '人文', null, '', '《王阳明哲学》勾勒阳明思想历程，阐释心学义理\r\n《未来简史》《人类简史》作者优娃儿·好啦里的预测书，为我们揭开关于未来的一种可能。\r\n《寻人不遇》上穷碧落下黄泉，两处茫茫皆不见。青山绿水不见诗人踪迹，却留存携永诗魂。\r\n《丝绸之路》一部全新的世界史', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('46', '1', '40', '0-40-46', '创业', null, '', '《高绩效教练》优秀的领导者都有”教练“特质，懂得重点培养他人的觉察力、责任感和自信心，...\r\n《让大象飞》激情创新，让你一飞冲天的创业术。\r\n《硅谷钢铁侠》爱龙·马克思的冒险人生\r\n《精益创业》风靡全球的创业思潮，李开复作序推荐。', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('47', '1', '40', '0-40-47', '作者光临', null, '', '《人生效率手册》你不能总在”被同龄人抛弃“的焦虑中度过此生。提高效率，全在此册。\r\n《我们终将遇见爱与孤独》以”不跟自己过不去“的蜕变为目标吧！\r\n《终生学习：哈佛毕业后的六堂课》斯坦福和哈佛大学都学不到的”人生必修课“：只有持续学习，才能使人趋于完满。\r\n《关键期关键帮助》我们或许是第一次为人父母，但孩子只有一次成长的机会。如何把握孩子0-7岁的...', null, '0', '1', '0', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('58', '1', '0', '0-58', '素材类别', null, '', '中英文对练      ', null, '0', '1', '3', '1', null, null, null, '9');
INSERT INTO `column` VALUES ('59', '1', '58', '0-58-59', '学习 ', null, '', ' \r\n                \r\n                \r\n               ', null, '0', '1', '1', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('60', '1', '58', '0-58-60', '购物  ', null, '', ' \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '2', '1', null, null, null, '2');
INSERT INTO `column` VALUES ('61', '1', '58', '0-58-61', '吃饭  ', null, '', ' \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '3', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('62', '1', '58', '0-58-62', '约会  ', null, '', ' \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '4', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('63', '1', '0', '0-63', ' 网站导航', null, '', ' \r\n               ', null, '0', '1', '0', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('64', '1', '63', '0-63-64', ' 首页   ', null, '', '中银投资有限公司 \r\n                \r\n                \r\n               ', null, '0', '1', '1', '1', null, null, '/index.php/home/index', '1');
INSERT INTO `column` VALUES ('65', '2', '63', '0-63-65', '公司介绍        ', null, '', '（以下简称“中银投资”）是中银集团投资有限公司于1993年3月在北京成立的全资附属机构，注册资本3.55亿美元。公司经营范围包括直接投资业务、租赁业务、投资咨询业务和投...\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n    ', null, '0', '1', '2', '1', null, null, '/index.php/home/companyProfile/198', '1');
INSERT INTO `column` VALUES ('66', '2', '63', '0-63-66', ' 业务领域   ', null, '', ' 中银投资 \r\n                \r\n                \r\n               ', null, '0', '1', '3', '1', null, null, '/index.php/home/businessArea/204', '1');
INSERT INTO `column` VALUES ('67', '1', '63', '0-63-67', '资讯动态   ', null, '', ' 中银投资 \r\n                \r\n                \r\n               ', null, '0', '1', '4', '1', null, null, '/index.php/home/dynamicInformation/70', '1');
INSERT INTO `column` VALUES ('68', '2', '63', '0-63-68', ' 诚聘英才          ', '<p>&nbsp; &nbsp; 中银投资有限公司，是一支富有理想和激情、严谨务实的团队，他们洋溢着追求创新的进取精神和蓬勃向上的充沛活力。这里既有百年中行的专业背景，又有充满挑战与乐趣的良好工作氛围。1</p><p>&nbsp;</p><p>&nbsp; &nbsp; 如果您有强烈的进取精神和团队意识，优秀的专业知识及丰富的从业经验，做事认真，为人诚信，不畏挑战，欢迎您加入我们，成为中银投资有限公司大家庭的一员，这里将是您充分展示才华的舞台！</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><p><br/></p>', '', '    中银投资有限公司，是一支富有理想和激情、严谨务实的团队，他们洋溢着追求创新的进取精神和蓬勃向上的充沛活力。这里既有百年中行的专业背景，又有充满挑战与乐趣的良好工作氛围。1\r\n \r\n    如果您有强烈的进取精神和团队意识，优秀的专业知识及丰富的从业经验，做事认真，为人诚信，不畏挑战，欢迎您加入我们，成为中银投资有限公司大家庭的一员，这里将是您充分展示才华的舞台！\r\n                \r\n                \r\n                \r\n             ', '/public_file/image/201809/28/20180928155942_749.png', '0', '1', '5', '1', null, null, '/index.php/home/talentsWanted', '1');
INSERT INTO `column` VALUES ('69', '1', '63', '0-63-69', ' 联络我们   ', null, '', ' 中银投资 \r\n                \r\n                \r\n               ', null, '0', '1', '6', '1', null, null, '/index.php/home/contactUs', '1');
INSERT INTO `column` VALUES ('70', '2', '67', '0-63-67-70', ' 业内动态', null, '', ' 业内动态', null, '0', '1', '4', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('71', '2', '67', '0-63-67-71', '公司资讯', null, '', '公司资讯', null, '0', '1', '4', '1', null, null, null, '1');
INSERT INTO `column` VALUES ('72', '2', '66', '0-63-66-72', ' 股权投资      ', null, '', '依托中国银行品牌优势，以专业化、市场化投资团队，专注中国市场，以投资成长型优秀公司为主，打造价值投资导向、投资业绩领先的百年老店。 \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '3', '1', null, null, '/index.php/home/businessArea/204', '1');
INSERT INTO `column` VALUES ('73', '2', '66', '0-63-66-73', ' 租赁业务', null, '', ' 租赁业务', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('74', '2', '66', '0-63-66-74', ' 投资咨询', null, '', ' 投资咨询', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('75', '2', '66', '0-63-66-75', ' 资产管理', null, '', ' 资产管理', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('76', '2', '66', '0-63-66-76', ' 运营平台     ', null, '', '中银投资有限公司作为中银集团投资有限公司在中国内地的总部公司，承担集团境内投资类附属公司“财务行政共享中心”职能，通过专业化、集约化的运作，在兼顾效率的同时，实现有效的成本...\r\n                \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '30', '1', null, null, '/index.php/home/businessArea/208/76', '1');
INSERT INTO `column` VALUES ('77', '2', '72', '0-63-66-72-77', ' 投资理念', null, '', ' 投资理念', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('78', '2', '72', '0-63-66-72-78', ' 重点领域', null, '', ' 投资理念', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('79', '2', '72', '0-63-66-72-79', ' 研究与分析', null, '', ' 研究与分析', null, '0', '1', '3', '2', null, null, null, '1');
INSERT INTO `column` VALUES ('80', '2', '73', '0-63-66-73-80', ' 延伸平台      ', null, '', '中银投资有限公司作为中银集团投资有限公司在中国内地的延伸投资平台，是总公司在中国内地开展“租赁业务”、“投资咨询”、“资产管理”等业务的体的投资载体。依托雄厚的资金实力和... \r\n                \r\n                \r\n                \r\n                \r\n                \r\n               ', null, '0', '1', '3', '1', null, null, '/index.php/home/businessArea/207/80', '1');
INSERT INTO `column` VALUES ('81', '1', '67', '0-63-67-81', ' 通知公告', null, '', ' 通知公告', null, '0', '1', '4', '1', null, null, null, '1');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `post_id` int(10) unsigned DEFAULT NULL COMMENT '主题id',
  `topic_type` tinyint(2) unsigned NOT NULL DEFAULT '1' COMMENT '1为文章，2为商品，3为建议',
  `content` text COMMENT '评论内容',
  `from_uid` int(10) unsigned DEFAULT NULL COMMENT '评论者id，一般为会员表的id',
  `nickname` varchar(60) DEFAULT NULL COMMENT '冗余用户昵称',
  `thumb_img` varchar(255) DEFAULT NULL COMMENT '冗余用户头像',
  `is_top` tinyint(2) unsigned NOT NULL DEFAULT '0' COMMENT '是否置顶评论，1为置顶，0为不置顶',
  `is_hot` tinyint(2) unsigned NOT NULL DEFAULT '0' COMMENT '是否为热评，1为热评',
  `like_num` int(5) unsigned DEFAULT '0' COMMENT '评论被点赞的次数',
  `reply_num` int(5) unsigned DEFAULT '0' COMMENT '评论被回复的次数',
  `is_reply` tinyint(2) unsigned DEFAULT '0' COMMENT '是否回复',
  `status` tinyint(2) unsigned NOT NULL DEFAULT '1' COMMENT '评论状态，-1为删除，0为待审核，1为已发布',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `topic_id` (`post_id`) USING BTREE,
  KEY `topic_type` (`topic_type`) USING BTREE,
  KEY `from_id` (`from_uid`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=80 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '52', '1', '## 写的不错，支持支持\r\n## 加油 加油', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 14:11:52');
INSERT INTO `comment` VALUES ('2', '52', '1', '## 写的不错，支持支持\r\n## 加油 加油', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 14:14:05');
INSERT INTO `comment` VALUES ('3', '52', '1', '##  你是最棒的\r\n## 加油 加油', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 14:15:17');
INSERT INTO `comment` VALUES ('4', '52', '1', '##  不要灰心，你可以的\r\n## 加油 加油', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 14:17:00');
INSERT INTO `comment` VALUES ('5', '12', '1', '看看书评豆瓣的精彩文章吧 \r\n## [精简解读《微习惯》：简单到不可能失败的自我管理法则](https://book.douban.com/review/8177370/)\r\n![img](https://img3.doubanio.com/view/thing_review/l/public/p365220.webp)', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 22:50:10');
INSERT INTO `comment` VALUES ('6', '58', '1', '## 加油，没有人相信你，我都会一直相信你\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-18 15:04:30');
INSERT INTO `comment` VALUES ('7', '68', '1', '共同学习，共同进步，加油！', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-19 06:47:38');
INSERT INTO `comment` VALUES ('8', '68', '1', '强大的Redis ，缓存 DB 消息队列。', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-19 06:47:54');
INSERT INTO `comment` VALUES ('9', '68', '1', '## 1、String\r\n可以是字符串，整数或者浮点数，对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作。\r\n\r\n字符串命令：\r\n```\r\n①get、获取存储在指定键中的值\r\n\r\n②set、设置存储在指定键中的值\r\n\r\n③del、删除存储在指定键中的值（这个命令可以用于所有的类型）\r\n```\r\n\r\n## 2、list\r\n\r\n一个链表，链表上的每个节点都包含了一个字符串，虫链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素。\r\n\r\n列表命令：\r\n```\r\n①rpush、将给定值推入列表的右端\r\n\r\n②lrange、获取列表在指定范围上的所有值\r\n\r\n③lindex、获取列表在指定范围上的单个元素\r\n\r\n④lpop、从列表的左端弹出一个值，并返回被弹出的值\r\n```\r\n## 3、set\r\n包含字符串的无序收集器(unordered collection)、并且被包含的每个字符串都是独一无二的。添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集，并集，差集，从集合里面随机获取元素。\r\n\r\n集合命令：\r\n```\r\n①sadd、将给定元素添加到集合\r\n\r\n②smembers、返回集合包含的所有元素\r\n\r\n③sismember、检查指定元素是否存在于集合中\r\n\r\n④srem、检查指定元素是否存在于集合中，那么移除这个元素\r\n```\r\n\r\n## 4、hash\r\n包含键值对无序散列表，添加，获取，移除当键值对，获取所有键值对。\r\n\r\n散列命令：\r\n```\r\n①hset、在散列里面关联起指定的键值对\r\n\r\n②hget、获取指定散列键的值\r\n\r\n③hgetall、获取散列包含的所有键值对\r\n\r\n④hdel、如果给定键存在于散列里面，那么移除这个键\r\n```\r\n\r\n## 5、zset\r\n字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定。添加，获取，删除单个元素，根据分值范围(range)或者成员来获取元素。\r\n\r\n有序集合命令：\r\n```\r\n①zadd、将一个带有给定分值的成员添加到有序集合里面\r\n\r\n②zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素\r\n\r\n③zrangebyscore、获取有序集合在给定分值范围内的所有元素\r\n\r\n④zrem、如果指定成员存在于有序集合中，那么移除这个成员\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-19 06:54:25');
INSERT INTO `comment` VALUES ('10', '71', '1', '## 包\r\n每个 Go 程序都是由包构成的。\r\n\r\n程序从 main 包开始运行。\r\n\r\n本程序通过导入路径 \"fmt\" 和 \"math/rand\" 来使用这两个包。\r\n\r\n按照约定，包名与导入路径的最后一个元素一致。例如，\"math/rand\" 包中的源码均以 package rand 语句开始。\r\n\r\n*注意：* 此程序的运行环境是固定的，因此 rand.Intn 总是会返回相同的数字。\r\n\r\n（要得到不同的数字，需为生成器提供不同的种子数，参见 rand.Seed https://go-zh.org/pkg/math/rand/#Seed。 练习场中的时间为常量，因此你需要用其它的值作为种子数。）', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:12:35');
INSERT INTO `comment` VALUES ('11', '71', '1', '## 导入\r\n此代码用圆括号组合了导入，这是“分组”形式的导入语句。\r\n\r\n当然你也可以编写多个导入语句，例如：\r\n```\r\nimport \"fmt\"\r\nimport \"math\"\r\n```\r\n不过使用分组导入语句是更好的形式。', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:13:44');
INSERT INTO `comment` VALUES ('12', '71', '1', '## 导出名\r\n在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。\r\n\r\npizza 和 pi 并未以大写字母开头，所以它们是未导出的。\r\n\r\n在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。\r\n\r\n执行代码，观察错误输出。\r\n\r\n然后将 math.pi 改名为 math.Pi 再试着执行一次。https://tour.go-zh.org/basics/3', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:15:03');
INSERT INTO `comment` VALUES ('13', '71', '1', '## 函数\r\n函数可以没有参数或接受多个参数。\r\n\r\n在本例中，add 接受两个 int 类型的参数。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc add(x int, y int) int {\r\n	return x + y \r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(add(42, 13))\r\n}\r\n\r\n```\r\n注意类型在变量名 之后。\r\n\r\n（参考 这篇关于 Go 语法声明的文章了解这种类型声明形式出现的原因。 http://blog.go-zh.org/gos-declaration-syntax）', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:18:04');
INSERT INTO `comment` VALUES ('14', '71', '1', '## 函数（续）\r\n当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc add(x, y int) int {\r\n	return x + y\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(add(42, 13))\r\n}\r\n\r\n```\r\n在本例中，\r\n```\r\nx int, y int\r\n```\r\n被缩写为\r\n```\r\nx, y int\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:19:11');
INSERT INTO `comment` VALUES ('15', '71', '1', '## 多值返回\r\n函数可以返回任意数量的返回值。\r\n\r\nswap 函数返回了两个字符串。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc swap(x, y string) (string, string) {\r\n	return  x,y\r\n}\r\n\r\nfunc main() {\r\n	a, b := swap(\"hello\", \"world\")\r\n	fmt.Println(a, b)\r\n}\r\n\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:20:04');
INSERT INTO `comment` VALUES ('16', '71', '1', '## 命名返回值\r\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\r\n\r\n返回值的名称应当具有一定的意义，它可以作为文档使用。\r\n\r\n没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。\r\n\r\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc split(sum int) (x, y int) {\r\n	x = sum * 4 / 9\r\n	y = sum - x\r\n	return\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(split(9))\r\n}\r\n\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:21:20');
INSERT INTO `comment` VALUES ('17', '72', '1', '## 变量\r\nvar 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\r\n\r\n就像在这个例子中看到的一样，var 语句可以出现在包或函数级别。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nvar c, python, java bool\r\n\r\nfunc main() {\r\n	var i int\r\n	fmt.Println(i, c, python, java)\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:23:41');
INSERT INTO `comment` VALUES ('18', '72', '1', '## 变量的初始化\r\n变量声明可以包含初始值，每个变量对应一个。\r\n\r\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nvar i, j int = 1, 2\r\n\r\nfunc main() {\r\n	var c, python, java = true, false, \"no!\"\r\n	fmt.Println(i, j, c, python, java)\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:24:26');
INSERT INTO `comment` VALUES ('19', '72', '1', '## 短变量声明\r\n在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。\r\n\r\n函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	var i, j int = 1, 2\r\n	k := 3\r\n	c, python, java := true, false, \"no!\"\r\n\r\n	fmt.Println(i, j, k, c, python, java)\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:25:14');
INSERT INTO `comment` VALUES ('20', '72', '1', '## 基本类型\r\nGo 的基本类型有\r\n```\r\nbool\r\nstring\r\nint  int8  int16  int32  int64\r\nuint uint8 uint16 uint32 uint64 uintptr\r\nbyte // uint8 的别名\r\nrune // int32 的别名\r\n    // 表示一个 Unicode 码点\r\nfloat32 float64\r\ncomplex64 complex128\r\n```\r\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\r\n\r\nint, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"math/cmplx\"\r\n)\r\n\r\nvar (\r\n	ToBe   bool       = false\r\n	MaxInt uint64     = 1<<64 - 1\r\n	z      complex128 = cmplx.Sqrt(-5 + 12i)\r\n)\r\n\r\nfunc main() {\r\n	fmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\r\n	fmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\r\n	fmt.Printf(\"Type: %T Value: %v\\n\", z, z)\r\n}\r\n```\r\n```\r\nType: bool Value: false\r\nType: uint64 Value: 18446744073709551615\r\nType: complex128 Value: (2+3i)\r\n```\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:27:18');
INSERT INTO `comment` VALUES ('21', '72', '1', '## 零值\r\n没有明确初始值的变量声明会被赋予它们的 零值。\r\n\r\n零值是：\r\n```\r\n数值类型为 0，\r\n布尔类型为 false，\r\n字符串为 \"\"（空字符串）。\r\n```\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	var i int\r\n	var f float64\r\n	var b bool\r\n	var s string\r\n	fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)\r\n}\r\n```\r\n```\r\n0 0 false \"\"\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:29:10');
INSERT INTO `comment` VALUES ('22', '72', '1', '## 类型转换\r\n表达式 T(v) 将值 v 转换为类型 T。\r\n\r\n一些关于数值的转换：\r\n```\r\nvar i int = 42\r\nvar f float64 = float64(i)\r\nvar u uint = uint(f)\r\n```\r\n或者，更加简单的形式：\r\n```\r\ni := 42\r\nf := float64(i)\r\nu := uint(f)\r\n```\r\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。试着移除例子中 float64 或 uint 的转换看看会发生什么。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"math\"\r\n)\r\n\r\nfunc main() {\r\n	var x, y int = 3, 4\r\n	var f float64 = math.Sqrt(float64(x*x + y*y))\r\n	var z uint = uint(f)\r\n	fmt.Println(x, y, z)\r\n}\r\n```\r\n\r\n```\r\n3 4 5\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:30:33');
INSERT INTO `comment` VALUES ('23', '72', '1', '## 类型推导\r\n在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。\r\n\r\n当右值声明了类型时，新变量的类型与其相同：\r\n```\r\nvar i int\r\nj := i // j 也是一个 int\r\n```\r\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：\r\n```\r\ni := 42           // int\r\nf := 3.142        // float64\r\ng := 0.867 + 0.5i // complex128\r\n```\r\n尝试修改示例代码中 v 的初始值，并观察它是如何影响类型的。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	v := 42 // 修改这里！\r\n	fmt.Printf(\"v is of type %T\\n\", v)\r\n}\r\n```\r\n\r\n```\r\nv is of type int\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:32:19');
INSERT INTO `comment` VALUES ('24', '72', '1', '## 常量\r\n常量的声明与变量类似，只不过是使用 const 关键字。\r\n\r\n常量可以是字符、字符串、布尔值或数值。\r\n\r\n常量不能用 := 语法声明。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nconst Pi = 3.14\r\n\r\nfunc main() {\r\n	const World = \"世界\"\r\n	fmt.Println(\"Hello\", World)\r\n	fmt.Println(\"Happy\", Pi, \"Day\")\r\n\r\n	const Truth = true\r\n	fmt.Println(\"Go rules?\", Truth)\r\n}\r\n```\r\n\r\n```\r\nHello 世界\r\nHappy 3.14 Day\r\nGo rules? true\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:33:22');
INSERT INTO `comment` VALUES ('25', '72', '1', '## 数值常量\r\n数值常量是高精度的 值。\r\n\r\n一个未指定类型的常量由上下文来决定其类型。\r\n\r\n再尝试一下输出 needInt(Big) 吧。\r\n\r\n（int 类型最大可以存储一个 64 位的整数，有时会更小。）\r\n\r\n（int 可以存放最大64位的整数，根据平台不同有时会更少。）\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nconst (\r\n	// 将 1 左移 100 位来创建一个非常大的数字\r\n	// 即这个数的二进制是 1 后面跟着 100 个 0\r\n	Big = 1 << 100\r\n	// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\r\n	Small = Big >> 99\r\n)\r\n\r\nfunc needInt(x int) int { return x*10 + 1 }\r\nfunc needFloat(x float64) float64 {\r\n	return x * 0.1\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(needInt(Small))\r\n	fmt.Println(needFloat(Small))\r\n	fmt.Println(needFloat(Big))\r\n}\r\n```\r\n\r\n```\r\n21\r\n0.2\r\n1.2676506002282295e+29\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:34:49');
INSERT INTO `comment` VALUES ('26', '80', '1', '**Martin Fowler**是一位独立咨询顾问，他运用对象技术解决企业问题已经超过十年。他的顾问领域包括健康管理、金融贸易，以及法人财务。他的客户包括Chrysler，Citibank，UK National Health Service，AndersenConsulting，NetscapeCommunications。此外Fowler也是objects、UML、patterns技术的一位合格讲师，他是《AnalysisPatterns》和《UML Distilled》的作者。', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:51:41');
INSERT INTO `comment` VALUES ('27', '80', '1', '“模式的关键点是它们源于实践。必须观察人们的工作过程，发现其中好的设计，并找出‘这些解决方案的核心’。这不是一个简单的过程，但是一旦发现了某个模式，它将是非常有价值的。对于我来说，价值之一是能够撰写这样一本参考书。你不必通读本书的全部内容，也不必通读任何一本有关模式的书。只需要了解到这些模式都是干什么的、它们解决什么问题、它们是如何解决问题的，就足够了。这样，一旦你碰到类似问题，就可以从书中找出相应的模式。那时，你再深入了解相应的模式也为时不晚。”', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 20:53:28');
INSERT INTO `comment` VALUES ('28', '27', '1', '\r\n```\r\n1.直接取整，舍弃小数，保留整数：intval()； \r\n2.四舍五入取整：round()； \r\n3.向上取整，有小数就加1：ceil()； \r\n4.向下取整：floor()。\r\n```\r\n## 一、intval—对变数转成整数型态 \r\nintval如果是字符型的会自动转换为0。\r\n```\r\nintval(3.14159);  // 3\r\nintval(3.64159);  // 3\r\nintval(\'ruesin\'); //0\r\n```\r\n\r\n## 二、四舍五入：round()\r\n\r\n根据参数2指定精度将参数1进行四舍五入。参数2可以是负数或零（默认值）。\r\n```\r\nround(3.14159);      // 3\r\nround(3.64159);      // 4\r\nround(3.64159, 0);   // 4\r\nround(3.64159, 2);   // 3.64\r\nround(5.64159, 3);   // 3.642\r\nround(364159, -2);   // 364200\r\n```\r\n## 三、向上取整，有小数就加1：ceil()\r\n\r\n返回不小于 value 的下一个整数，value 如果有小数部分则进一位。\r\n\r\n这个方法，在我们写分页类计算页数时经常会用到。\r\n```\r\nceil(3.14159);  // 4\r\nceil(3.64159);  // 4\r\n```\r\n## 四、向下取整：floor()\r\n\r\n返回不大于 value 的下一个整数，将 value 的小数部分舍去取整。\r\n```\r\nfloor(3.14159);    // 3\r\nfloor(3.64159);    // 3\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-22 14:01:28');
INSERT INTO `comment` VALUES ('29', '86', '1', '李开复老师曾经说过：\r\n```\r\n人的一生两个最大的财富是：你的才华和你的时间。才华越来越多，但是时间越来越少，我们的一生可以说是用时间来换取才华。如果一天天过去了，我们的时间少了，而才华没有增加，那就是虚度了时光。\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 03:19:17');
INSERT INTO `comment` VALUES ('30', '56', '1', 'Go语言完全自学手册（图文教程） https://edu.aliyun.com/course/499', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 12:35:58');
INSERT INTO `comment` VALUES ('31', '86', '1', '1. 面向对象最大优点在于它能够使复杂逻辑易于处理\r\n\r\n\r\n2. 阅读本书方法：从头到尾将第一部分的叙述性章节读完，然后再根据兴趣和需求翻阅第二部分的有关章节\r\n\r\n\r\n3. 软件架构通用性书籍：POSA（面向模式的软件架构）\r\n\r\n\r\n4. 迭代开发的核心在于只要软件对用户有用，就应当交付，即使这个软件当时并没有完成', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:29:45');
INSERT INTO `comment` VALUES ('32', '86', '1', '## 1. 架构：\r\n最高层次的系统分解、系统中不易改变的决定（有些主观）\r\n\r\n\r\n## 2. 企业应用特点：\r\n持久化数据、涉及到大量数据、很多人同时访问数据、大量操作数据的用户界面屏幕、需要与散布在企业周围的其他企业应用集成、可能会遇到业务过程中的差异以及数据中概念的不一致性、复杂业务无逻辑\r\n\r\n\r\n## 3. 企业应用分类：\r\n选择架构时，必须很清楚地了解面临的问题，在理解的基础上再来选择合适的设计。同时，即便选择了某种模式，也需要进一步根据面临的问题来修改模式\r\n在系统开发时应该选取尽可能少的工具，注意不同的工具擅长处理的方面不同，切记不要用错工具\r\n\r\n\r\n## 4. 关于性能的考虑：\r\n性能：响应时间、响应性、等待时间、吞吐率、负载（当前有多少用户与系统相连）、负载敏感度、效率（性能除以资源配置）、容量（最大有效负载或吞吐率）、可伸缩性（增加硬件资源对系统性能的影响）\r\n当构建企业应用系统时，关注硬件的可伸缩性往往比关注容量或效率更重要！\r\n关于性能考虑：一般可以先建立系统，调试运行，然后通过基于测量的严格优化过程来提高性能\r\n\r\n\r\n## 5. 模式：\r\n所有模式都是不完善的，你有责任在自己的系统中完善它们！', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:31:01');
INSERT INTO `comment` VALUES ('33', '87', '1', '## Layer与Tier的区别：\r\n\r\n1、Tier强调物理上的分离，Two Tier System。\r\n\r\n2、Layer强调逻辑上的分层。\r\n', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:35:06');
INSERT INTO `comment` VALUES ('34', '73', '1', '## for\r\nGo 只有一种循环结构：for 循环。\r\n\r\n基本的 for 循环由三部分组成，它们用分号隔开：\r\n```\r\n初始化语句：在第一次迭代前执行\r\n条件表达式：在每次迭代前求值\r\n后置语句：在每次迭代的结尾执行\r\n```\r\n初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\r\n\r\n一旦条件表达式的布尔值为 false，循环迭代就会终止。\r\n\r\n注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	sum := 0\r\n	for i := 0; i < 10; i++ {\r\n		sum += i\r\n	}\r\n	fmt.Println(sum)\r\n}\r\n```\r\n45\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 13:46:22');
INSERT INTO `comment` VALUES ('35', '73', '1', '## for（续）\r\n初始化语句和后置语句是可选的。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	sum := 1\r\n	for ; sum < 1000; {\r\n		sum += sum\r\n		fmt.Println(sum)\r\n	}\r\n	\r\n}\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:53:00');
INSERT INTO `comment` VALUES ('36', '73', '1', '## for 是 Go 中的 “while”\r\n此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	sum := 1\r\n	for sum < 1000 {\r\n		sum += sum\r\n	}\r\n	fmt.Println(sum)\r\n}\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:54:32');
INSERT INTO `comment` VALUES ('37', '73', '1', '## 无限循环\r\n如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。\r\n```\r\npackage main\r\n\r\nfunc main() {\r\n	for {\r\n	}\r\n}\r\n```\r\n\r\n```\r\nprocess took too long\r\n```\r\n', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:56:21');
INSERT INTO `comment` VALUES ('38', '73', '1', '## if\r\nGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"math\"\r\n)\r\n\r\nfunc sqrt(x float64) string {\r\n	if x < 0 {\r\n		return sqrt(-x) + \"i\"\r\n	}\r\n	return fmt.Sprint(math.Sqrt(x))\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(sqrt(2), sqrt(-4))\r\n}\r\n```\r\n\r\n```\r\n1.4142135623730951 2i\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 21:58:08');
INSERT INTO `comment` VALUES ('39', '73', '1', '## if 的简短语句\r\n同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。\r\n\r\n该语句声明的变量作用域仅在 if 之内。\r\n\r\n（在最后的 return 语句处使用 v 看看。）\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"math\"\r\n)\r\n\r\nfunc pow(x, n, lim float64) float64 {\r\n	if v := math.Pow(x, n); v < lim {\r\n		return v\r\n	}\r\n	return lim\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(\r\n		pow(3, 2, 10),\r\n		pow(3, 3, 20),\r\n	)\r\n}\r\n```\r\n9 20\r\n', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 22:00:46');
INSERT INTO `comment` VALUES ('40', '73', '1', '## if 和 else\r\n在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。\r\n\r\n（在 main 的 fmt.Println 调用开始前，两次对 pow 的调用均已执行并返回其各自的结果。）\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"math\"\r\n)\r\n\r\nfunc pow(x, n, lim float64) float64 {\r\n	if v := math.Pow(x, n); v < lim {\r\n		return v\r\n	} else {\r\n		fmt.Printf(\"%g >= %g\\n\", v, lim)\r\n	}\r\n	// 这里开始就不能使用 v 了\r\n	return lim\r\n}\r\n\r\nfunc main() {\r\n	fmt.Println(\r\n		pow(3, 2, 10),\r\n		pow(3, 3, 20),\r\n	)\r\n}\r\n```\r\n\r\n```\r\n27 >= 20\r\n9 20\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 22:03:27');
INSERT INTO `comment` VALUES ('41', '73', '1', '## switch\r\nswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\r\n\r\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"runtime\"\r\n)\r\n\r\nfunc main() {\r\n	fmt.Print(\"Go runs on \")\r\n	switch os := runtime.GOOS; os {\r\n	case \"darwin\":\r\n		fmt.Println(\"OS X.\")\r\n	case \"linux\":\r\n		fmt.Println(\"Linux.\")\r\n	default:\r\n		// freebsd, openbsd,\r\n		// plan9, windows...\r\n		fmt.Printf(\"%s.\\n\", os)\r\n	}\r\n}\r\n```\r\nGo runs on nacl.', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 15:51:58');
INSERT INTO `comment` VALUES ('42', '73', '1', '## switch 的求值顺序\r\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\r\n\r\n（例如，\r\n```\r\nswitch i {\r\ncase 0:\r\ncase f():\r\n}\r\n```\r\n在 i==0 时 f 不会被调用。）\r\n\r\n**注意：** Go 练习场中的时间总是从 2009-11-10 23:00:00 UTC 开始，该值的意义留给读者去发现。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"time\"\r\n)\r\n\r\nfunc main() {\r\n	fmt.Println(\"When\'s Saturday?\")\r\n	today := time.Now().Weekday()\r\n	switch time.Saturday {\r\n	case today + 0:\r\n		fmt.Println(\"Today.\")\r\n	case today + 1:\r\n		fmt.Println(\"Tomorrow.\")\r\n	case today + 2:\r\n		fmt.Println(\"In two days.\")\r\n	default:\r\n		fmt.Println(\"Too far away.\")\r\n	}\r\n}\r\n```\r\n\r\n```\r\nWhen\'s Saturday?\r\nToo far away.\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 15:54:28');
INSERT INTO `comment` VALUES ('43', '73', '1', '## 没有条件的 switch\r\n没有条件的 switch 同 switch true 一样。\r\n\r\n这种形式能将一长串 if-then-else 写得更加清晰。\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"time\"\r\n)\r\n\r\nfunc main() {\r\n	t := time.Now()\r\n	switch {\r\n	case t.Hour() < 12:\r\n		fmt.Println(\"Good morning!\")\r\n	case t.Hour() < 17:\r\n		fmt.Println(\"Good afternoon.\")\r\n	default:\r\n		fmt.Println(\"Good evening.\")\r\n	}\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 15:55:47');
INSERT INTO `comment` VALUES ('44', '73', '1', '## defer\r\ndefer 语句会将函数推迟到外层函数返回之后执行。\r\n\r\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	defer fmt.Println(\"world\")\r\n\r\n	fmt.Println(\"hello\")\r\n}\r\n```\r\n\r\n```\r\nhello\r\nworld\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 15:56:52');
INSERT INTO `comment` VALUES ('45', '73', '1', '## defer 栈\r\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\r\n\r\n更多关于 defer 语句的信息，请阅读此博文。http://blog.go-zh.org/defer-panic-and-recover\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	fmt.Println(\"counting\")\r\n\r\n	for i := 0; i < 10; i++ {\r\n		defer fmt.Println(i)\r\n	}\r\n\r\n	fmt.Println(\"done\")\r\n}\r\n```\r\n\r\n```\r\ncounting\r\ndone\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-23 15:58:17');
INSERT INTO `comment` VALUES ('46', '87', '1', '企业应用架构之分层 – 总结 https://it.zuocheng.net/tier-architecture-summary-zh#_3-tier_architecture', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 00:57:46');
INSERT INTO `comment` VALUES ('47', '87', '1', '计算机网络 https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 00:59:02');
INSERT INTO `comment` VALUES ('48', '86', '1', '## 架构 \r\n\r\n架构一般来说意味着：\r\n\r\n从最高层将系统分解成多个部分。\r\n\r\n一旦作出就很难改变的决定。\r\n\r\nRalph Johnson说：\r\n\r\n架构是一种主观 的东西，是项目专家开发人员对系统设计的一种共同理解 。通常，共同理解是指系统包含哪些主要组件以及这些组件相互之间如何交互。Martin认为架构模式中最重要就是分层 。', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:19:42');
INSERT INTO `comment` VALUES ('49', '86', '1', '## 企业应用程序 \r\n\r\n企业应用程序通常也被称为\"信息系统(Information Systems)\"或”数据处理系统(Data Processing)\"。企业应用程序的例子包括：薪水帐册、病人记录、船运跟踪、费用分析、信用等级、保险、供应链、会计、客户服务和外贸。不是企业 应用程序的例子包括：汽车燃油喷射(automobile fuel injection)，字处理器、选举控制器、化学工厂控制器、电话交换机、操作系统、编译器和游戏。\r\n\r\n企业应用程序的特点：\r\n\r\n- 1.企业应用程序通常包含**持久化** 的数据。\r\n- 2.企业应用程序通常包含**大量数据** ，一个中型系统的数据量超过1G，大约包含万条记录。\r\n- 3.用户通常**并发地** 访问数据。\r\n- 4.企业应用程序通常包含很多用户接口屏幕(user interface screen)。包含上百个不同的屏幕是很常见的。\r\n- 5.企业应用程序通常需要和别的企业应用程序进行集成。\r\n- 6.通常有复杂的业务逻辑(business logic)。业务逻辑通常是非逻辑的(illogic)，它们经常变化而且看起来十分古怪。', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:23:10');
INSERT INTO `comment` VALUES ('50', '86', '1', '## 企业应用程序的类型 \r\n\r\n不同类型的企业应用程序需要使用不同的方式来开发，要对“总是要这样做”的规则保持警惕。三种不同的企业应用程序举例：\r\n\r\n- 1.B2C在线零售店，用户浏览商品，将它们放入购物篮，然后购买。此类系统需要处理大量用户，这就要求高效利用资源并且应用需要是可伸缩的，这样通过添加硬件就能够增加负载量。此类系统的领域逻辑相当直观且明显，需要支持尽可能广泛的浏览器。\r\n\r\n- 2.一个能使租赁协议的处理自动化的系统(a system that automates the processing of leasing agreements)。比起B2C在线零售店，这个系统的用户量要少得多，但是业务逻辑却要复杂得多。用户界面也要更复杂。\r\n\r\n- 3.为一个小公司做的简单费用跟踪系统。这个系统只有少量的用户和简单的业务逻辑。它的主要挑战是快速的构建并及时听取反馈。\r\n\r\n对于这三种应用程序不能够使用同一种架构。', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:26:52');
INSERT INTO `comment` VALUES ('51', '86', '1', '## 性能(Performance) \r\n\r\n**做性能优化之前和之后一定要测量**。 术语：\r\n\r\n- **响应时间(response time)** 。系统处理外部请求所花费的时间，比如说按一个按钮。\r\n- **响应性(responsiveness)** 。描述系统以多快的速度对请求进行响应，这和响应时间不同。比如说，当点击\"复制\"按钮到出现进度条这段时间是响应性，而到文件复制结束时是响应时间。\r\n- **潜伏时间(Latency)** 。 指接收到任何形式响应所需的最短时间。对本地程序，潜伏时间非常短，对于远程程序，潜伏时间至少是请求在网络上传输的时间。和响应性不同，它是用户感知到 响应所用的时间，潜伏时间是指服务器端(一般来说是计算机)接收到响应所用的时间。作为应用程序开发者，我们没有办法改善潜伏时间。\r\n- **吞吐量(Throughput)** 。在给定的时间内完成的工作量。如果是计算文件复制的时间，吞吐量可能用字节每秒(bytes per second)来衡量。对企业应用程序，吞吐量一般用事务数每秒来衡量(transactions per second, tps)。\r\n- **负载(Load)** 。用于系统处于多大的压力，例如可用有多少用户连接到系统来衡量系统负载。负载一般作为其它测量量的上下文，例如可以说，10个用户时请求响应时间是0.5秒而20个用户时响应时间是2秒。\r\n- **负载敏感性(Load Sensitivity)** 。表壳响应时间怎样随着系统负载变化。假设系统A对10到20个用户的响应时间是0.5秒，系统B对10个用户的响应时间是0.2秒，对20个用户的响应时间上升到2秒。我们说系统A比系统B有较低的负载敏感性。\r\n- **效率(Efficeincy)** 。用性能除以资源。系统A有2个CPU，其吞吐量是30tps，系统B有3个CPU，吞吐量是40tps，那么我们说系统A比系统B更有效率。\r\n- **容量(Capacity)** 。表示系统最大能够承受的有效负载或吞吐量。\r\n- **伸缩性(Scalability)** 。描述添加资源(通常是硬件)如何影响性能。一个可伸缩的系统可能通过添加硬件来获得更好的性能，例如通过加一台服务器可以加倍吞吐量。给单台服务器增加动力(如添加更多的CPU)是**垂直伸缩性** 。添加更多服务器是**水平伸缩性** 。\r\n\r\n性能一般是指负载或吞吐量。当构建企业应用程序时，硬件伸缩性通常比系统容量甚至系统效率更重要，因为这时可以通过添加硬件来提高系统性能。', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:30:58');
INSERT INTO `comment` VALUES ('52', '61', '1', '## 先查看远程分支\r\n```\r\ngit branch -ｒ\r\n```\r\n## 使用下面两条命令来删除远程分支\r\n```\r\ngit branch -r -d origin/branch-name\r\ngit push origin :branch-name\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:49:06');
INSERT INTO `comment` VALUES ('53', '61', '1', '## 使用git  直接提交的话   直接 push\r\n\r\n## 获取最新版本  有两种  拉取 和 获取    pull 和 fetch  \r\n\r\n**git  pull**从远程拉取最新版本 到本地  \r\n\r\n自动合并 merge      **git pull origin master**\r\n\r\n**git  fetch**从远程获取最新版本 到本地   不会自动合并 merge    \r\n```\r\ngit fetch  origin master      \r\ngit log  -p master ../origin/master     \r\ngit merge orgin/master\r\n```\r\n实际使用中  使用git fetch 更安全    在merge之前可以看清楚 更新情况  再决定是否合并', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 18:54:57');
INSERT INTO `comment` VALUES ('54', '61', '1', '## 一、拉取最新的版本\r\n\r\n1、我们先查看远程仓库的情况（分别为拉取和推送）\r\n\r\n\r\n2、使用如下命令从origin远程仓库获取最新版本的代码\r\n```\r\ngit fetch origin master:temp\r\n```\r\n解释：从远程origin仓库拉取matser分支的版本，并且同时在本地创建一个分支test，拉取到test分支\r\n\r\n3、比较本地的master分支和test分支的差异\r\n```\r\ngit diff test\r\n```\r\n\r\n\r\n4、合并本地master分支和test分支\r\n```\r\ngit merge test\r\n```\r\n\r\n## 二、修改后上传到github上面\r\n\r\n简单的方式：都是在本地的master分支上进行操作修改代码\r\n```\r\n1、git status   \r\n\r\n2、git add -A   \r\n\r\n3、git commit -a -m \"first commit\"  \r\n```\r\n\r\n安全一点的方式：在分支上进行代码的操作\r\n\r\n1.创建一个新的分支test,并切换至该分支：\r\n```\r\n$git checkout -b test\r\n```\r\n\r\n2.在该分支可以对代码进行修改，删除，增加等。\r\n\r\n\r\n3.提交sixi这个分支修改，删除、增加的代码：\r\n```\r\n\r\n$ git commit -a -m \'commit all files\'\r\n```\r\n\r\n4.切换至master分支，把分支test合并到本地master中。\r\n\r\n```\r\n$git checkout master\r\n\r\n\r\n$git merge test\r\n```\r\n\r\n6.上传至远程仓库：\r\n```\r\ngit push origin master\r\n```\r\n（我这里是默认本地matser传到github上面）\r\n\r\n提示：\r\n```\r\ngit add -A 提交所有变化\r\ngit add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\r\ngit add. 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 19:00:12');
INSERT INTO `comment` VALUES ('55', '73', '1', '## 1. 练习\r\n\r\n作为练习函数和循环的简单途径，用牛顿法实现开方函数。在这个例子中，牛顿法通过选择一个初始点z，然后重复这一选择过程求Sqrt(x)的近似值，这里用图片描述牛顿法的数学公式： \r\n\r\n```math\r\n z = z- \\frac{x^2-x}{2x}\r\n```\r\n\r\n为了做到这个，只需要重复计算 10 次，并且观察在不同的循环次数（1，2，3，……）下z是如何逐步逼近结果的。 然后，修改循环条件，使得当z值停止改变（或改变非常小）的时候退出循环。观察迭代次数是否变化，结果与math.Sqrt接近。\r\n\r\n提示：定义并初始化一个浮点值，向其提供一个浮点语法或使用转换：\r\n```\r\nz := float64(1)\r\n```\r\n或\r\n```\r\nz := 1.0\r\n```\r\n## 2. 解题思路\r\n\r\n定义并初始化一个浮点值z，并套用计算方式： \r\n```\r\nz = z - (z*z-x)/(2*z)\r\n```\r\n循环计算并查看变化（迭代10次，到结果没有变化），目的是得到类似math.Sqrt()的效果。\r\n\r\n## 3. 代码实现\r\n```\r\n// 循环与函数练习：用牛顿法实现开方\r\n\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"math\"\r\n)\r\n\r\nfunc Sqrt(x float64) float64 {\r\n    z := 1.00                  // z用来套用公式z = z - (z*z-x)/(2*z)\r\n    temp := 0.00                        // 临时变量，用来记录z上次的值\r\n    for i := 0; i < 10; i++ {\r\n        z = z - (z*z-x)/(2*z)                       // 计算最新的z值\r\n        fmt.Println(z)         // 观察不同循环序数的z值，如何逐步逼近结果\r\n        if math.Abs(z-temp) < 0.000000000000001 {\r\n            break           // 当值停止改变（或改变非常小）的时候退出循环\r\n        } else {\r\n            temp = z             // 把每次循环的z值赋给temp，做条件比较\r\n        }\r\n    }\r\n    return z           // 当z值停止改变（或改变非常小）时跳出循环，返回z值\r\n}\r\n\r\n// 比较牛顿法与普通开方函数的输出\r\nfunc main() {\r\n    fmt.Println(\"牛顿法：\", Sqrt(2))\r\n    fmt.Println(\"math.Sqrt(２):\", math.Sqrt(2))\r\n}\r\n```\r\n输出结果为\r\n```\r\n1.5\r\n1.4166666666666667\r\n1.4142156862745099\r\n1.4142135623746899\r\n1.4142135623730951\r\n1.414213562373095\r\n牛顿法： 1.414213562373095\r\nmath.Sqrt(２): 1.4142135623730951\r\n```', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-24 19:35:05');
INSERT INTO `comment` VALUES ('56', '90', '1', '## 1.此处的「类」泛指所有的「Class类」、「接口」、「traits 可复用代码块」以及其它类似结构。\r\n\r\n## 2.一个完整的类名需具有以下结构:\r\n```\r\n\\<命名空间>(\\<子命名空间>)*\\<类名>\r\n```\r\n1.完整的类名 必须 要有一个顶级命名空间，被称为 \"vendor namespace\"；\r\n\r\n2.完整的类名 可以 有一个或多个子命名空间；\r\n\r\n3.完整的类名 必须 有一个最终的类名；\r\n\r\n4.完整的类名中任意一部分中的下滑线都是没有特殊含义的；\r\n\r\n5.完整的类名 可以 由任意大小写字母组成；\r\n\r\n6.所有类名都 必须 是大小写敏感的。\r\n\r\n## 当根据完整的类名载入相应的文件\r\n\r\n1.完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应；\r\n\r\n2.紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。\r\n\r\n3.末尾的类名 必须 与对应的以 .php 为后缀的文件同名。\r\n\r\n4.自动加载器（autoloader）的实现 一定不可** 抛出异常**、一定不** 触发任一级别的错误信息**以及不应该有**返回值**。', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-25 00:50:19');
INSERT INTO `comment` VALUES ('57', '61', '1', '你要覆盖掉github上面的东西的话，很简单啦，\r\n```\r\ngit push origin master -f\r\n```\r\n(-f是强制push)', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-25 04:06:05');
INSERT INTO `comment` VALUES ('58', '62', '1', '## 跳坑笔记结束\r\n**加强补充：**\r\n简单粗暴点的办法就是直接配置git更省事儿\r\n```\r\ngit config --global core.ignorecase false\r\n```\r\n然后拓展下git的好用的基本的配置：\r\n```\r\ngit config --global user.name \"你的名字\"               \r\ngit config --global user.email \"你的邮箱\"         \r\ngit config --global push.default simple             \r\n```\r\n//什么gui呢？gitpush时有俩参数，‘matching’ 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\r\n\r\n而 Git 2.x 默认的是 simple，意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码\r\n```\r\ngit config --global core.autocrlf false              //* 让Git不要管Windows/Unix换行符转换的事\r\ngit config --global gui.encoding utf-8               #//避免git gui中的中文乱码\r\ngit config --global core.quotepath off               // 避免git status显示的中文文件名乱码\r\n```\r\n', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-25 04:09:19');
INSERT INTO `comment` VALUES ('59', '61', '1', '```\r\ngit push origin --delete Chapater6   \r\n```\r\n## 可以删除远程分支Chapater6   \r\n\r\n```\r\ngit branch -d Chapater8 \r\n```\r\n## 可以删除本地分支（在主分支中）\r\n\r\n', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-25 04:34:27');
INSERT INTO `comment` VALUES ('60', '95', '1', '## Docker 容器镜像删除 \r\n\r\n### 1.停止所有的container，这样才能够删除其中的images：\r\n```\r\ndocker stop $(docker ps -a -q)\r\n```\r\n如果想要删除所有container的话再加一个指令：\r\n```\r\ndocker rm $(docker ps -a -q)\r\n```\r\n### 2.查看当前有些什么images\r\n```\r\ndocker images\r\n```\r\n### 3.删除images，通过image的id来指定删除谁\r\n```\r\ndocker rmi <image id>\r\n```\r\n想要删除untagged images，也就是那些id为<None>的image的话可以用\r\n```\r\ndocker rmi $(docker images | grep \"^<none>\" | awk \"{print $3}\")\r\n```\r\n要删除全部image的话\r\n```\r\ndocker rmi $(docker images -q)\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-26 13:42:10');
INSERT INTO `comment` VALUES ('61', '95', '1', '## 第一种：进入容器内部获取信息\r\n\r\n执行以下命令可进入容器内部：\r\n```\r\ndocker exec -it tomcat001 /bin/bash1\r\n```\r\n此时已进入容器内部，所以分别执行hostname、ip addr、env这三个命令可以获取相关信息\r\n\r\n## 第二种：执行docker exec命令\r\n\r\n不用进入容器，直接在docker环境执行docker exec 容器名 容器内命令的方式也可以获取相关信息，举例如下：\r\n \r\n1. 获取容器的hostname：docker exec tomcat001 hostname \r\n\r\n2. 获取容器ip地址：docker exec tomcat001 ip addr\r\n \r\n3. 获取容器环境变量：docker exec tomcat001 env\r\n\r\n## 第三种：使用docker inspect命令\r\n\r\n推荐使用docker inspect来获取信息，这个命令会返回一个json字符串，里面以key-value的格式准备了该容器相关的信息，内容十分丰富，可以一次性取得全部内容，也可以返回指定key对应的信息；\r\n\r\n执行命令docker inspect tomcat001\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-26 14:38:41');
INSERT INTO `comment` VALUES ('62', '96', '1', '## centos7系统yum卸载后重新安装\r\n\r\n想在centos上玩python3，可是我用的最新的centos7系统上默认自带的也是python2.7的版本，我本身又不想再折腾python3以下的版本，所以就像彻底删掉，没想到由于yum需要依赖python2，竟然没删掉，一气之下连yum也一并删掉了，删掉后在需要安装软件的时候才发现只用rpm安装是有多费劲，还需要先把安装包下载到本地，不能在线安装，还要自己处理各种软件依赖，这让比较懒的我更加难受，在吐槽yum为嘛还没升级到python3依赖的同时，相比之下更能接受python2存在带来的便利。在此也劝各位想折腾的朋友，在yum依赖没有升级到python3之前，如果不想处理rpm依赖，还是不要贸然把yum以及python2卸载掉。\r\n\r\nhttps://blog.csdn.net/guanjintao/article/details/79459925', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-26 18:36:53');
INSERT INTO `comment` VALUES ('63', '96', '1', '简书小伙伴的《CentOS7 安装最新版Python2.x》\r\n\r\nhttps://www.jianshu.com/p/ada7ca038d7f', '31', 'xiaowu', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-26 19:30:56');
INSERT INTO `comment` VALUES ('64', '61', '1', '一篇文章，教你学会Git  https://juejin.im/post/599e14875188251240632702', '40', 'xiaobao', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-27 10:39:53');
INSERT INTO `comment` VALUES ('65', '100', '1', '## PHP接口(interface)和抽象类(abstract)\r\n### nterface\r\n\r\n定义了一个接口类，它里面的方法其子类必须实现。接口是类的一个模板，其子类必须实现接口中定义的所有方法。\r\n```\r\ninterface User{\r\n    function getHeight($height);\r\n    function getWeight($weight); \r\n}\r\n\r\nclass my implements User{\r\n    function getHeight($username){\r\n        echo $height;\r\n    }\r\n\r\n    function getWeight($weight){\r\n        echo $weight;\r\n    }\r\n}\r\n```\r\n\r\n### abstract\r\n\r\n抽象类就把类像的部分抽出来,就是把重复的东西写到抽象类中，减少工作量。只要方法没有用abstract声明，在其子类中就不用实现。而且在子类中该方法为公共方法。\r\n```\r\nabstract User{\r\n\r\n    abstract function getHeight($height);\r\n\r\n    function getWeight(){\r\n        echo $weight;\r\n    }\r\n}\r\n\r\nclass my extends User{\r\n\r\n    function getHeight($height){\r\n         echo $height;\r\n    }\r\n\r\n    function getInfoById($id){\r\n        $this->getWeight.“<br/>”;\r\n        echo $id;\r\n    }\r\n}\r\n```', '40', 'xiaobao', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-27 11:54:28');
INSERT INTO `comment` VALUES ('66', '100', '1', '抽象基类没办法被实例化 ,必须继承', '40', 'xiaobao', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-27 12:02:37');
INSERT INTO `comment` VALUES ('67', '99', '1', '## composer  https://packagist.org/search/?q=orm', '40', 'xiaobao', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-27 14:22:40');
INSERT INTO `comment` VALUES ('68', '102', '1', '## 趣味数学 https://www.33iq.com/tag/%CA%FD%D1%A7%CC%EC%B5%D8-%C8%A4%CE%B6%CA%FD%D1%A7.html', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-28 17:34:00');
INSERT INTO `comment` VALUES ('69', '105', '1', '在我的例子中，确保存在正确的cert.pem文件是不够的。您还需要使用date.timezone密钥将php.ini中的时区设置为您的实际时区（在我的情况下，我将其设置为America / Los Angeles）。否则，PHP将默认使用UTC，您的系统时钟将显示为关闭。\r\n\r\n## 找到原因后，在网上搜索到了一些关于PHP的时区设置方法： \r\n\r\n1、修改php.ini，在php.ini中找到data.timezone =去掉它前面的;号，然后设置data.timezone = “Asia/Shanghai”;即可。 \r\n\r\n2、在程序PHP 5以上版本的程序代码中使用函数ini_set(\'date.timezone\',\'Asia/Shanghai\');或者date_default_timezone_set(‘Asia/Shanghai\'); \r\n\r\n## 一些常用的时区标识符说明： \r\n```\r\nAsia/Shanghai – 上海 \r\nAsia/Chongqing – 重庆 \r\nAsia/Urumqi – 乌鲁木齐 \r\nAsia/Hong_Kong – 香港 \r\nAsia/Macao – 澳门 \r\nAsia/Taipei – 台北 \r\nAsia/Singapore – 新加坡 \r\n```\r\n\r\n## 函数设置时区方法：\r\n```\r\n<?php \r\nfunction_exists(date_default_timezone_set);//在这他总是返回1,这函数是判断这里面的字符是不是一个定义了的函数名 \r\ndate_default_timezone_set(\"Etc/GMT\");//这是格林威治标准时间,得到的时间和默认时区是一样的 \r\ndate_default_timezone_set(\"Etc/GMT+8\");//这里比林威治标准时间慢8小时 \r\ndate_default_timezone_set(\"Etc/GMT-8\");//这里比林威治标准时间快8小时 \r\ndate_default_timezone_set(\'PRC\'); //设置中国时区 \r\n?>\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-01-30 09:46:53');
INSERT INTO `comment` VALUES ('70', '94', '1', '```\r\ndocker   # docker 命令帮助\r\n\r\nCommands:\r\n    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\r\n    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\r\n    commit    Create a new image from a container\'s changes # 提交当前容器为新的镜像\r\n    cp        Copy files/folders from the containers filesystem to the host path\r\n              # 从容器中拷贝指定文件或者目录到宿主机中\r\n    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\r\n    diff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\r\n    events    Get real time events from the server          # 从 docker 服务获取容器实时事件\r\n    exec      Run a command in an existing container        # 在已存在的容器上运行命令\r\n    export    Stream the contents of a container as a tar archive   \r\n              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\r\n    history   Show the history of an image                  # 展示一个镜像形成历史\r\n    images    List images                                   # 列出系统当前镜像\r\n    import    Create a new filesystem image from the contents of a tarball  \r\n              # 从tar包中的内容创建一个新的文件系统映像[对应 export]\r\n    info      Display system-wide information               # 显示系统相关信息\r\n    inspect   Return low-level information on a container   # 查看容器详细信息\r\n    kill      Kill a running container                      # kill 指定 docker 容器\r\n    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\r\n    login     Register or Login to the docker registry server   \r\n              # 注册或者登陆一个 docker 源服务器\r\n    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出\r\n    logs      Fetch the logs of a container                 # 输出当前容器日志信息\r\n    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT\r\n              # 查看映射端口对应的容器内部源端口\r\n    pause     Pause all processes within a container        # 暂停容器\r\n    ps        List containers                               # 列出容器列表\r\n    pull      Pull an image or a repository from the docker registry server\r\n              # 从docker镜像源服务器拉取指定镜像或者库镜像\r\n    push      Push an image or a repository to the docker registry server\r\n              # 推送指定镜像或者库镜像至docker源服务器\r\n    restart   Restart a running container                   # 重启运行的容器\r\n    rm        Remove one or more containers                 # 移除一个或者多个容器\r\n    rmi       Remove one or more images                 \r\n              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\r\n    run       Run a command in a new container\r\n              # 创建一个新的容器并运行一个命令\r\n    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]\r\n    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\r\n    start     Start a stopped containers                    # 启动容器\r\n    stop      Stop a running containers                     # 停止容器\r\n    tag       Tag an image into a repository                # 给源中镜像打标签\r\n    top       Lookup the running processes of a container   # 查看容器中运行的进程信息\r\n    unpause   Unpause a paused container                    # 取消暂停容器\r\n    version   Show the docker version information           # 查看 docker 版本号\r\n    wait      Block until a container stops, then print its exit code   \r\n              # 截取容器停止时的退出状态值\r\nRun \'docker COMMAND --help\' for more information on a command.\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-02-01 14:03:40');
INSERT INTO `comment` VALUES ('71', '125', '1', '## 求10 个整数中最大值\r\n```\r\n#include<stdio.h>\r\nint main()\r\n{\r\n   int i,max;\r\n   int array[10];\r\n   printf(\"请输入十个整数：\\n\");\r\n   for(i=0;i<10;i++)\r\n   {\r\n    scanf(\" %d\",&array[i]);\r\n   }\r\n   max=array[0];//数组第一个从0开始\r\n   for(i=1;i<10;i++)\r\n   {\r\n      if(max<array[i])\r\n    max=array[i];\r\n   }\r\n   printf(\"max=%d\\n\",max);\r\n   return 0;\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-03-03 16:23:11');
INSERT INTO `comment` VALUES ('72', '127', '1', '## 用C语言编写：输入半径R，求圆的周长、面积和球的体积', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-03-10 15:17:48');
INSERT INTO `comment` VALUES ('73', '127', '1', '```\r\n# include<stdio.h>\r\n\r\nvoid main()\r\n\r\n{\r\n\r\nfloat r,c,s;\r\n\r\nprintf(\"请输入圆的半径： \");\r\n\r\nscanf(\"%f\",&r);    /*用于输入一个浮点数据存放于地址&r*/\r\n\r\nc=2*3.1415926*r;  /*计算周长，赋值给C*/\r\n\r\ns=3.1415926*r*r;   /*用于计算面积*/\r\n\r\nv=4/3*PI*r*r*r; /*用于计算体积*/\r\n\r\nprintf(\"周长c=%8.4f；\\n面积s=\r\n%8.4f；\\n体积v=%8.4f\",c,s,v);   /*周长，面积，体积都是8个字符宽，4位小数*/\r\n\r\n}\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-03-10 15:19:11');
INSERT INTO `comment` VALUES ('74', '130', '1', '## Nginx的启动、停止与重启\r\n### 启动\r\n启动代码格式：nginx安装目录地址 -c nginx配置文件地址\r\n```\r\n[root@LinuxServer sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\r\n ```\r\n\r\n### 停止\r\nnginx的停止有三种方式：\r\n\r\n#### 从容停止\r\n##### 1、查看进程号\r\n```\r\n[root@LinuxServer ~]# ps -ef|grep nginx\r\n ```\r\n#### 2、杀死进程\r\n```\r\n[root@LinuxServer ~]# kill -QUIT 2072\r\n ```\r\n\r\n#### 快速停止\r\n##### 1、查看进程号\r\n```\r\n[root@LinuxServer ~]# ps -ef|grep nginx\r\n ```\r\n\r\n#### 2、杀死进程\r\n```\r\n[root@LinuxServer ~]# kill -TERM 2132\r\n```\r\n或\r\n```\r\n [root@LinuxServer ~]# kill -INT 2132\r\n``` \r\n\r\n### 强制停止\r\n ```\r\n[root@LinuxServer ~]# pkill -9 nginx\r\n ```\r\n\r\n###  重启\r\n1、验证nginx配置文件是否正确\r\n\r\n方法一：进入nginx安装目录sbin下，输入命令./nginx -t\r\n\r\n看到如下显示\r\n```\r\nnginx.conf syntax is ok\r\n\r\nnginx.conf test is successful\r\n```\r\n说明配置文件正确！\r\n\r\n方法二：在启动命令-c前加-t\r\n\r\n### 2、重启Nginx服务\r\n方法一：进入nginx可执行目录sbin下，输入命令./nginx -s reload 即可\r\n\r\n方法二：查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务\r\n\r\n\r\n ', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-03-30 09:37:37');
INSERT INTO `comment` VALUES ('75', '132', '1', '## nginx 安装\r\n```\r\nzypper se nginx\r\nzypper in nginx\r\n```\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-03-30 09:49:45');
INSERT INTO `comment` VALUES ('76', '117', '1', '```\r\nsvnserve -d -r /home/svn\r\nsudo netstat -ntlp\r\n```\r\n', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-04-07 17:37:12');
INSERT INTO `comment` VALUES ('77', '117', '1', '```\r\niptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\r\nservice iptables save #保存iptables规则\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-04-07 17:37:56');
INSERT INTO `comment` VALUES ('78', '117', '1', '[svn命令在linux下的使用](https://www.cnblogs.com/clicli/p/5913330.html)', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-04-07 17:49:58');
INSERT INTO `comment` VALUES ('79', '117', '1', '## 在Linux下安装SVN并配置post-commit\r\nhttps://blog.csdn.net/csdn_heshangzhou/article/details/82532253\r\n\r\n 5.2 给post-commit所有用户可执行权限\r\n```\r\n    chmod -R a+x post-commit\r\n```', '2', 'admin', '/public/img/header-img-comment_03.png', '0', '0', '0', '0', '0', '1', '2019-04-07 17:59:38');

-- ----------------------------
-- Table structure for comment_reply
-- ----------------------------
DROP TABLE IF EXISTS `comment_reply`;
CREATE TABLE `comment_reply` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `comment_id` int(10) unsigned DEFAULT NULL COMMENT '评论id',
  `reply_type` tinyint(2) unsigned DEFAULT '1' COMMENT '1为回复评论，2为回复别人的回复',
  `reply_id` int(10) unsigned DEFAULT NULL COMMENT '回复目标id，reply_type为1时，是comment_id，reply_type为2时为回复表的id',
  `content` text COMMENT '回复内容',
  `to_uid` int(10) unsigned DEFAULT NULL COMMENT '回复目标id',
  `from_uid` int(10) unsigned DEFAULT NULL COMMENT '回复用户id',
  `from_thumb_img` varchar(255) DEFAULT NULL COMMENT '回复者的头像',
  `from_nickname` varchar(50) DEFAULT NULL COMMENT '回复者的昵称',
  `create_time` int(11) unsigned DEFAULT NULL COMMENT '评论时间',
  `to_nickname` varchar(50) DEFAULT NULL COMMENT '冗余回复对象的昵称',
  `is_author` tinyint(2) unsigned DEFAULT NULL COMMENT '0为普通回复，1为后台管理员回复',
  PRIMARY KEY (`id`),
  KEY `comment_id` (`comment_id`) USING BTREE,
  KEY `from_uid` (`from_uid`) USING BTREE,
  KEY `to_uid` (`to_uid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment_reply
-- ----------------------------

-- ----------------------------
-- Table structure for posts
-- ----------------------------
DROP TABLE IF EXISTS `posts`;
CREATE TABLE `posts` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `pid` int(11) unsigned NOT NULL,
  `path` varchar(255) NOT NULL DEFAULT '0',
  `uid` int(11) unsigned NOT NULL DEFAULT '0',
  `title` varchar(50) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `content` text NOT NULL,
  `status` smallint(3) unsigned NOT NULL DEFAULT '1',
  `display` smallint(3) unsigned NOT NULL DEFAULT '1',
  `created_at` timestamp NOT NULL,
  `updated_at` timestamp NOT NULL,
  PRIMARY KEY (`id`),
  KEY `title` (`title`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=136 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of posts
-- ----------------------------
INSERT INTO `posts` VALUES ('1', '2', '0', '2', '面试的时候，你会如何自我介绍？', 'php面试集锦', '**知友毛书记：**\r\n\r\n通过这几年大大小小的面试、总结以及与前辈的交流，我给自己大致设定了一个回答类似”Why don\'t you tell me a little bit of yourself\"问题的模板：\r\n\r\n### 1.大致背景介绍及目前状况 (Background)\r\n类似于“我叫xxx，xxx大学xxx专业研究生在读，本科毕业于xxxx。目前我在xxx组织担任xxx职位，在xxx公司兼任xxx职位……“的大致介绍。\r\n\r\n### 2.职位相关经验介绍(Professional)\r\n举出几个与你面试职位相关的（工作/实习）经历。不要只罗列，要用具体事例告诉面试官你做到了什么，学到了什么，达成了什么。不要说“我表达能力好”和“我勤奋肯干”，要说“我被破例允许以实习生的身份在每天的晨会上做宏观经济简报”和“在主动完成分配的工作之余，我还在实习的两个月内先后帮助同事完成了xx，xx和xx三个项目/报告”。\r\n\r\n跟你面试职位联系紧密的经历优先，其他工作经历的依相关度的递减而优先度递减。比如你要去面投行，之前金融相关的经历肯定要优先考虑，营销方面的经验次之。当然由于很多技巧是可转移（Transferable Skills) 的（比如注重细节，工作负责，主动创新等)，所以如果语言组织的好，不那么相关的工作经历也可以很好地让面试官看出他希望从你身上看到的能力。\r\n例：\r\n```\r\n“我去年夏天在北京xxxx资本市场部实习。实习期间我负责xxx，xxx，xxxx……（简单介绍做过什么）在参与编写只面向重要客户及公司内部的信用债周报中的“新发债推荐”部分时，我通过为投资者简单介绍新发债公司的发债历史，信用情况以及发展前景来为债券作出评估，期间我会通过对公司财务报表分析以简单评估其盈利能力，偿债能力以及现金流“（表现了你的写作能力，分析能力，信息搜集能力，信息整合能力以及财务专业知识过关。而且”重要客户及公司内部“说明你的能力在这种重要任务上足以被信任。）\r\n```\r\n### 3.个人其他值得一提的经历（Personal）\r\n与工作无关，但是能够给面试官留下深刻印象的个人经历。比如曾经骑行西藏，去非洲做过义工，做过TED speaker等等。终极目的是让面试官从感情上产生 “我愿意和这样的人共事”的想法。\r\n\r\n对于面试标准，有这么一个所谓的“候机法则”（我忘了是不是这个名字），意为面试官通过面试要选出一个他愿意与之等一个小时飞机的人。也就是说你要有趣不无聊，让人乐意跟你一起呆至少一个小时。从这个角度看，回答中的第三部分其实是很重要的，这一部分如果答的好，能够成功建立起与面试官的认同感联系（rapport），并且塑造自己的个人形象并唤起面试官对你个人的兴趣。\r\n\r\n如果专业水平过关，那么面试人主要拼的就是这一部分了——是不是招人待见。虽然你会在接下来的整个面试来讨面试官的喜欢，但是在这里开个好头似乎也不是什么坏事。\r\n\r\n————————————————————————————————\r\n\r\n##### 补充1.\r\n\r\n不仅对于这个问题，对于所有的面试问题都请注意“不要只罗列”，要用事例去证明自己（tell a story)。请确定你的每一个”论点“都有”论据“支撑.（你说你xxx，你怎么xxx了？你说你能帮我实现xxx，哪看出来的？）\r\n我曾经在求职节目非你莫属里见过几个哥们上去给自己一通吹，听着干过的事儿都很牛逼，评委一问细节直接去球了。一定要避免这种情况，减分会很严重。\r\n\r\n##### 补充2：\r\n\r\n一般来说这个问题应该在1分钟到1分半钟之内回答完。\r\n\r\n### 知友周晓农：\r\n\r\n　　面试，是在经历了资格审查，笔试筛选后的最后一个环节。要在留下来进行面试的人中胜出，面试中如何自我介绍，很重要。\r\n```\r\n1、比较容易出错的地方是，只想说自己的得意之处，而不顾用人单位的需求。\r\n2、研究用人单位的需求，自己的强项介绍，要与用人单位的需求相对接。\r\n3、适当讲述个人成功的经历和事例，比用自我标榜式的语言讲述好。\r\n4、用人单位会就你的成功经历和事例，提出一些内行的问题，宜明白简洁地回答，以证明自己的实力。\r\n5、细想一下，用人单位可能会提什么问题，要提前有所准备。\r\n6、恰当表明，用人单位以及什么样的岗位，是自己实现人生理想的地方。\r\n7、如能保持轻松，则可能随机应变，处理好面试中该处理好的事。\r\n8、面试，是双方再发现的过程，如果再发现中增强了双方的需求度，那就是最佳效果了。\r\n```\r\n　　万变不离其宗，所有的努力，都是要让用人单位知道，你就是他们所需要的人，你有这个实力，还有很好的潜力。\r\n\r\n　　让用人单位觉得，你不是一个喜欢自吹的人。言过其实，容易让人警觉和讨厌。\r\n\r\n　　防止由于准备或举措不当，以致未能让用人单位发现你，或者不能取得用人单位的信任。\r\n\r\n　　我曾几次参加过面试他人，我是从我个人的体会中，想到了上面这些问题的。\r\n\r\n　　我想你可能并非是要找工作，而是要探讨这个问题，故提供点意见，供参考。　　\r\n\r\n### 知友大于网：\r\n\r\n很多人明明很有能力，但在面试时不能很好的展现出来，26条面试漂亮回答，让你在面试时有效地展示自己的才华，把握机会。\r\n\r\n#### 1、请你自我介绍一下自己好吗？\r\n\r\n回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。\r\n\r\n其实，企业最希望知道的是求职者能否胜任工作，包括：**最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，**这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。\r\n\r\n#### 2、你觉得你个性上最大的优点是什么？\r\n回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在北大青鸟经过一到两年的培训及项目实战，加上实习工作，使我适合这份工作。\r\n\r\n#### 3、说说你最大的缺点？\r\n回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。\r\n\r\n#### 4、你对薪资的要求？\r\n回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\r\n\r\n```\r\n回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。\r\n```\r\n\r\n```\r\n回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\r\n```\r\n\r\n```\r\n回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。\r\n```\r\n#### 5、你对加班的看法？\r\n回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\r\n```\r\n回答样本：如果工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时我也会提高工作效率，减少不必要的加班。\r\n```\r\n#### 6、如果通过这次面试我们录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？\r\n\r\n回答提示：一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\r\n\r\n#### 7、谈谈你对跳槽的看法？\r\n回答提示：\r\n```\r\n①正常的“跳槽”能促进人才合理流动，应该支持。\r\n②频繁的跳槽对单位和个人双方都不利，应该反对。\r\n```\r\n\r\n#### 8、工作中难以和同事、上司相处，你该怎么办？\r\n回答提示：\r\n```\r\n①我会服从领导的指挥，配合同事的工作。\r\n②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。\r\n③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。\r\n④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。\r\n```\r\n#### 9、你对于我们公司了解多少？\r\n回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\r\n\r\n#### 10、最能概括你自己的三个词是什么？\r\n回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，\r\n\r\n#### 11、你的业余爱好是什么？\r\n回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。\r\n\r\n#### 12、作为被面试者给我打一下分？\r\n回答提示：试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\r\n\r\n#### 13、你为什么要离开原来的公司?\r\n回答提示：\r\n```\r\n①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。\r\n②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\r\n```\r\n\r\n#### 14、你欣赏哪种性格的人？\r\n回答提示：诚实、不死板而且容易相处的人、有“实际行动”的人。\r\n\r\n#### 15、你通常如何对待别人的批评？\r\n回答提示：\r\n```\r\n①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。\r\n②我会等大家冷静下来再讨论。\r\n```\r\n\r\n#### 16、怎样对待自己的失败？\r\n回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。\r\n\r\n#### 17、你为什么愿意到我们公司来工作？\r\n回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。\r\n\r\n#### 18、对这项工作，你有哪些可预见的困难？\r\n回答提示：①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\r\n\r\n#### 19、如果录用了你，你将怎样开展工作？\r\n回答提示：\r\n```\r\n①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。\r\n②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\r\n```\r\n\r\n分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了。\r\n\r\n#### 20、你希望与什么样的上级共事？\r\n回答提示：\r\n```\r\n①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。\r\n②最好回避对上级具体的希望，多谈对自己的要求。\r\n③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\r\n```\r\n\r\n分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。\r\n\r\n#### 21、与上级意见不一时，你将怎么办？\r\n回答提示：\r\n```\r\n①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”\r\n②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”\r\n```\r\n\r\n分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。\r\n\r\n#### 22、为什么选择我们公司？\r\n回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。\r\n\r\n分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工作，而不只是探探路。\r\n\r\n#### 23、谈谈如何适应办公室工作的新环境？\r\n回答提示\r\n```\r\n①办公室里每个人有各自的岗位与职责，不得擅离岗位。\r\n②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。\r\n③多请示并及时汇报，遇到不明白的要虚心请教。\r\n④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\r\n```\r\n\r\n#### 24、除了本公司外，还应聘了哪些公司？\r\n回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\r\n\r\n#### 25、你还有什么问题要问吗？\r\n回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\r\n\r\n#### 26、如果你被录用，何时可以到职？\r\n回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。', '1', '1', '2019-01-11 11:11:00', '2019-01-13 13:41:37');
INSERT INTO `posts` VALUES ('2', '1', '0-1', '2', 'PHP面试总结', 'PHP面试总结', '这是面试我所遇到的大部分的知识点，供大家参考，没有写答案，大家自己可以查查，后续我会持续更新\r\n\r\nPHP基础\r\n```\r\n1：变量的传值与引用。\r\n2：变量的类型转换和判断类型方法。\r\n3：php运算符优先级，一般是写出运算符的运算结果。\r\n4：PHP中函数传参，闭包，判断输出的echo，print是不是函数等。\r\n5：PHP数组，数组函数，数组遍历，预定义数组（面试必出）。\r\n6：PHP面向对象，魔术方法，封装、继承、多态。设计模式，包括（单利、工厂、迭代器、装饰、命令、策略）。\r\n7：正则表达式，每个标号含义，邮箱、网址、标签匹配，正则函数（面试必出）。\r\n8：PHP异常处理（级别，错误日志，控制错误输出）（面试必出）。\r\n9：PHP时间函数，日期计算函数。\r\n10：文件系统，记录日志、目录、文件的遍历、上传、多方法得到文件扩展名、文件引用方式、引用函数区别。（面试必出）。\r\n11：会话控制，主要说原理。session与cookie在分布式应用中出现问题的解决方案。\r\n12：PHP模板引擎，常用模板引擎特点，MVC好与不好的地方。\r\n13：PHP安全处理，过滤函数。\r\n14：XML的使用。\r\n15：PHP字符串的处理，包括转义（安全）、编码、截取、定位、与数组间的转换、处理函数等。（面试必出）。\r\n16：Socket编程，各种协议，head头，curl参数含义。\r\n17：网络状态码含义，常用（204，304, 404, 504，502）。\r\n18：Apache配置文件，PHP配置文件，各个含义字段的含义。\r\n19：网络各种攻击的名词含义（SQL攻击、XSS、CSRF、DDos），防止措施。\r\n20：url的处理函数，得到url指定的部分。\r\n```\r\n \r\nMysql基础\r\n```\r\n1：基础sql语句书写（一般让写关联和子查询语句）\r\n2：索引的创建，优缺点，最左原则\r\n3：存储引擎，常用的几个，优缺点，差别，原理（面试必出）\r\n4：sql注入的处理方法\r\n5：mysql处理函数（PHP中封装的）\r\n6：PDO的使用方法，为什么使用\r\n7：mysql的优化，表拆分等\r\n8：事务处理，sql语句的处理效率等\r\n9：数据表字段的类型，同类型间的区别，改如何选取，int(10)与int(11)的区别等。\r\n10：数据库索引使用的那种数据结构，画出数据结构\r\n```\r\n \r\nLinux\r\n```\r\n1：常用命令的使用，vim编辑器的使用。\r\n2：进程，cpu等信息的查看命令。\r\n3：文件内查看命令（主要涉及统计信息）。\r\n4：Shell的使用，命令操作。\r\n5：awk的用法\r\n6：shell杀掉所有的php-fpm进程\r\n```\r\nNoSql\r\n```\r\n1：Redis的应用场景，结合微博业务说出他的具体应用。\r\n2：Redis与MC支持数据的不同点，两者都支持哪些数据结构的存储，写越多越好。\r\n3：Redis持久化存储的原理，与Mysql的应用区别。怎样保持持久化数据与内存数据同步的关系（Redis同步机制）\r\n4：Redis与MC在并发状态下的性能比较。\r\n5：MC的内存管理机制，当一个数据需要存储的时候怎样分配内存空间\r\n6：Redis的内存管理机制，与MC有哪些不同点。\r\n``` \r\n开发环境\r\n```\r\n1：PHP7中的新特性与废弃的特性\r\n2：为什么要使用PHP7，PHP7快在哪里\r\n3：PHP7中对异常和错误的理解\r\n```\r\n版本控制\r\n```\r\n1：git的使用命令，例如：写出版本回退命令。\r\n2：git与svn的区别。\r\n3：如何进行多分支开发，包括多人开发协同，分段测试，上线。\r\n```\r\n\r\nPHP部分\r\n```\r\n1、HTTP Keep-Alive的作用\r\n\r\n2、php数组函数常见的那些? (array_merge、in_array的作用)\r\n\r\n3、PHP中几个输出函数echo，print()，print_r()，sprintf()，var_dump()的区别\r\n\r\n4、不用新变量直接交换现有两个变量的值\r\n\r\n5、heredoc\r\n\r\n6、写个函数来解决多线程同时读写一个文件的问题。\r\n\r\n7、禁掉cookie的session使用方案，设置session过期的方法，对应函数\r\n\r\n8、json格式数据有哪些特点\r\n\r\n9、php获取文件内容的方法，对应的函数\r\n\r\n10、php魔术方法与魔术常量\r\n\r\n11、PHP 如何获取客户端的IP地址\r\n\r\n12、写一个函数，可以遍历文件夹下的所有文件和文件夹。\r\n\r\n13、有mail.log的一个文档，内容为若干邮件地址，用’\\n’分隔换行。挑选sina.com的地址。\r\n\r\n14、PHP缓存技术有哪些? tp是局部还是完全缓存?\r\n\r\n15、strlen()与mb_strlen的作用与区别\r\n\r\n16、写一个函数，尽可能高效的从一个标准url中取出扩展名\r\n\r\n17、php.ini 中safe mod关闭 影响哪些函数和参数，至少写6个？\r\n\r\n18、  约瑟夫环问题\r\n\r\n19、Isset() 、empty()与is_null的区别\r\n\r\n20、求两个文件的相对路径\r\n\r\n21、MVC的优缺点\r\n\r\n22、Session与cookie的联系和区别（运行机制），session共享问题解决方案\r\n\r\n23、正则表达式\r\n\r\n24、写一个函数得到header头信息\r\n```\r\n \r\n\r\nMySQL部分\r\n```\r\n 1、select * from table where (ID = 10)  or (ID = 32) or (ID = 22)  让结果按10, 32, 22的顺序检索出来？\r\n```\r\n \r\n\r\nLinux部分\r\n```\r\n1、Core文件是什么，有什么用？\r\n\r\n2、共享内存除了文件映射还有什么方式？\r\n\r\n3、请解释下列10个shell命令的用途\r\n\r\n4、Linux文件属性有哪些？（共十位）\r\n\r\n5、Linux查询命令\r\n```\r\n \r\n\r\n服务器部分\r\n```\r\n1、Apache与Nginx的优缺点比较 \r\n\r\n2、Cgi 与fastcgi的区别\r\n\r\n3、Select, poll和epoll的区别\r\n\r\n4、Memcache和Redis区别\r\n```\r\n ------------------------------------PHP部分-------------------------------------\r\n\r\nphp部分我是按照面试常问的问题总结的，下面的问题在面试中出场率很高。问题比较基础\r\n\r\n1、HTTP Keep-Alive的作用\r\n```\r\n作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。\r\n\r\n缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。\r\n\r\n解决：Keep-Alive: timeout=5, max=100\r\ntimeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。\r\n```\r\n2、php数组函数常见的那些? (array_merge、in_array的作用)\r\n\r\nPHP中以array_开头的数组函数有哪些，并说出使用方法（至少6个）\r\n\r\n一、数组遍历函数\r\n``` \r\n1 list();  //不是真正的函数，而是PHP的语言结构，用于给一组变量赋值，仅能用于索引数组\r\n2 each();  //返回数组当前元素的键值对，并将指针移动到下一个元素位置\r\n3 while(); //可配合list或each使用：while(list($key, $value) = each($arr)){each $key, $value; }\r\n``` \r\n二、数组内部指针控制\r\n``` \r\n1 current();  //读取指针位置的内容\r\n2 key();      //读取当前指针指向内容的索引值\r\n3 next();     //将数组中的内部指针指向下一单元\r\n4 prev();     //将数组内部指针倒回一位\r\n5 end();      //将数组内部指针指向最后一个元素\r\n6 reset();    //将目前指针指向第一个索引位置\r\n``` \r\n三、数组键值操作函数\r\n``` \r\n1 array_values($arr);       //获得数组的值\r\n2 array_keys($arr);         //获得数组的键名\r\n3 array_flip($arr);         //数组中的值与键名互换（如果有重复前面的会被后面的覆盖）\r\n4 array_search(\'PHP\',$arr); //检索给定的值，加true则是严格类型检查\r\n5 array_reverse($arr);      //将数组中的元素翻转(前后顺序)\r\n6 in_array(\"apple\", $arr);  //在数组中检索apple\r\n7 array_key_exists(\"apple\", $arr); // 检索给定的键名是否存在数组中\r\n8 array_count_values($arr);        // 统计数组中所有值出现的次数\r\n9 array_unique($arr);              // 删除数组中重复的值\r\n``` \r\n四、数组回调函数\r\n``` \r\n1 array_filter(); //使用回调函数过滤数组中的元素，如果回调返回true则当前的元素被包含到返回数组中\r\n2 array_walk();   //回调函数处理数组，自定义函数要有两个参数，本函数第三个参数可以作为回调第三个参数返回\r\n3 array_map();    //可以处理多个数组，每个数组的长度应该相同，传入数组的个数和回调函数参数个数应该一致\r\n``` \r\n二、数组的分段和填充\r\n``` \r\n1 array_slice($arr, 0, 3);    //将数组中的一段取出，此函数忽略键名（数组的分段）\r\n2 array_splice($arr, 0, 3，array(\"black\",\"maroon\"));    //将数组中的一段取出，返回的序列从原数组中删除\r\n3 array_chunk($arr, 3, TRUE);   //将一个数组分割成多个，TRUE为保留原数组的键名（分割多个数组）\r\n``` \r\n四、数组与栈，列队\r\n``` \r\n1 array_push($arr, \"apple\", \"pear\");    //将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数\r\n2 array_pop($arr);    // 将数组栈的最后一个元素弹出（出栈）\r\n3 array_shift($arr);   //数组中第一个元素移出并返回（长度减1，其他元素向前移动一位，数字键名改为从零计数，文字键名不变）\r\n4 array_unshift($arr,\"a\",array(1,2));  //在数组的开头插入一个或多个元素\r\n``` \r\n六、数组的排序\r\n``` \r\n1 sort($arr);      //由小到大，忽略键名\r\n2 rsort($arr);     //由大到小，忽略键名\r\n\r\n3 asort($arr);     //由小到大，保留键名\r\n4 arsort($arr);    //由大到小，保留键名\r\n\r\n5 ksort($arr);     //按照键名正序排序\r\n6 krsort($arr);    //按照键名逆序排序\r\n``` \r\n七、数组的计算\r\n``` \r\n1 array_sum($arr);   //对数组内部的所有元素做求和运算（数组元素的求和）\r\n2 array_merge($arr1, $arr2); //合并两个或多个（相同字符串键名，后面覆盖前面，相同的数字键名，后面的附加到后面）\r\n3  \r\n4 array_diff($arr1, $arr2);       //返回差集结果数组   array_diff_assoc($arr1, $arr2, $arr3);  //返回差集结果数组，键名也做比较\r\n5 array_intersect($arr1, $arr2);  //返回交集结果数组    array_intersect_assoc($arr1, $arr2);   //返回交集结果数组，键名也做比较\r\n```  \r\n\r\n八、其他的数组函数\r\n``` \r\n1 array_unique($arr);   //移除数组中重复的值，新的数组中会保留原始的键名\r\n2 shuffle($arr);        // 将数组的顺序打乱\r\n``` \r\n3、PHP中几个输出函数echo，print()，print_r()，sprintf()，var_dump()的区别\r\n``` \r\n1：echo：是语句不是函数，没有返回值，可输出多个变量值，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。\r\n\r\n2：print：是语句不是函数，有返回值 1 ，只能输出一个变量，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。\r\n\r\n3：print_r：是函数，可以打印复合类型，例如：stirng、int、float、array、object等，输出array时会用结构表示，而且可以通过print_r($str,true)来使print_r不输出而返回print_r处理后的值\r\n\r\n4：printf：是函数，有返回值，返回值是打印内容的长度，把文字格式化以后输出（参看C语言）\r\n\r\n5：sprintf：是函数，跟printf相似，但不打印，而是返回格式化后的文字（该函数把格式化的字符串写写入一个变量中，而不是输出来），其    他的与printf一样。 \r\n``` \r\n例如：  \r\n``` \r\n $str = \"Hello\";    \r\n $number = 123; \r\n $txt = sprintf(\"%s world. Day number %u\",$str,$number)；\r\n //输出： Hello world. Day number 123 \r\n``` \r\n6：var_dump()：函数，输出变量的内容、类型或字符串的内容、类型、长度。常用来调试。\r\n\r\n可以通过function_exists(\'函数名称\')进行测试\r\n``` \r\n var_dump(function_exists(\'print\'));  //bool(false)\r\n  \r\n var_dump(function_exists(\'echo\'));  //bool(false)\r\n  \r\n var_dump(function_exists(\'print_r\')); //bool(true)\r\n``` \r\n4、不用新变量直接交换现有两个变量的值\r\n```   \r\n   list($a, $b) = array($b, $a);\r\n   $a = $a . $b;\r\n   $b = strlen( $b );\r\n   $b = substr( $a, 0, (strlen($a) – $b ) );\r\n   $a = substr( $a, strlen($b) );\r\n``` \r\n \r\n3:(必须用一个两个字符串都都不能出现的字符做为分隔符)\r\n``` \r\n       $a = $b.\',\'.$a ;\r\n       $a = explode(\',\', $a);\r\n       $b = $a[1];\r\n       $a = $a[0];\r\n```  \r\n4：这个是当两个数都是数字的时候:\r\n``` \r\n       $a = $a + $b;\r\n       $b = $a – $b;\r\n       $a = $a – $b;\r\n```  \r\n5：借助数组\r\n``` \r\n     $a = array($a,$b);\r\n     $b = $a[0];\r\n     $a = $a[1];\r\n``` \r\n5、heredoc\r\n``` \r\nHeredoc在正规的PHP文档中和技术书籍中一般没有详细讲述。他是一种Perl风格的字符串输出技术。使用heredoc技术可以实现界面与代码的准分离，比如phpwind模板。\r\n\r\nheredoc的语法是用”<<<”加上自己定义成对的标签，在标签范围內的文字视为一个字符串\r\n``` \r\n规则如下：\r\n  \r\n1、以<<<End开始标记开始，以End结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。开始标记和开始标记相同，比如常用大写的EOT、EOD、EOF来表示，也可以使用其他标记，只要保证开始标记和结束标记不在正文中出现就行。\r\n\r\n2、位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在heredoc中，变量不需要用连接符 . 或 , 来拼接，比如：\r\n``` \r\n$a=2;\r\n$b= <<<EOF\r\n\"zyf\"$a\r\n\"zyf\"\r\nEOF;\r\n echo $b; //结果连同双引号一起输出：\"zyf\"2 \"zyf\"\r\n``` \r\n3、heredoc常用在输出包含大量HTML语法文档的时候。他要比传统的echo输出精炼很多，如下所示：\r\n\r\n``` \r\n function getHtml(){\r\n      echo \"<html>\";\r\n      echo \"<head><title>Title</title></head>\";\r\n      echo \"<body>Content</body>\";\r\n      echo \"</html>;\r\n  }\r\n   \r\n function getHtml(){\r\n  echo <<<EOT\r\n        <html>\r\n        <head><title>Title</title></head>\r\n        <body>Content</body>\r\n        </html>\r\nEOT;\r\n  }\r\n``` \r\n \r\n6、写个函数来解决多线程同时读写一个文件的问题。\r\n``` \r\n 1 <?php\r\n 2     $fp = fopen(\"/tmp/lock.txt\",\"w+\");\r\n 3     if(flock($fp, LOCK_EX)){// 进行排它型锁定\r\n 4         fwrite($fp,\"Write something here\\n\");\r\n 5         flock($fp, LOCK_UN);// 释放锁定\r\n 6     }else{\r\n 7         echo \"Couldn\'t lock the file !\";\r\n 8     }\r\n 9     fclose($fp);\r\n10 ?>\r\n``` \r\n \r\n\r\n7、禁掉cookie的session使用方案，设置session过期的方法，对应函数\r\n\r\n通过 url 传值，把session id附加到url上（缺点：整个站点中不能有纯静态页面，因为纯静态页面session id 将无法继续传到下一页面）\r\n通过隐藏表单，把session id 放到表单的隐藏文本框中同表单一块提交过去（缺点：不适用a标签这种直接跳转的非表单的情况）\r\n直接配置php.ini文件,将php.ini文件里的session.use_trans_sid= 0设为1,（好像在win上不支持）\r\n用文件、数据库等形式保存Session ID，在跨页过程中手动调用\r\n``` \r\n 1 第一种  setcookie() 直接用setcookie设置session id的生命周期。\r\n 3     $lifetime=60; //保存1分钟 \r\n 4     session_start(); \r\n 5     setcookie(session_name(), session_id(), time()+$lifetime, \"/\");\r\n 6 第二种  session_set_cookie_params()    \r\n 7     $lifetime=60;//保存1分钟\r\n 8     session_set_cookie_params($lifetime);\r\n 9     session_start();\r\n10     session_regenerate_id(true);\r\n11     其中session_regenerate_id();方法用于改变当前session_id的值，并保留session中数组的值。参数默认为 false,如果设置为true则改变session_id的值，并清空当前session数组。\r\n``` \r\n8、json格式数据有哪些特点 \r\n\r\n　　JSON 一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、 Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速率)。\r\n\r\nJSON的结构基于下面两点\r\n\r\n1. \"名称/值\"对的集合 不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等\r\n\r\n2. 值的有序列表 多数语言中被理解为数组(array)\r\n\r\n \r\n9、php获取文件内容的方法，对应的函数\r\n1：file_get_contents得到文件的内容（可以以get和post的方式获取），整个文件读入一个字符串中\r\n2：用fopen打开url, 以get方式获取内容（借助fgets()函数）\r\n3：用fsockopen函数打开url（可以以get和post的方式获取），以get方式获取完整的数据，包括header和body\r\n4：使用curl库获取内容，使用curl库之前，需要查看php.ini，查看是否已经打开了curl扩展\r\n\r\n10、php魔术方法与魔术常量\r\n类方法：\r\n1、__construct(); \r\n　　说明：具有构造函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。\r\n2、__destruct(); \r\n　　说明：析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。\r\n \r\n方法重载：\r\n3、__call();\r\n　　说明：在对象中调用一个不可访问方法时，__call(); 方法会被调用。\r\n4、__callStatic();\r\n　　说明：用静态方式中调用一个不可访问方法时，__callStatic(); 方法会被调用。\r\n \r\n属性重载：(只对类中私有受保护的成员属性有效)\r\n5、__get();\r\n　　说明：读取不可访问属性的值时，__get() 会被调用。\r\n6、__set();\r\n　　说明：在给不可访问属性赋值时，__set() 会被调用。\r\n7、__isset();\r\n　　说明：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。\r\n8、__unset();\r\n　　说明：当对不可访问属性调用 unset() 时，__unset() 会被调用。\r\n \r\n序列化相关：\r\n9、__sleep();\r\n　　说明：序列化时调用，serialize() 函数会检查类中是否存在该魔术方法。如果存在，该方法会先被调用，然后才执行序列化操作。\r\n10、__wakeup();\r\n　　说明：unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用该方法，用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作\r\n \r\n操作类和对象方法：\r\n```\r\n11、__toString();\r\n　　说明：方法用于一个类被当成字符串时调用，例如把一个类当做字符串进行输出\r\n12、__invoke()；\r\n　　说明：当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。\r\n13、__set_state()；\r\n　　说明：当调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组\r\n14、__clone();\r\n　　说明：当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值。\r\n15、__autoload();\r\n　　说明：该方法可以自动实例化需要的类。当程序要用一个类但没有被实例化时，改方法在指定路径下查找和该类名称相同的文件。否则报错。\r\n16 __debugInfo();\r\n　　说明：php5.6增加的特性，var_dump()一个类时触发，返回一个包含对象属性的数组\r\n```　　\r\n说明：PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。\r\n \r\n常量：\r\n``` \r\n__LINK__      //文件中的当前行号。\r\n__FILE__       //文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。\r\n__DIR__       //文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录，它等价于 dirname(__FILE__)。\r\n \r\n__FUNCTION__       //函数名称。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。\r\n __CLASS__              //类的名称。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。\r\n __METHOD__         //类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。\r\n __NAMESPACE__   //当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增）\r\n ``` \r\n11、PHP 如何获取客户端的IP地址\r\n\r\n用$_SERVER获取的IP地址有什么问题？\r\n``` \r\n$_SERVER[\'REMOTE_ADDR\'] ;   通过全局数组来获得 \r\n\r\ngetenv(\'REMOTE_ADDR\') ; 通过环境变量来获得\r\n``` \r\n当客户机使用代理的时候获取不到真实的IP地址\r\n\r\n \r\n\r\n12、写一个函数，可以遍历文件夹下的所有文件和文件夹。\r\n\r\n``` \r\n 1     function get_dir_info($path){\r\n 2           $handle = opendir($path);//打开目录返回句柄\r\n 3           while(($content = readdir($handle))!== false){\r\n 4                 $new_dir = $path . DIRECTORY_SEPARATOR . $content;\r\n 5                 if($content == \'..\' || $content == \'.\'){\r\n 6                        continue;\r\n 7                 }\r\n 8                 if(is_dir($new_dir)){\r\n 9                       echo \"<br>目录：\".$new_dir . \'<br>\';\r\n10                       get_dir_info($new_dir);\r\n11                 }else{\r\n12                       echo \"文件：\".$path.\':\'.$content .\'<br>\';\r\n13                 }\r\n14           }\r\n15       }\r\n16       get_dir_info($dir);\r\n``` \r\n \r\n\r\n13、有mail.log的一个文档，内容为若干邮件地址，用’\\n’分隔换行。挑选sina.com的地址（包括从文件读取、过滤到列印出来）。\r\n\r\n思路1：用正则表达式（比较慢，效率地，不推荐用）\r\n\r\n思路2：cat mail.log | grep sina.com\r\n\r\n \r\n\r\n14、PHP缓存技术有哪些? tp是局部还是完全缓存?\r\n``` \r\n1. 全页面静态化缓存，也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程\r\n2. 页面部分缓存，将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示\r\n3. 数据缓存，通过一个id进行请求的数据,将数据缓存到一个php文件中,id和文件是对应的,下次通过这个id进行请求时 直接读php文件\r\n4. 查询缓存，和数据缓存差不多,根据查询语句进行缓存;\r\n5. 常用的缓存技术有：redis和memcache\r\n个人认为tp应该是全局缓存 因为：tp缓存实在本地生成一个php文件来存储数据库中读取出来的数据\r\n```  \r\n15、strlen()与mb_strlen的作用与区别\r\n在PHP中，strlen与mb_strlen是求字符串长度的函数\r\nPHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。\r\n \r\n采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串str长度，可以用mbstrlen(str,\'UTF-8\')。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。\r\n\r\n需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。\r\n \r\n16、写一个函数，尽可能高效的从一个标准url中取出扩展名\r\n```  \r\n$arr = parse_url(\'http://www.sina.com.cn/abc/de/fg.php?id=1\');\r\nresult=pathinfo(arr[\'path\']);var_dump($arr);\r\nvar_dump($result[\'extension\']);\r\n```  \r\n17、php.ini 中safe mod关闭 影响哪些函数和参数，至少写6个？\r\n ``` \r\nmove_uploaded_file()        exec()\r\nsystem()                              passthru()\r\npopen()                              fopen()\r\nmkdir()                               rmdir()\r\nrename()                            unlink()\r\ncopy()                                 chgrp()\r\nchown()                              chmod()\r\ntouch()                               symlink()\r\nlink()                                   parse_ini_file()\r\nset_time_limit()                  max_execution_time mail()\r\n ``` \r\n\r\n18、一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。\r\n\r\n``` \r\n 1 <？php\r\n 2  function fuhuan($allnum, $ti){\r\n 3      $arr = array();\r\n 4      for($i = 0; $i < $allnum; $i++){\r\n 5          $arr[$i] = $i;\r\n 6      }\r\n 7  \r\n 8      $nums = 1;\r\n 9      while(count($arr) > 1){\r\n10           foreach ($arr as $key => $value) {\r\n11               if($nums == $ti){\r\n12                   unset($arr[$key]);\r\n13                   $nums = 1;\r\n14               }else{\r\n15                   $nums++;\r\n16               }\r\n17          }\r\n18      }\r\n19      $new_arr = array_values($arr);\r\n20      var_dump($new_arr[0] + 1);\r\n21  }\r\n22  fuhuan(10,10);\r\n``` \r\n 19、isset() 、empty()与is_null的区别\r\n\r\n1、当变量未定义时，is_null() 和“参数本身”是不允许作为参数判断的，会报Notice警告错误；\r\n\r\n2、empty , isset首先都会检查变量是否存在，然后对变量值进行检测。而is_null 和 “参数本身”只是直接检查变量值，是否为null，因此如果变量未定义就会出现错误！\r\n\r\n3、isset()：仅当null和未定义，返回false；\r\n\r\n4、empty()：\"\"、0、\"0\"、NULL、FALSE、array(),未定义，均返回true；\r\n\r\n5、is_null()：仅判断是否为null，未定义报警告；\r\n\r\n6、变量本身作为参数，与empty()一致，但接受未定义变量时，报警告；\r\n\r\n \r\n\r\n20、求两个文件的相对路径(这题没什么实际意义)\r\n\r\n``` \r\n 1  getpath(\'/a/b/c/d/e.php\', \'/a/d/12/34/c.php\');\r\n 2   \r\n 3 public function getpath($a, $b)\r\n 4 {\r\n 5      $aarr = explode(\'/\', $a);\r\n 6      $barr = explode(\'/\', $b);\r\n 7      $count = count($barr) - 2;\r\n 8      $pathinfo = \'\';\r\n 9      for($i = 1; $i <= $count; $i++){\r\n10          if($aarr[$i] == $barr[$i]){\r\n11               $pathinfo .= \'../\';\r\n12          }else{\r\n13               $pathinfo .= $barr[$i] . \'/\';\r\n14          }\r\n15      }\r\n16      echo $pathinfo;\r\n17 }\r\n``` \r\n \r\n\r\n21、MVC的优缺点\r\n1、 MVC的优点 \r\n``` \r\n      　　（1） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。 \r\n      　　（2） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。 \r\n      　　（3） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。 \r\n      　　（4） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。 \r\n``` \r\n2、 MVC的不足之处 \r\n``` \r\n      　　（1） 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 \r\n      　　（2） 视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 \r\n      　　（3） 视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 \r\n      　　（4） 目前，一般高级的界面工具或构造器不支持MVC模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。 \r\n ``` \r\n \r\n22、session与cookie的联系和区别（运行机制），session共享问题解决方案\r\n区别与联系：\r\n    使用session_start()调用session，服务器端在生成session文件的同时生成session ID哈希值和默认值为PHPSESSID的session name，并向客户端发送变量为PHPSESSID(session name)(默认)值为一个128位的哈希值。服务器端将通过该cookie与客户端进行交互，session变量的值经php内部系列化后保存在服务器 机器上的文本文件中，和客户端的变量名默认情况下为PHPSESSID的coolie进行对应交互，即服务器自动发送了http 头:header(‘Set-Cookie: session_name()=session_id(); path=/’);即setcookie(session_name(),session_id());当从该页跳转到的新页面并调用 session_start()后,PHP将检查与给定ID相关联的服务器端存贮的session数据，如果没找到则新建一个数据集。\r\n共享方案：\r\n1：使用数据库保存session， 使用数据库来保存session，就算服务器宕机了也没事，session照样在。\r\n问题：程序需要定制；每次请求都进行数据库读写开销不小，另外数据库是一个单点，可以做数据库的hash来解 决这个问题。       \r\n\r\n2：使用 memcached来保存session， 这种方式跟数据库类似，内存存取性能比数据库好很多。\r\n\r\n问题：程序需要定制，增加 了工作量；存入memcached中的数据都需要序列化，效率较低，断电或者重启电脑容易丢失数据；\r\n\r\n3： 通过加密的cookie，在A服务器上登录，在用户的浏览器上添加加密的cookie，当用户访问B服务器时，检查有无Session，如果没有，就检验 Cookie是否有效，Cookie有效的话就在B服务器上重建session。简单，高效， 服务器的压力减小了，因为session数据不存在服务器磁盘上。根本就不会出现session读取不到的问题。\r\n\r\n问题：网络请求占用很多。每次请求时，客户端都要通过cookie发送session数据给服务器，session中数据不能太多，浏览器对cookie 的大\r\n\r\n小存在限制。不适合高访问量的情况，因为高访问量的情况下。\r\n\r\n \r\n\r\n## 23、 正则表达式\r\n\r\n正则表达式一定要会, 通过正则表达式能很容易的看出一个人的基础\r\n```\r\n匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] \r\n匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] \r\n匹配空行的正则表达式：\\n[\\s| ]*\\r \r\n匹配HTML标记的正则表达式：/<(.*)>.*<\\/\\1>|<(.*) \\/>/ \r\n匹配首尾空格的正则表达式：(^\\s*)|(\\s*$) \r\n匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* \r\n匹配网址URL的正则表达式：^[a-zA-z]+://(\\\\w+(-\\\\w+)*)(\\\\.(\\\\w+(-\\\\w+)*))*(\\\\?\\\\S*)?$ \r\n匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ \r\n匹配国内电话号码：(\\d{3}-|\\d{4}-)?(\\d{8}|\\d{7})? \r\n匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$ \r\n```\r\n \r\n\r\n24、写一个函数得到header头信息\r\n\r\n``` \r\nfunction getHeader()\r\n{\r\n    $headers = [];\r\n    if (function_exists(\'getallheaders\')) {\r\n        $headers = getallheaders();\r\n    } elseif (function_exists(\'http_get_request_headers\')) {\r\n        $headers = http_get_request_headers();\r\n    } else {\r\n        foreach ($_SERVER as $key => $value) {\r\n            if(strstr($key, \'HTTP_\')) {\r\n                $newk = ucwords(strtolower(str_replace(\'_\', \'-\', substr($key, 5))));\r\n                $headers[$newk] = $value;\r\n            }\r\n        }\r\n    }\r\n\r\n    var_dump($headers);\r\n}\r\n``` \r\n------------------------MySQL部分-----------------------\r\n\r\n 1、select * from table where (ID = 10)  or (ID = 32) or (ID = 22)  让结果按10, 32, 22的顺序检索出来？\r\n```\r\nSelect *\r\nfrom user_info\r\nWhere (ID IN (10, 32, 22))\r\n\r\norder BY FIND_IN_SET(ID, \'10, 32, 22\')\r\n```\r\n----------------------linux部分-----------------------\r\n\r\n## 1、core文件是什么，有什么用？\r\n ``` \r\n core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。\r\n什么是core dump Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容扔出来生成的，它可以做为调试程序的参考.\r\n    core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。如何使用core文件 gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 在哪个函数中.\r\n为什么没有core文件生成呢? core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.\r\nulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号\r\n不用core文件，程序出了问题产生信号是否知道？答：内核向进程发信号嘛。\r\n``` \r\n \r\n\r\n2、共享内存除了文件映射还有什么方式？\r\n``` \r\n共享内存对象映射。\r\n\r\n二者有什么区别：\r\n\r\n区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。\r\n``` \r\n \r\n\r\n3、请解释下列10个shell命令的用途\r\ntop、ps、mv、find、df、cat、chmod、chgrp、grep、wc\r\n``` \r\ntop：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 \r\nps：查看进程 \r\nmv：移动或者更改文件 \r\nfind：在子目录中搜索匹配的文件 \r\ndf：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。\r\ncat：把一个或多个文件内容显示到标准输出 \r\n\r\nchmod：改变文件属性 \r\n\r\nchgrp：改变用户分组 \r\n\r\ngrep：在文件内进行搜索 \r\n\r\nwc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。\r\n``` \r\n \r\n\r\n### 4、Linux文件属性有哪些？（共十位）\r\n``` \r\n-rw-r--r--那个是权限符号，总共是- --- --- ---这几个位。\r\n``` \r\n第一个短横处是文件类型识别符：\r\n\r\n-表示普通文件；\r\n\r\nc表示字符设备（character）；\r\n\r\nb表示块设备（block）；\r\n\r\nd表示目录 （directory）；\r\n\r\nl表示链接文件（link）；\r\n\r\n后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个连续短横是其他权限位（Other）。\r\n\r\n每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- --- --- ---。\r\n\r\n权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：\r\n```\r\n一个文件aaa具有完全空的权限- --- --- ---。\r\n\r\nchmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- --- ---）\r\n\r\nchmod g+r aaa（给组设置权限为可读，其权限表示为：- --- r-- ---）\r\n\r\nchmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）\r\n\r\n如果aaa具有满权限- rwx rwx rwx。\r\n\r\nchmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）\r\n\r\n如果要给aaa赋予制定权限- rwx r-x r-x，命令为：\r\n\r\nchmod u=rwx，go=rx aaa\r\n```\r\n \r\n### 5、linux查询命令\r\n``` \r\n1：find / -name \"文件名\"    在目录结构中搜索文件，并执行指定的操作。\r\n2：grep\r\n3：local 文件名  ---他是 \'find -name\' 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\r\n4. whereis ---是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\r\n5：which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\r\n``` \r\n\r\n -------------------服务器部分-------------------\r\n\r\n \r\n## 1、Apache与Nginx的优缺点比较 \r\n### 1、nginx相对于apache的优点： \r\n轻量级，比apache 占用更少的内存及资源。高度模块化的设计，编写模块相对简单 \r\n抗并发，nginx 处理请求是异步非阻塞，多个连接（万级别）可以对应一个进程，而apache 则是阻塞型的，是同步多进程模型，一个连接对应一个进程，在高并发下nginx 能保持低资源低消耗高性能 \r\nnginx处理静态文件好，Nginx 静态处理性能比 Apache 高 3倍以上 \r\n\r\n### 2、apache 相对于nginx 的优点： \r\napache 的rewrite 比nginx 的rewrite 强大 ，模块非常多，基本想到的都可以找到 ，比较稳定，少bug ，nginx 的bug 相对较多 \r\n \r\n### 3：原因：这得益于Nginx使用了最新的epoll（Linux 2.6内核）和kqueue（freebsd）网络I/O模型，而Apache则使用的是传统的select模型。目前Linux下能够承受高并发访问的 Squid、Memcached都采用的是epoll网络I/O模型。 处理大量的连接的读写，Apache所采用的select网络I/O模型非常低效。\r\n \r\n \r\n## 2、cgi 与fastcgi的区别\r\ncgi在2000年或更早的时候用得比较多， 以前web服务器一般只处理静态的请求，web服务器会根据这次请求的内容，然后会fork一个新进程来运行外部c程序 （或perl脚本...）， 这个进程会把处理完的数据返回给web服务器，最后web服务器把内容发送给用户，刚才fork的进程也随之退出。 如果下次用户还请求改动态脚本，那么web服务器又再次fork一个新进程，周而复始的进行。\r\n\r\n后来出现了一种更高级的方式是， web服务器可以内置perl解释器或php解释器。 也就是说这些解释器做成模块的方式，web服务器会在启动的时候就启动这些解释器。 当有新的动态请求进来时，web服务器就是自己解析这些perl或php脚本，省得重新fork一个进程，效率提高了。\r\n\r\nfastcgi的方式是，web服务器收到一个请求时，他不会重新fork一个进程（因为这个进程在web服务器启动时就开启了，而且不会退 出），web服务器直接把内容传递给这个进程（进程间通信，但fastcgi使用了别的方式，tcp方式通信），这个进程收到请求后进行处理，把结果返回 给web服务器，最后自己接着等待下一个请求的到来，而不是退出。 \r\nfastcgi跟cgi的区别是：\r\n在web服务器方面 \r\n\r\n在对数据进行处理的进程方面\r\n\r\ncgi         fork一个新的进程进行处理                                           \r\n\r\n读取参数，处理数据，然后就结束生命期\r\n\r\nfastcgi   用tcp方式跟远程机子上的进程或本地进程建立连接       \r\n\r\n要开启tcp端口，进入循环，等待数据的到来，处理数据\r\n\r\n\r\n举个例子: 服务端现在有个10万个字单词， 客户每次会发来一个字符串，问以这个字符串为前缀的单词有多少个。 那么可以写一个程序，这个程序会建一棵trie树，然后每次用户请求过来时可以直接到这个trie去查找。 但是如果以cgi的方式的话，这次请求结束后这课trie也就没了，等下次再启动该进程时，又要新建一棵trie树，这样的效率就太低下了。   而用fastcgi的方式的话，这课trie树在进程启动时建立，以后就可以直接在trie树上查询指定的前缀了。\r\n\r\n \r\n\r\n## 3、select, poll和epoll的区别\r\n#### select\r\nselect最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。\r\n\r\nselect目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。\r\n\r\nselect的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。\r\n\r\n另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。\r\n\r\n### poll\r\npoll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。 \r\n\r\npoll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 \r\n\r\n另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。\r\n\r\n### epoll\r\n直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。\r\n\r\nepoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。\r\n\r\nepoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了 这些文件描述符在系统调用时复制的开销。\r\n\r\n另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。\r\n\r\n## 4、Memcache和Redis区别\r\n\r\n1:  Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。\r\n\r\n2:  Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存。\r\n\r\n3:  他们的扩展都需要做集群；实现方式：master-slave、Hash。\r\n\r\n4:  在100k以上的数据中，Memcached性能要高于Redis。\r\n\r\n5:  如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。当然，这和你的应用场景和数据特性有关。\r\n\r\n6:  如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcached都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。\r\n\r\n7:  Redis和Memcache在写入性能上面差别不大，读取性能上面尤其是批量读取性能上面Memcache更强', '1', '1', '2019-01-11 11:11:00', '2019-01-18 05:38:55');
INSERT INTO `posts` VALUES ('3', '2', '0', '2', 'php面试必问的面试问题', 'php面试必问的面试问题', '1、css的定位有哪些方式？以及用法\r\n\r\n\r\nposition 在英文中表示“位置”的意思 它主要是用于实现对元素的定位\r\n\r\n在CSS中定位分为三种：\r\n\r\nposition:fixed 固定定位\r\n\r\nposition:relatvie 相对定位\r\n\r\nposition:absolute 绝对定位\r\n\r\nposition:static 　无特殊定位 (默认值)。\r\n\r\n注意：\r\n\r\n在使用定位属性时，一定要配合定位的坐标来使用！\r\n\r\nleft：表示定位的元素离左边多远\r\n\r\nright：表示定位的元素离右边多远\r\n\r\ntop：表示定位的元素离上边多远\r\n\r\nbottom：表示定位的元素离下边多远\r\n\r\n1固定定位\r\n\r\n语法：\r\n\r\nposition:fixed\r\n\r\n固定定位，它是相对于浏览器窗口来进行定位。不管页面如何滚动，固定定位元素显示的位置不会改变！\r\n\r\n特点：\r\n\r\n固定定位元素它脱离了标准文档流\r\n\r\n固定定位元素的的层级比标准文档流里面的元素要高 所以固定定位元素它会压盖住标准文档流里面的元素\r\n\r\n固定定位元素它不再占用空间\r\n\r\n固定定位元素它显示的位置不会随着浏览器滚动而滚动\r\n\r\n2相对定位\r\n\r\n语法：\r\n\r\nposition:relative;\r\n\r\n相对定位它是相对于“原来的自己”来进行定位！\r\n\r\n特点：\r\n\r\n相对定位元素它没有脱离标准文档流\r\n\r\n相对定位元素如果没有设置定位的坐标，那么相对定位元素它还在原来的位置\r\n\r\n相对定位元素设置了定位的坐标以后，那么它会在老家留下一个坑\r\n\r\n相对定位元素它会将标准文档流中的元素压盖住。\r\n\r\n相对定位元素的定位坐标值可以是负数\r\n\r\n注意：\r\n\r\n相对定位元素它会在老家留下一个坑，所以一般情况下它很少单独使用，相对定位元素它主要是用来配合“绝对定位”元素来使用的。\r\n\r\n3绝对定位\r\n\r\n语法：\r\n\r\nposition:absolute;\r\n\r\n什么是绝对定位？\r\n\r\n绝对定位元素是相对于“祖先定位元素”来进行定位！\r\n\r\n什么是祖先定位元素？\r\n\r\n绝对定位元素它会先去查找其父元素是否设置了定位的属性\r\n\r\n如果有设置定位的属性 那么它就会相对于其父元素来进行定位；\r\n\r\n但是如果它的父元素没有设置定位属性 那么它就会去查找其父元素的上一级元素是否设置了定位的属性，\r\n\r\n如果有设置就相对于其父元素的上一级元素进行定位\r\n\r\n但是如果没有设置 那么会继续往向一级进行查找，\r\n\r\n如果其祖先元素都没有设置定位属性，那么它会相对于“浏览器窗口”来进行定位！\r\n\r\n①自己设置了绝对定位时：如果父元素没有设置定位属性，那么就相对于body进行定\r\n\r\n②自己设置了绝对定位时：如果父元素也设置定位属性，那么就会相对于父元素进行定位\r\n\r\n③自己设置了绝对定位时：如果父元素也设置定位属性，那么就会相对于父元素进行定位\r\n\r\n2、用JQ发送AJAX请求时，$.ajax需要配置哪些参数？？分别代表什么意义？？\r\n\r\n\r\njQuery.ajax(options)\r\n\r\n参数说明：\r\n\r\noptions ：只有一个参数，要求是JSON格式的数据，其可以设置如下属性：\r\n\r\nasync ：是否异步，true代表异步，false代表同步。默认为true\r\n\r\ncache ：是否缓存，true代表缓存，false代表不缓存，默认为true\r\n\r\ncomplete ：当Ajax状态码为4时所触发的回调函数\r\n\r\ncontentType ：请求头，如果是POST请求，此参数为application/x-www-form-urlencoded\r\n\r\ndata : 发送Ajax请求时所传递的参数，要求是一个字符串\r\n\r\ndataType ：期待的返回值类型，可以是text/xml/json数据类型\r\n\r\nsuccess ：当Ajax状态码为4且响应状态码为200时所触发的回调函数\r\n\r\ntype ：发送的http请求，可以是get，也可以是post\r\n\r\nurl ：请求的url地址\r\n\r\n\r\n\r\n3、什么时候用同步请求？？什么时候用异步请求？？\r\n\r\n\r\n一.什么是同步请求：(false)\r\n\r\n同步请求即是当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码，相当于是排队，前一个人办理完自己的事务，下一个人才能接着办。也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态(即当ajax返回数据后，才执行后面的function2)。 \r\n二.什么是异步请求：(true)\r\n异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。\r\n一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。\r\n\r\n4、PHP有哪些魔术方法？？\r\n\r\n\r\n魔术方法包括：\r\n\r\n__construct()，类的构造函数\r\n\r\n__destruct()，类的析构函数\r\n\r\n__call()，在对象中调用一个不可访问方法时调用\r\n\r\n__callStatic()，用静态方式中调用一个不可访问方法时调用\r\n\r\n__get()，获得一个类的成员变量时调用\r\n\r\n__set()，设置一个类的成员变量时调用\r\n\r\n__isset()，当对不可访问属性调用isset()或empty()时调用\r\n\r\n__unset()，当对不可访问属性调用unset()时被调用。\r\n\r\n__sleep()，执行serialize()时，先会调用这个函数\r\n\r\n__wakeup()，执行unserialize()时，先会调用这个函数\r\n\r\n__toString()，类被当成字符串时的回应方法\r\n\r\n__invoke()，调用函数的方式调用一个对象时的回应方法\r\n\r\n__set_state()，调用var_export()导出类时，此静态方法会被调用。\r\n\r\n__clone()，当对象复制完成时调用\r\n\r\n__autoload()，尝试加载未定义的类\r\n\r\n__debugInfo()，打印所需调试信息\r\n\r\n5、简述get方法和post方法\r\n\r\n\r\n① 传参方式不同\r\n\r\nget请求是在url的尾部传递参数的\r\n\r\npost请求是在请求空白行的位置传递参数的\r\n\r\n② 传参的大小不同\r\n\r\nget请求，其传参的最大值为2kb\r\n\r\npost请求理论上是没有任何限制的，但是实际应用中，受到php.ini文件的影响，一般为2M\r\n\r\n③ 传参的类型不同\r\n\r\nget请求，只能传递字符串\r\n\r\npost请求，不仅可以传递字符串还可以传递二进制数据\r\n\r\n④ 安全性不同\r\n\r\n相对而言，post请求的安全性要略高于get请求\r\n\r\n其请求头参数不同\r\n\r\n6、PHP中的单词函数\r\n\r\n\r\nI接收函数\r\n\r\nM:实例化基础模型类\r\n\r\nD:实例化自定义模型类\r\n\r\nU:对URL地址进行组装\r\n\r\n7、抽象类和接口又什么区别？？\r\n\r\n\r\n1、对接口的使用是通过关键字implements。对抽象类的使用是通过关键字extends。当然接口也可以通过关键字extends继承。\r\n\r\n2、接口中不可以声明成员变量（包括类静态变量），但是可以声明类常量。抽象类中可以声明各种类型成员变量，实现数据的封装\r\n\r\n3、接口没有构造函数，抽象类可以有构造函数。\r\n\r\n4、接口中的方法默认都是public类型的，而抽象类中的方法可以使用private,protected,public来修饰。\r\n\r\n5、一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。\r\n\r\n共同点：做规范用\r\n\r\n抽象类：不能被实例化，只能被继承；通过关键字abstract声明；抽象类中至少要包\r\n\r\n含一个抽象方法，该抽象方法没有方法体，天生要被子类重写；\r\n\r\n接口：通过interface声明；接口中的成员常量和方法都是 public 的，方法可以不写关键字 public；接口能实现多继承；\r\n\r\n抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。抽象类是通过关键字\r\n\r\nabstract 来声明的。\r\n\r\n抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要 包含一个抽象方法，\r\n\r\n抽象方法没有方法体，该方法天生就是要被子类重写的。 抽象方法的格式为：abstract function abstractMethod();\r\n\r\n接口是通过 interface 关键字来声明的，接口中的成员常量和方法都是 public 的，方法可 以不写关键字 public，\r\n\r\n接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。 抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽\r\n\r\n象类还是接口要看具体实现。\r\n\r\n子类继承抽象类使用 extends，子类实现接口使用implements。\r\n\r\n8、如何理解命名空间？？\r\n\r\n\r\n防止类和函数方法冲突\r\n\r\n命名空间可以解决下面两个问题：\r\n\r\n（1）用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。\r\n\r\n（2）为很长的标识符创建一个别名，提高代码的可读性，减少代码的编写量。\r\n\r\n9、PHP哪个版本开始支持命名空间？？\r\n\r\n\r\nThinkPHP3.2\r\n\r\nPHP 在 5.3.0 以后的版本开始支持命名空间。\r\n\r\n10、PHP拥有那些扩展？？\r\n\r\n\r\nPDO: PHP访问数据库定义的一个轻量级的一致接口。\r\n\r\nCURL扩展\r\n\r\nGD扩展\r\n\r\nMemcache\r\n\r\nMysql\r\n\r\n11、SVN出现冲突怎么办？？\r\n\r\n\r\nSVN作用：协同开发。\r\n\r\n融合：\r\n\r\n更新：\r\n\r\n12、如何理解MVC？？\r\n\r\n\r\nMVC是一个框架模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。\r\n\r\nMVC所指的就是在软件设计中一种编程模式。在该模式下会将业务操作、数据显示、数据交互会进行一个拆分操作\r\n\r\nM:代表就是具体的模型(model) 主要作用就是与数据库进行数据交互\r\n\r\nV:代表就是具体的视图(view)主要作用就是与用户进行数据交互\r\n\r\nC：代表就是具体的控制器（controller）主要作用就是处理具体的业务逻辑\r\n\r\n由模型(model)，视图(view)，控制器(controller)完成的应用程序，model 层负责提供数据，和数据库有关的操作都交给模型层来处理，view 层则提供交互的界面，并输出数据，而 controller 层则负责接收请求，并分发给相应的 model 来处理，然后调用 view 层来显示。\r\n\r\n13、商品表里有哪些字段？？\r\n商品id，商品名称，商品货号，商品分类id，市场售价，本店售价，商品缩略图，商品缩略小图，是否热卖 1表示热卖 0表示不是，是否推荐 1表示推荐 0表示不推荐，是否热卖 1表示新品 0表示不是，添加时间，表示商品是否删除 1正常 0删除状态，商品是否销售 1销售 0下架状态，\r\n\r\n14、相同商品ID的属性不同，怎么办？？\r\n商品表中的属性存成一个集合，属性表\r\n\r\n15、cookie跟session\r\n\r\n\r\n对比一下两者，有以下几点不同：\r\n\r\n1.作用位置：cookie是在客户端保存用户信息，session实在服务器端保存用户信息；\r\n\r\n2.保存内容：cookie保存的是字符串，session中保存的是对象；\r\n\r\n3.作用时间：cookie可以长期保存在客户端，session随会话结束而关闭；\r\n\r\n4.一般cookie保存不重要的用户信息，重要的信息由session保存。\r\n\r\n5、cookie分为两种：会话cookie和文件Cookie。会话cookie当浏览器关闭时，数据消失，文件Cookie是将数据存储在一个文件中，设置过期时间，关闭浏览器后，若没到过期时间，再次打开浏览器，数据还存在。\r\n\r\n16、购物车的实现原理\r\n\r\n\r\n分两种情况：\r\n\r\n1、用户没有登录，将数据存储在cookie中，若用户登录，再将cookie中的数据转存到数据库。\r\n\r\n2、用户登录后，将数据直接存储到数据库。\r\n\r\n17、RBAC权限管理\r\n基于角色的权限访问控制（Role-Based Access Control）\r\n\r\n五张表：两个中间表 admin、role、rule、admin_role、role_rule\r\n\r\n三张表：一个中间表\r\n\r\n通过代码控制不同的管理员是否能够访问某个方法的过程就是权限控制。\r\n\r\n\r\n\r\nRBAC（Role-Based AccessControl，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。\r\n\r\n18、如何理解接口开发\r\n先下载第三方接口文件，\r\n\r\n19、短信验证码如何防止短信轰炸？？\r\nJS客户端验证验证\r\n\r\n手机号限制短信条数（计数器）\r\n\r\n（一）增加图形验证\r\n\r\n恶意攻击者采用自动化工具，调用“动态短信获取”接口进行动态短信发送，原因主要是攻击者可以自动对接口进行大量调用。\r\n采用图片验证码可有效防止工具自动化调用，即当用户进行“获取动态短信” 操作前，弹出图片验证码，要求用户输入验证码后，服务器端再发送动态短信到用户手机上，该方法可有效解决短信轰炸问题。\r\n\r\n安全的图形验证码必须满足如下防护要求\r\n\r\n- 生成过程安全:图片验证码必须在服务器端进行产生与校验;\r\n- 使用过程安全:单次有效，且以用户的验证请求为准;\r\n- 验证码自身安全:不易被识别工具识别，能有效防止暴力破解。\r\n\r\n图形验证的示例：\r\n\r\n（二）单IP请求次数限制\r\n\r\n使用了图片验证码后，能防止攻击者有效进行“动态短信”功能的自动化调用;\r\n但若攻击者忽略图片验证码验证错误的情况，大量执行请求会给服务器带来额外负担，影响业务使用。建议在服务器端限制单个 IP 在单位时间内的请求次数，一旦用户请求次数(包括失败请求次数)超出设定的阈值，则暂停对该 IP 一段时间的请求;若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请 求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。\r\n\r\n（三）限制发送时长\r\n\r\n建议采用限制重复发送动态短信的间隔时长， 即当单个用户请求发送一次动态短信之后，服务器端限制只有在一定时长之后（此处一般为60秒），才能进行第二次动态短信请求。该功能可进一步保障用户体验，并避免包含手工攻击恶 意发送垃圾验证短信。\r\n\r\n完整的动态短信验证码使用流程\r\n\r\n20、商品的图片上传是怎么处理的？？\r\n21、如何设置session的有效期？？\r\n22、支付的同步回调和异步回调？？\r\n\r\n\r\n具体同步回调跟异步回调\r\n\r\n同步回调作用：实现当用户支付完成之后能够跳转到对应的商户页面（确保用户支付完成之后能够正确的对用户的支付做一个处理操作）\r\n\r\n异步回调作用：确保商户对用户的支付做了一个正确的处理\r\n\r\n23、支付宝的支付流程？\r\n\r\n\r\n1、申请支付宝账户信息，得到相应的APPID与公钥（交给支付宝）、私钥（自己保存）\r\n\r\n2、下载官方文档，在本地搭建demo测试，config.php中设置APPID、同步异步回调地址、支付宝私钥等信息。\r\n\r\n3、创建后台应用\r\n\r\n4、具体使用代码实现支付功能\r\n\r\n24、支付宝异步回调的作用？？\r\n\r\n\r\n异步回调作用：确保商户对用户的支付做了一个正确的处理\r\n\r\n1、确保同步没执行，异步单方面请求。（）\r\n\r\n2、解决掉单问题\r\n\r\n3、比较安全\r\n\r\n同步回调作用：实现当用户支付完成之后能够跳转到对应的商户页面（确保用户支付完成之后能够正确的对用户的支付做一个处理操作）（get方式）\r\n\r\n异步回调作用：确保商户对用户的支付做了一个正确的处理（post方式）\r\n\r\n25、商品模块的多维属性\r\n26、Linux常用的命令\r\n查找文件：\r\n\r\nfind\r\n\r\n-name根据文件名字进行查找\r\n\r\n-group ：根据文件的所属组进行搜索\r\n\r\n-user ：根据文件的拥有者进行搜索\r\n\r\nlocate指令，用于检索数据\r\n\r\nlocate 文件名称\r\n\r\ndf指令：显示磁盘信息\r\n\r\n-l ：显示本地磁盘信息\r\n\r\n-h ：以1024进制显示磁盘信息\r\n\r\n-H ：以1000进制显示磁盘信息\r\n\r\n-T ：显示磁盘格式信息\r\n\r\n-t ：显示指定格式的磁盘信息\r\n\r\ncd 用户名：进入用于\r\n\r\ncd ~ :回到家\r\n\r\nyy:复制 p :粘贴\r\n\r\nvim 文件名： 查看文件\r\n\r\n27、hppt的状态码？？\r\n1、301 MovedPermanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。永久重定向。\r\n\r\n2、302 Move temporarily：请求的资源临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求\r\n\r\n3、404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的\r\n\r\n4、200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是\r\n\r\n\r\n\r\n表示正常状态。\r\n\r\n200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页\r\n201（已创建）：请求成功并且服务器创建了新的资源\r\n202（已接受）：服务器已接受请求，但尚未处理\r\n203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源\r\n204（无内容）：服务器成功处理了请求，但没有返回任何内容\r\n205（重置内容）：服务器成功处理了请求，但没有返回任何内容\r\n206 （部分内容）：服务器成功处理了部分GET 请求\r\n404（未找到）：服务器找不到请求的网页\r\n500（服务器内部错误）：服务器遇到错误，无法完成请求\r\n\r\n28、require与include\r\n\r\n\r\nrequire()语句的性能与include()相类似，都是包括并运行指定文件。\r\n\r\n不同之处在于：对include()语句来说，在执行文件时每次都要进行读取和评估；报错时不会阻止后面的代码运行；而对于require()来说，文件只处理一次（实际上，文件内容替换require()语句）。这就意味着如果可能执行多次的代码，则使用require()效率比较高。另外一方面，如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用include()语句\r\n\r\nincluce在用到时加载\r\n\r\nrequire在一开始就加载\r\n\r\n29、Linux系统中怎么编译PHP程序的扩展？？\r\n1、找到软件压缩包，解压\r\n\r\n2、编译make &&make install\r\n\r\n3、配置php.ini\r\n\r\n4、重启Apache\r\n\r\n30、对事务的理解\r\n\r\n\r\n逻辑上的一组操作，含有几个组成部分，这几个部分构成一个整体，操作要么全部成功，要么全部失败并返回原状态！\r\n\r\n在执行SQL语句之前，先执行start transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所做出的影响会持久化到数据库中。或者rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！\r\n\r\n事务的四大特性（ACID）\r\n\r\n原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。\r\n\r\n一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。\r\n\r\n隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。\r\n\r\n持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。\r\n\r\n31、\r\nPHP获取当前时间 time()\r\n\r\nPhp截取字符串：substr函数\r\n\r\nPHP查找字符串中是否有子串：\r\n\r\n32、五个有关数组处理函数？\r\nIn_array：判断数组中是否存在某个元素\r\n\r\narray_reverse() 将数组中的元素倒叙，返回值为倒叙之后的数组。\r\n\r\narray_splice(array1,start,length,array2) 从数组中移除相应的元素，并用新元素替换它\r\n\r\narray_push() （进栈）向数组的尾部添加一个或多个元素，\r\n\r\narray_pop() （出栈）从数组的中删除最后一个元素\r\n\r\n33、跨域请求有哪几种方式？？\r\nJSONP\r\n\r\nCORS\r\n\r\n34、存储引擎有几个？有什么区别？？\r\nMysiam与innodb\r\n\r\n\r\n\r\nMyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持。\r\nMyISAM 类型的表强调的是性能，其执行速度比 InnoDB 类型更快，但是不提供事务支持，而 InnoDB 提供事务支持以及外部键等高级数据库功能。\r\n创建索引：alert tabletablename add index (`字段名`)\r\n\r\n35、Redis默认端口号？数据类型？\r\n\r\n\r\n6379\r\n\r\nString、hash、list（链表）、set（集合）、zset（有序集合）\r\n\r\n36、Redis实用案例--抢购秒杀、计数器、推荐、收藏案例\r\n秒杀：\r\n\r\n\r\n\r\n使用Redis的list链表，pop操作，即使是很多用户同时到达也是依次执行\r\n\r\n1、现将商品表的库存存入队列\r\n\r\n2、抢购开始，设置库存的缓存周期\r\n\r\n3、客户端执行下单操作，下单前判断redis队列库存量\r\n\r\n计数器：\r\n\r\n37、MySQL中的左链接跟右链接有什么区别？？\r\n\r\n\r\nLeft join（左联接）：是已左表为准，左表中的记录都会出现在查询结果中，如果右表没有相匹配的记录，则以 null 填充。\r\n\r\nRight join（右联接）：是以右表为准，右表中的记录都会出现在查询结果中，如果左表没有相匹配的记录，则以 null 填充。\r\n\r\nInner join（内联接）：两张表地位是平等的，符合联接条件的记录才会出现在查询结果中。\r\n\r\n38、memcache默认端口号？？，Memcache跟Redis的区别??\r\n27017,28017\r\n\r\n\r\n\r\nMemcache 缓存是把所有的数据保存在内存中，采用hash 表的方式，把每条数据有 key 和 value 组成，每个 key 独一无二的，当要访问的某个值的时候先按照找到值，然后在返回结果，Memcache采用 LRU 算法来逐渐把过期的数据清除掉\r\n\r\n39、mysql锁机制\r\n40、数据库优化从哪几个方面做？？\r\n1、设计数据库方面\r\n\r\n2、建立索引\r\n\r\n3、读写分离\r\n\r\n4、缓存\r\n\r\n41、电商项目中，商品库存什么时候会发生变化？？\r\n\r\n\r\n1、添加商品时，商品库存增加。库存表针对不同的属性，添加\r\n\r\n2、订单支付成功时，库存会减少\r\n\r\n3、订单支付失败，库存不会减少\r\n\r\n4、客户退货，库存增加\r\n\r\n42、优化MySQL的查询\r\n1、避免全表查询，给相应字段建立索引\r\n\r\n2、避免查询语句过长，分批查询。\r\n\r\n3、where后面不能有函数运算\r\n\r\n4、左原则like第一个字段要有索引\r\n\r\n5、在where和group by后面建立索引', '1', '1', '2019-01-11 11:11:00', '2019-01-13 23:27:58');
INSERT INTO `posts` VALUES ('4', '2', '0', '2', '一位资深php程序员在北京的面试30个题目', '$error_arr = $re->errorInfo();', '1、SESSION 保存在服务器的哪里？\r\n2、服务端是如何获取客户端的cookie?\r\n3、如何实现SESSION共享，共享的原理是什么？\r\n4、请大致说出LVS搭建的过程，文件共享原理是什么？\r\n5、网络共享服务器上传数据是向一台服务器上传？还是多台？如何实现同步?\r\n6、说出你所知道的数据库设计范式？常用的建模工具是什么？（mysql建模工具）\r\n7、如果你是项目经理，你如何管理你的项目团队的日常事宜？\r\n8、主从数据库的配置，都需要哪些基本的条件，需要配置什么内容？\r\n9、说出你常用的版本控制器，SVN中需要配置哪几个配置文件\r\n10、LVS 在项目运行之前需要注意哪些事项，或者说会出现什么问题?\r\n11、ecshop为何出现字段冗余违犯设计模式，请说出为何这么做？\r\n12、常用mysql优化方式，尽可能多的说?\r\n13、memcache原理是什么？是否能存入2M的value?\r\n14、什么是队列？排它锁，Myisam 死锁如何解决？\r\n15、请说出mysql常用存储引擎？memory存储引擎的特点？\r\n16、如何最快速的插入5000条以上的数据?\r\n17、你用过多少开源框架？\r\n18、ecshop 购物车信息存放在哪里？\r\n19、PHP生成页面缓存的原理\r\n\r\n20、你所知道的缓存技术有哪些，分别做下简单介绍\r\n\r\n------------------------------------------------------------------------------------------------\r\n\r\n1、SESSION 保存在服务器的哪里？\r\n答：通过php.ini指定，可存在指定目录的文件中或内存中，或数据库中！\r\n\r\n2、服务端是如何获取客户端的cookie?\r\n答：服务器每次处理请求的进候都可以抓取头信息的cookie并设置返回,\r\n\r\n3、如何实现SESSION共享，共享的原理是什么？\r\n答：配置主从数据库，将SESSION存入主数据库中，常见的做法还有在各服务器端安装MEMCAHCE,将SESSION存入各MEMCACHE中，\r\n\r\n4、请大致说出LVS搭建的过程，文件共享原理是什么？\r\n5、网络共享服务器上传数据是向一台服务器上传？还是多台？如何实现同步?\r\n\r\n6、说出你所知道的数据库设计范式？常用的建模工具是什么？（mysql建模工具）\r\n答：1NF:每一条满足原子性，不可以分割；2NF:每一条记录要满足唯一性，3NF:字段不冗余，有时我们还需要反三范式，常用的建模工具：phpMyAdmin,navicat for mysql,DOS命令行；\r\n\r\n7、如果你是项目经理，你如何管理你的项目团队的日常事宜？\r\n\r\n8、主从数据库的配置，都需要哪些基本的条件，需要配置什么内容？\r\n答：基本条件：二台以上数据库服务器，\r\n配置流程：1.分别打开主从服务器的bin-log;从服务器+relaylog\r\n2.在主服务器根据需求建立相应的帐号并授权；\r\n3.从服务器使用己创建好的帐号连接主服务器读取二进制文件并分析后同步\r\n配置项：主：log-bin=mysql-bin;server-id=num(int);binlog-format=mixd/statement/row/\r\n从：log_bin=mysql-bin;server-id=num(int)//唯一;relay_log=mysql-relay-bin;log_slave_updates=1;relay_only=1;\r\n\r\n9、说出你常用的版本控制器，SVN中需要配置哪几个配置文件\r\n答：SVN,GIT,CVS;配置文件：mod_authz_svn.so mod_dav_svn.so移至服务器模块中并加载，配置权限，分配用户；\r\n\r\n10、LVS 在项目运行之前需要注意哪些事项，或者说会出现什么问题?\r\n\r\n11、ecshop为何出现字段冗余违犯设计模式，请说出为何这么做？\r\n答：在某些环境下反三范式反而增加了效率，因此这么做！\r\n\r\n12、常用mysql优化方式，尽可能多的说?\r\n答：SQL语句优化；存储优化；数据库配置；服务器配置\r\n\r\n13、memcache原理是什么？是否能存入2M的value?\r\n答：采用C/S模式，协义是普通文本，基于libevent机制处理数据放在内存中；memcache最大只能存入1MB数据，memcache并非为存储大数据而生，但可以考虑在存储前将值先压缩或拆分成多值分配到多个key中！\r\n\r\n14、什么是队列？排它锁，Myisam 死锁如何解决？\r\n答：在默认情况下MYisam是表级锁，所以同时操作单张表的多个动作只能以队列的方式进行；\r\n排它锁又名写锁，在SQL执行过程中为排除其它请求而写锁，在执行完毕后会自动释放；\r\n死锁解决：先找到死锁的线程号，然后杀掉线程ID\r\n       \r\n15、请说出mysql常用存储引擎？memory存储引擎的特点？\r\n答：Myisam、InnoDB、memory,memory的特点是将表存到内存中，数度快，重启后数据丢失！\r\n\r\n\r\n16、如何最快速的插入5000条以上的数据?\r\n\r\n答：先生成数据文件，在用sql语句导入\r\n\r\n\r\n17、你用过多少开源框架？\r\n答：TP/CI/ZF/YII\r\n\r\n\r\n18、ecshop 购物车信息存放在哪里？\r\n答：order_info;order_goods;order_action;\r\n\r\n19、PHP生成页面缓存的原理\r\n答：将缓存内容放入OB缓存中，在OB缓存结束或脚本执行完毕后放入到程序缓存未尾并返回！\r\n\r\n20、你所知道的缓存技术有哪些，分别做下简单介绍\r\n答：ob缓存，通过模板技术写入文件类缓存；memcache;redis；redis和memcache最显著的区别在于数据不仅并于内存中，同时还会在磁盘中生成文件，即使重启，数据亦可被加载;\r\n\r\n21、HTTP 协议的原理，什么是全双工，什么是半双工?\r\n答：HTTP协议是一种无状态的协义，直白的讲就是请求和响应，全双工是指请求和响应同时进行，半双工指单个执行；\r\n\r\n22、ucenter通信原理？\r\n\r\n答：就是某个应用登陆后，然后后台轮询发送给同步登陆的应用的回调文件 ，回调文件接收到用户ID之后，生成cookie或者session然后进入登陆模式。\r\n\r\n \r\n\r\n23、Memcached的原理\r\n\r\n答：memcached 是以守护程序方式运行于一个或多个服务器中，等待接收客户端的连接操作，客户端可以由各种语言编写(例如PHP)。PHP 等客户端在与 memcached 服务建立连接之后，接下来的事情就是存取对象了，每个被存取的对象都有一个唯一的标识符 key，存取操作均通过这个 key 进行，保存到 memcached 中的对象实际上是放置内存中的，并不是保存在 cache 文件中的，这也是为什么 memcached 能够如此高效快速的原因。\r\n\r\n \r\n\r\n24、你用过多少种JS框架？举例说明优缺点\r\n答：jQuery、prototype、dojo、ext、YUI;\r\njQuery:强大的DOM节点查询无人能出其左右，动画操方便； DOM封装的很好！高低版本兼容非常好\r\nprototype:较早的jS库，对ajax支持较好，基于原型链面向对象很强大\r\ndojo:更容易俣WEB页面具有动态能力；\r\next:强大的UI操作高居榜首；\r\nYUI:强大的类库，提供很多方法；\r\n\r\n25、如何衡量AJAX的使用（何时使用AJAX）\r\n答：AJAX既称无刷新技术，常用见的使用场景：表单验证，用户评分、点击；只要需要实时的与服务器交互时即可使用；\r\n26、什么是推技术，实现原理是什么?\r\n答：推技术又称COMET，即在客户请求时在服务器挂起长连接，一旦服务器有了新数据，它降立即反回给客户端，实时性好；\r\n\r\n27、什么是垂直搜索，斯芬克斯中分词原理？\r\n答：垂直搜索是指在特定的范围内搜索的上下文，搜索面只会越来越精细，而非越来越广泛；sphinx分词的原理：将文本拆分为多个单词从数据源的各个文档对像创建索引并将索引表存储于内存中！\r\n\r\n28、sphinx中无法ha_sphinx.so是用来做什么的?\r\n答：一个sphinx的存储模块；\r\n\r\n29、PHP常用的合并数组的方式?\r\n答：array_mergn;array_mergn_recursive;\r\n\r\n30、回答PHP读取文件速度快，还是读取mysql的数据快？为何？\r\n答：一般情况下读文件》读数据库；不同情况速度也会反向，如：数据库数据量很小，而同目录文件又非常多的情况下，读数据库大于读文件；', '1', '1', '2019-01-11 11:11:00', '2019-01-13 23:28:58');
INSERT INTO `posts` VALUES ('5', '0', '0', '2', '网上的腾讯php面试题 （有答案版本） 纯手打答案', '网上的腾讯php面试题 （有答案版本） 纯手打答案', 'PHP开发工程师笔试试卷\r\n\r\n姓名:天才\r\n\r\n一、PHP开发部分\r\n1．合并两个数组有几种方式，试比较它们的异同\r\n答：1、array_merge() \r\n2、’+’ \r\n3、array_merge_recursive\r\n\r\narray_merge 简单的合并数组 \r\narray_merge_recursive 合并两个数组，如果数组中有完全一样的数据，将它们递归合并 \r\narray_combine 和 ‘+’ ：合并两个数组，前者的值作为新数组的键\r\n\r\n2．请写一个函数来检查用户提交的数据是否为整数（不区分数据类型，可以为二进制、八进制、十进制、十六进制数字）\r\n答：其实主要还是is_int和 floor 这个方法\r\n\r\nif(!is_numeric($jp_total)||strpos($jp_total,\".\")!==false){  \r\n    echo \"不是整数\";  \r\n}else{  \r\n    echo \"是整数\";  \r\n}  \r\n1\r\n2\r\n3\r\n4\r\n5\r\n3．PHP的strtolower()和strtoupper()函数在安装非中文系统的服务器下可能会导致将汉字转换为乱码，请写两个替代的函数实现兼容Unicode文字的字符串大小写转换\r\n答：原因是：中文是由多字节组成的，而只有英文系统的单个英文字符只有一个字节，所以该系统把中文的每一个字节都做了strtolower()处理,改变后的中文字节拼接在一起就成了乱码（新生成的编码映射对应的字符可能就不是中文了）\r\n\r\n手动解决：用str_split(string string,intstring,intsplit_length = 1)按每个字节切割，像中文能切割成三个字节。对识别到的字节若是英文字母则进行转换。\r\n\r\n<?php  \r\nfunction mystrtoupper($a){  \r\n    $b = str_split($a, 1);  \r\n    $r = \'\';  \r\n    foreach($b as $v){  \r\n        $v = ord($v);  \r\n        if($v >= 97 && $v<= 122){  \r\n            $v -= 32;  \r\n        }  \r\n        $r .= chr($v);  \r\n    }  \r\n    return $r;  \r\n}  \r\n\r\n\r\n$a = \'a中你继续F@#$%^&*(BMDJFDoalsdkfjasl\';  \r\necho \'origin string:\'.$a.\"\\n\";  \r\necho \'result string:\';  \r\n$r = mystrtoupper($a);  \r\nvar_dump($r);  \r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n4．PHP的is_writeable()函数存在Bug，无法准确判断一个目录/文件是否可写，请写一个函数来判断目录/文件是否绝对可写\r\n答：其中bug存在两个方面， \r\n1、在windowns中，当文件只有只读属性时，is_writeable()函数才返回false，当返回true时，该文件不一定是可写的。 \r\n如果是目录，在目录中新建文件并通过打开文件来判断； \r\n如果是文件，可以通过打开文件（fopen），来测试文件是否可写。\r\n\r\n2、在Unix中，当php配置文件中开启safe_mode时(safe_mode=on)，is_writeable()同样不可用。 \r\n读取配置文件是否safe_mode是否开启。\r\n\r\n/**\r\n* Tests for file writability\r\n*\r\n* is_writable() returns TRUE on Windows servers when you really can\'t write to\r\n* the file, based on the read-only attribute. is_writable() is also unreliable\r\n* on Unix servers if safe_mode is on.\r\n*\r\n* @access   private\r\n* @return   void\r\n*/\r\nif ( ! function_exists(\'is_really_writable\'))\r\n{\r\n    function is_really_writable($file)\r\n    {\r\n    // If we\'re on a Unix server with safe_mode off we call is_writable\r\n    if (DIRECTORY_SEPARATOR == \'/\' AND @ini_get(\"safe_mode\") == FALSE)\r\n    {\r\n        return is_writable($file);\r\n    }\r\n\r\n    // For windows servers and safe_mode \"on\" installations we\'ll actually\r\n    // write a file then read it. Bah...\r\n    if (is_dir($file))\r\n    {\r\n        $file = rtrim($file, \'/\').\'/\'.md5(mt_rand(1,100).mt_rand(1,100));\r\n\r\n        if (($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE)\r\n        {\r\n            return FALSE;\r\n        }\r\n\r\n        fclose($fp);\r\n        @chmod($file, DIR_WRITE_MODE);\r\n        @unlink($file);\r\n        return TRUE;\r\n    } elseif ( ! is_file($file) OR ($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE) {\r\n        return FALSE;\r\n    }\r\n\r\n    fclose($fp);\r\n    return TRUE;\r\n    }\r\n}\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n33\r\n34\r\n35\r\n36\r\n37\r\n38\r\n39\r\n40\r\n41\r\n42\r\n43\r\n5．PHP的chmod()函数存在Bug，无法保证设置成功，请写一个函数在指定路径下创建一个目录/文件并确保可以正确设置权限掩码\r\n答：我也找不到答案\r\n\r\n6．PHP处理上传文件信息数组中的文件类型$_FILES[‘type’]由客户端浏览器提供，有可能是黑客伪造的信息，请写一个函数来确保用户上传的图像文件类型真实可靠\r\n答：用getimagesize来判断上传图片的类型比$_FILES函数的type更可靠 \r\n同一个文件，使用不同的浏览器php返回的type类型是不一样的，由浏览器提供type类型的话， \r\n就有可能被黑客利用向服务器提交一个伪装撑图片后缀的可执行文件。 \r\n可以通过getimagesize()函数来判断上传的文件类型，如果是头像文件 会返回这样的一个数组\r\n\r\nArray\r\n(\r\n    [0] => 331\r\n    [1] => 234\r\n    [2] => 3\r\n    [3] => width=\"331\" height=\"234\"\r\n    [bits] => 8\r\n    [mime] => image/png\r\n)；\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n如果通过getimagesize()函数返回的是这样的一个数组 说明上传的是头像文件。其中索引为2的表示类型 \r\n1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte \r\norder)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = \r\nJB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM， \r\n你可以通过这个再去限制上传的头像类型\r\n\r\n<?php\r\n    $file=$_FILES[\'file\'];\r\n    if(!empty($file))\r\n    {\r\n        var_dump($file);\r\n        var_dump(getimagesize($file[\"tmp_name\"]));\r\n    }   \r\n?>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n7．PHP通过对数据的URL编码来实现与Javascript的数据交互，但是对于部分特殊字符的编解码与Javascript的规则不尽相同，请具体说明这种差异，并针对UTF-8字符集的数据，写出PHP的编解码函数和Javascript的编解码函数，确保PHP编码数据可以被Javascript正确解码 、Javascript编码的数据可以被PHP正确解码\r\n答：\r\n\r\n<?php\r\n $str = \'思源博客siyuantlw/tlw/sy/俺只是一个打酱油的\';\r\n $str = iconv(\"GB2312\",\'UTF-8\',$str);\r\n $str = urlencode($str); \r\n?>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n//js  decodeURIComponent   貌似对GB2312编码的格式不识别，必须转为utf-8才可以，然后，如果字符串中有空格的  就转为 +  号了\r\n<html>\r\n <script>\r\n  var ds = \'<?php echo $str;?>\';\r\n  var dddd= decodeURIComponent (ds);\r\n  alert(dddd);\r\n </script>\r\n</html>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n8．试阐述Memcache的key多节点分布的算法？当任一节点出现故障时PHP的Memcache客户端将如何处置？如何确保Memcache数据读写操作的原子性？\r\n答：原理：一致性hash\r\n\r\n原子性 \r\n原子性会导致的问题：简单的说就是A，B都想操作key1，然后都在key1上增加自己的信息，就会有问题 \r\nmemcached是原子的吗？宏观 \r\n所有的被发送到memcached的单个命令是完全原子的。如果您针对同一份数据同时发送了一个set命令和一个get命令，它们不会影响对方。它们将被串行化、先后执行。即使在多线程模式，所有的命令都是原子的；命令序列不是原子的。如果您通过get命令获取了一个item，修改了它，然后想把它set回memcached，我们不保证这个item没有被其他进程（process，未必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他进程set的item。 \r\nmemcached 1.2.5以及更高版本，提供了gets和cas命令，它们可以解决上面的问题。如果您使用gets命令查询某个key的item，memcached会 给您返回该item当前值的唯一标识。如果您覆写了这个item并想把它写回到memcached中，您可以通过cas命令把那个唯一标识一起发送给 memcached。如果该item存放在memcached中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 item，那么该item存放在memcached中的唯一标识将会改变，您的写操作就会失败。\r\n\r\n9．如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞？\r\n答：基本原则：不对外界展示服务器或程序设计细节（屏蔽错误），不相信任何用户提交的数据（过滤用户提交） \r\n1、1 屏蔽错误，将display_errors 设置为off \r\n2、 过滤用户提交参数，这里需要注意的是不能仅仅通过浏览器端的验证，还需要经过服务器端的过滤\r\n\r\n  这里是需要注意最多的地方，因为所有用户提交的数据入口都在这里，这是过滤数据的第一步。\r\n      1 考虑是否过滤select,insert,update,delete,drop,create等直接操作数据的命令语句\r\n      2 使用addslashes 将所有特殊字符过滤\r\n      3 打开magic_quotes_gpc，开启该参数数后自动将sql语句转换，将 \' 转换成  \\\'\r\n1\r\n2\r\n3\r\n4\r\n3、 可以考虑设置统一入口，只允许用户通过指定的入口访问，不能访问未经许可的文件等内容 \r\n4、可以考虑对安全性要求高的文件进行来源验证，比如要想执行b.php必须先执行a.php，可以在b.php中判断来自a.php的referer,避免用户直接执行b.php\r\n\r\n10．请设计一个数据结构可以实现无限级子菜单的树型菜单功能并提供菜单生成算法，用UML描述设计并写出相关PHP代码\r\n答：还没找到答案\r\n\r\n二、系统相关部分\r\n1．请简述Linux、FreeBSD、Soalaris、Mac OS、Windows几种系统下进程与线程的内核实现方式、管理机制的异同\r\n2．请简述Linux/BSD系统下进程间通讯的方式有哪些，并具体说明在PHP下如何实现\r\n答： \r\n管道（Pipe）及有名管道（namedpipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； \r\n信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）； \r\n报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列systemV消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 \r\n共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 \r\n信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 \r\n套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和SystemV的变种都支持套接字。\r\n\r\n3．请简述Linux/BSD系统下系统的消息/事件异步通知机制有几种，并加以比较\r\n4．简单比较TCP/UDP协议的异同，对于PHP的Socket扩展与Stream扩展，试比较两者基于TCP/UDP协议的SOCKET编程差异？\r\n5．为什么会出现僵死进程（孤儿进程）？怎样查看僵死进程？如何解决僵死进程问题？\r\n答：僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 \r\n查看：使用ps aux \r\n删除：ps aux | grep -e ‘^[Zz]’ | awk ‘{print $2}’ | xargs kill -9\r\n\r\n6．对于System-V消息队列，如何解决系统本身对于消息队列条数、总容量（字节数）的限制？如何设置消息的优先级别？请比较阻塞模式和非阻塞模式的异同，并说明如何避免非阻塞模式下的消息队列堵塞？\r\n7．请描述Apache 2.x版本的MPM（Multi-Processing Module）机制，并具体说明在不同的MPM机制下如何支持PHP？\r\n答：常用的应该就只有3个：worker|prefork|perchild \r\nprefork：在功能上就是使用Apache的运行方式，一个父进程，然后根据设置以及连接情况生成相应的子进程数。这种模式可靠性和健壮性都是最好的。但是在性能上，开销过大。达不到我们这些“吸血鬼”的要求了^_^。如果连接数过多的话，会导致我们无法远程登陆，一定要等到连接数下降后才能连接，这也是最让我头痛的事情。 \r\nworker：混合线程/进程的MPM。一个父进程，后面是带有线程的子进程。每个子进程的线程数是固定且相同的。这是最“平庸”的一个模式，但也是使用人最多的一种模式。因为它性能等各方面比较均衡。性能上要比prefork好一些，只是牺牲了一点点的健壮性和可靠性而已。一般推荐使用这个选项。 \r\nperchild：也是混合线程/进程的MPM。当启动perchild MPM时，它会建立指定数量的子进程，且每个子进程都具有指定数量的线程，如负载增加了，那它不会建立新的进程（子进程是固定的），只是在子进程下建立新的线程。它还有一个特点就是可以为每一个子进程配置不同的用户和组。也可以为每个虚拟主机指定一个子进程。这种模式性能是最佳的，但是可靠性和健壮性就相对是最差的。各取所需，我个人觉得这种模式也不错，如果你不用第三方的模块的话^_^。\r\n\r\n8．请简述PHP在Apache下的几种运行方式并加以比较？如何让PHP在Linux+Apache下以Fast CGI方式运行？\r\n答：php在apache有3中运行方式：CGI模式、FastCGI模式、Apache 模块DLL。 \r\n比较： \r\nCgi模式和模块dll加载方式比较： \r\nCgi模式下，apache调用外部执行器php.exe执行php代码，并将解释后生成的html代码和原html整合，再传递给apache服务器，其在执行时每次都需要重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构，运行速度非常慢，但因为是外部加载执行器，php代码执行出错不会导致apache崩溃。\r\n\r\n在模块化(DLL)中，PHP是与Web服务器一起启动并运行的。所以从某种角度上来说，以apache模块方式安装的 PHP4有着比CGI模式更好的安全性以及更好的执行效率和速度。\r\n\r\nCgi和fastcgi模式比较： \r\nFastcig是cgi的升级版，Cgi和fastcgi工作模式大抵相同，但fastcgi模式中fastcgi的进程管理器可用来管理cgi解释器，该管理器在cgi解释器完成请求后，会处于挂起状态，用以等待接下来的请求，因为向比较cgi每次都需要重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构，fastcig模式明显要快很多。\r\n\r\n9． 请写出让PHP能够在命令行下以脚本方式执行时安装PHP所必须指定的configure参数，并说明如何在命令行下运行PHP脚本（写出两种方式）同时向PHP脚本传递参数？\r\n答：由于 –enable-cli 和 –enable-cgi 同时默认有效，因此，不必再配置行中加上 –enable-cli 来使得 CLI 在 make install 过程中被拷贝到 {PREFIX}/bin/php\r\n\r\nphp -f “index.php” \r\nphp -r “print_r(get_defined_constants());”\r\n1\r\n2\r\n10．请简述PHP 5.2的内存池及其内存管理机制、垃圾回收机制\r\n内存管理机制\r\n\r\n试题二：\r\n１、请列举你能想到的UNIX信号，并说明信号用途。\r\n答： \r\nUnix信号量也可以在文件/usr/include/sys/signal.h中查看 \r\nSIGHUP 进程由於控制终端死去或者控制终端发出起命令 \r\nSIGINT 键盘中断所产生的信号 \r\nSIGQUIT 键盘终止\r\n\r\n２、请列举、你能想到的所有的字符串查找算法，并加注释简单说明。\r\n答： \r\n1 顺序查找 \r\n2 二分查找 \r\n3 分块查找 \r\n4 哈希表查找\r\n\r\n３、有一个IP地址（192.168.0.1），请写出其32位无符号整数形式。\r\n答：此题是将十进制转换成二进制 采用取余法即可很简单 答案是：11000000.10101000.00000000.00000001 千万不能只记答案哦\r\n\r\n４、写出、你能想到的所有HTTP返回状态值，并说明用途（比如：返回404表示找不到页面）\r\n答： \r\n200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 \r\n301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 \r\n302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 \r\n401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \r\n403 （禁止） 服务器拒绝请求。 \r\n404 （未找到） 服务器找不到请求的网页。 \r\n500 （服务器内部错误） 服务器遇到错误，无法完成请求。 \r\n501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 \r\n502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 \r\n503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \r\n504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \r\n505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\r\n\r\n基础任务-选作（会得到额外分数）：\r\n\r\n１、画几个你最熟悉的SERVER端模型出来（格式不重要，尽量将图画清楚，说明思路即可）\r\n进阶任务：\r\n１、PHP的垃圾收集机制是怎样的？\r\n说明： \r\n１）如果，你熟悉PHP源码，那么请从源码入手，回答些问题，会获得额外加分 \r\n２）如果，你不熟悉PHP源码，那么尽你所能，多写点东西，包括利用自己的编程直觉得到的信息，都可以。 \r\n３）对，则有分，错误不扣，不写无分。\r\n\r\n答：PHP可以自动进行内存管理，清除不再需要的对象。PHP使用了引用计数(referencecounting)这种单纯的垃圾回收(garbagecollection)机制。每个对象都内含一个引用计数器，每个reference连接到对象，计数器加1。当reference离开生存空间或被设为NULL，计数器减1。当某个对象的引用计数器为零时，PHP知道你将不再需要使用这个对象，释放其所占的内存空间。\r\n\r\n２、请写出HTTP头，并符合以下要求：\r\n１）这是一个post请求 \r\n２）目标：http://www.example.com:8080/test \r\n３）POST变量： \r\nusername: test \r\npwd: test2 \r\nintro: Hello world! \r\n４）包含以下COOKIE信息： \r\ncur_query: you&me \r\n说明：\r\n\r\n１）如果，你记不得某个HTTP协议中的指令字了，那么，无奈这举是用“汉字”代替。 \r\n２）如果，你能记住更多的HTTP协议指令字，那么多写几句，总是没坏处，对吧？ \r\n３）最关键的，只需要画出正确的“轮廓”（还记得httpwatch等工具打印出来的头部吗？那就是“轮廓”的含义），也会有分数，但如果，连“轮廓”都写错了，那么就很遗憾了。 \r\n答：\r\n\r\nAccept: text/html 可以接受的数据类型 \r\nAccept-Encoding: gzip 接受的压缩类型 \r\nAccept-Language: zh-CN 接受语言 \r\nCache-Control: no-cache 是否有缓存 \r\nConnection : keep-alive 是否保持链接 \r\nHost:http://www.example.com:8080/test \r\nCookie：intro=Hello world! \r\nContent-Disposition: form-data; username=”test”&pwd=”test2”&intro=”hello world!” \r\nUser-Agent: 浏览器信息 \r\nReferer: 前一个页面地址\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n设计任务：\r\n１、最近总有人骚扰我们的投票模块，需要你来设计一个投票限制的东东\r\n要求如下： \r\n１）要求每个QQ号码（假设此QQ号码在UNIT32内可以表示）10分钟这内只能投5票。 \r\n２）我们的用户很踊跃，平均每天要有2000万人左右通过此程序投票。 \r\n说明： \r\n１）无需写代码，只需要图跟文字即可。 \r\n２）对于关键逻辑，请用图加代码表示出来，这也是对你文字表达能力的一个考验。 \r\n３）对你能想到的所有的边界条件列出来，这是对你逻辑思维全面与敏捷性的考验。 \r\n４）存储部分，尽你所能吧。如果，你需要一个自己设计的存储层，那么把这个存储层的实现，用文字＋图片方式描述清楚，要是设计合理，你会获得华丽的奖分。 \r\n答：找了好久终于找到个大神的回答：打字太累了 就截图了 \r\n \r\n \r\n \r\n\r\n\r\n编程任务：\r\n１、我们碰到了大麻烦，一个新来的传教士惹恼了上帝，上帝很愤怒，要求我们把圣经（bbe.txt）背熟，直至他说哪个单词，我们就要飞快的回答出这个单词在第几行第几个单词位置。听说你是个优秀的程序员，那么髟助我们完成这个不可能的任务吧。\r\n要求如下： \r\n１）/myworks/example/bbe.txt，98版本英文圣经一本 \r\n２）输入部分要求如下：php ./example.php [单词] \r\n３）输出部分如下：[单词] 1,2 2,4 5,6　表示：此单词在1行2列（第二个单词），2行4列… \r\n说明：\r\n\r\n１）此文本4MB之巨… \r\n２）单词的含义：由英文字母（大小写），数字（0-9）组成的串 \r\n３）提供给你的机器OS为ubuntu 9.10，内存只有1G，而且，很不幸的，其中700M用来做了别的 \r\n４）上机考试不允许上网，但我装了man文档以及读取CHM以及PDF的阅读器，在电脑的桌面的CHM文件夹中，有相应的PHP参考手册 \r\n５）算法复杂度要求不能大于O（N^2）（就是N的平方） \r\n６）什么？PHP低效且用起来不顺手，好的，你可以用别的语言来实现。但注意：提供给你的机器上只有python 2.4/perl 5.8/gcc[g++] 4.1\r\n\r\n答：两份答案感觉还可以 \r\nbbe.txt文件咱们没有 想像成是 空格 隔开的算了\r\n\r\nhello123 hello tim jason \r\nwoaini1 tianjianxiong333 hh aaa\r\n\r\n/* 此文件用于根据bbe.txt文件对所有单词创建索引，相当于一次预处理 */   \r\nini_set(\'display_errors\',\'on\');  \r\nset_time_limit(0);  \r\n$file = file($src); // 数组  \r\nforeach($file as $i => &$ls){  \r\n    $a = explode(\" \",$ls);  \r\n    $len = count($a);  \r\n    if ($len > 0){  \r\n        for($j=0;$i<$len;$j++){  \r\n            $data = \"此单词\".$a[$j].\"在\".($i+1).\"行,\".($j+1).\"列\";  \r\n            $key = md5(trim(strtolower($a[$j])));  \r\n            file_put_contents($key,$data);  \r\n        }  \r\n    }  \r\n    //echo $i.\". > \".$ls.\'<br />\';  \r\n}\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\nexample.php：\r\n\r\n#!/usr/local/bin/php -q   \r\n<?php  \r\nset_time_limit(0);   \r\n$getkey=empty($argv[1]) ? $_REQUEST[\'k\'] : $argv[1];  \r\n$arr = explode(\",\",$getkey);    \r\n$len = count($arr);  \r\nif($len > 0){  \r\n    for($i=0;$i<$len;$i++){  \r\n        echo getKey($arr[$i]).\"\\n\";  \r\n    }  \r\n}  \r\nfunctuion getKey($key){  \r\n    $str = \"没有找到此单词[\".$key.\"]\";  \r\n    if($key){  \r\n        $fc = md5($key);  \r\n        $str = file_get_contents($fc));  \r\n    }  \r\n    return $str;  \r\n}  \r\n?>  \r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n别人的方法： \r\n1、使用ascii码，判断字符所在范围 \r\n2、只要扫描一遍字符即可，复杂度为O（N） \r\n3、利用了php string{$i} 的特性，取字符串内任一字符 \r\n4、todo：改为fgetc版本，可以完全不需要使用以上php特性 \r\n5、字符串匹配算法：http://wendell07.blog.hexun.com/14112681_d.html，目前看来最快的方法：Sunday，由于本题是单词匹配，问题更简单，只要找到头尾……\r\n\r\n$word = $argv[1];  \r\n$lines = 0;  \r\n\r\n$handle = @fopen(\"bbe.txt\", \"r\");  \r\nif ($handle) {  \r\n    while (!feof($handle)) {  \r\n        $line = fgets($handle, 4096);  \r\n        $local = local_word($line, $word);  \r\n        $lines++;  \r\n        if( !empty($local) ){  \r\n            echo \"$lines,\".implode(\' \',$local).\"\\n\";  \r\n        }  \r\n    }  \r\n    fclose($handle);  \r\n}  \r\n\r\nfunction local_word($line, $word){  \r\n    $local = array();  \r\n    $local_length = 1;  \r\n    $word_length = strlen($word);  \r\n\r\n    for($i = 0; ( $char = $line{$i} ) !== \'\'; $i++ ){  \r\n        // 单词最后一个字符必定不是符号，且必有一个符号结尾，此计为一个新词  \r\n        if( !is_symbel( $line{ $i-1 } ) && is_symbel($char) ){  \r\n            $local_length++;  \r\n        }      \r\n\r\n        if( $char === $word[0] && // 如果第一个字符相同  \r\n            is_symbel( $line{ $i-1 } ) && // 且为单词开始  \r\n            is_symbel( $line{ $i+$word_length }) // 单词结尾应该为符号  \r\n        ){  \r\n            // 进入验证单词模式，一个一个字符比对  \r\n            for($j = 1; ($w_char = $word{$j}) !== \'\'; $j++ ){  \r\n                // 遇到单词字符不匹配  \r\n                if( $w_char != $line{ $i+$j } ){  \r\n                    $i += $j;  \r\n                    break;  \r\n                }  \r\n                // 如果单词比对完全正确  \r\n                if( $j == ($word_length-1) ){  \r\n                    //echo \"$line_length, $word_length\\n\";  \r\n                    $local[] = $local_length;  \r\n                }  \r\n            }  \r\n        }  \r\n    }  \r\n    return $local;  \r\n}  \r\n\r\nfunction is_symbel($char){  \r\n    $asc = ord($char);  \r\n    return !( (48 <= $asc && $asc <= 57) ||  \r\n              (65 <= $asc && $asc <= 90) ||  \r\n              (97 <= $asc && $asc <= 122) );  \r\n}  \r\n ', '1', '1', '2019-01-11 11:11:00', '2019-01-13 23:32:14');
INSERT INTO `posts` VALUES ('6', '2', '0', '2', ' PHP面试经常被提到的问题', ' PHP面试经常被提到的问题', '1． Include 与 require的区别，require和require_once的效率哪个高？\r\n\r\n  PHP在遇到include时就解释一次，如果页面中出现10次include，php就解释10次，而php遇到require时只解释一次，即使页面出现多次require也只解释一次，因此require的执行表率比include高。\r\n\r\nPhp使用require包含文件时将被包含的文件当成当前文件的一个组成部分，如果被包含的文件中有语法错误或者被包含的文件不存在，则php脚本将不再执行，并提示错误。\r\n\r\nPhp使用include包含文件时相当于指定了这个文件的路径，当被包含的文件有语法错误或者被包含的文件不存在时给出警告，不影响本身脚本的运行。\r\n\r\nInclude在包含文件时可以判断文件是否包含，而require则不管任何情况都包含进来。\r\n\r\nRequire的效率比require_once的效率更高，因为require_once在包含文件时要进行判断文件是否已经被包含。\r\n\r\n \r\n\r\n2． Cookie和session的区别，禁止了cookie后session能正常使用吗？session的缺点是什么？session在服务器端是存在哪里的？是共有的还是私有的？\r\n\r\n  COOKIE保存在客户端，用户通过手段可以进行修改，不安全，单个cookie允许的最大值是3k。而SESSION保存在服务器端，相对比较安全，大小没有限制。禁用了cookie之session不能正常使用。\r\n\r\nSession的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。\r\n\r\nSession保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。\r\n\r\nSession文件是公有的。\r\n\r\n3． 怎么防止sql注入？\r\n\r\n1、过滤掉一些常见的数据库操作关键字：select,insert,update,delete,and,*等\r\n\r\n或者通过系统函数：addslashes(需要被过滤的内容)来进行过滤。\r\n\r\n 2、在PHP配置文件中\r\n\r\nRegister_globals=off;设置为关闭状态 //作用将注册全局变量关闭。\r\n\r\n比如：接收POST表单的值使用$_POST[\'user\'],如果将register_globals=on;直接使用$user可以接收表单的值。\r\n\r\n 3、SQL语句书写的时候尽量不要省略小引号(tab键上面那个)和单引号\r\n\r\n 4、提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的\r\n\r\n 5、对于常用的方法加以封装，避免直接暴漏SQL语句\r\n\r\n 6、开启PHP安全模式\r\n\r\nSafe_mode=on;\r\n\r\n 7、打开magic_quotes_gpc来防止SQL注入\r\n\r\nMagic_quotes_gpc=off;默认是关闭的，它打开后将自动把用户提交的sql语句的查询进行转换，把\'转为\\\'，这对防止sql注入有重大作用。\r\n\r\n因此开启：magic_quotes_gpc=on;\r\n\r\n 8、控制错误信息\r\n\r\n关闭错误提示信息，将错误信息写到系统日志。\r\n\r\n9、使用mysqli或pdo预处理。\r\n\r\n4． 数据库索引有几类，分别是什么？什么时候该用索引\r\n\r\n　普通索引、主键索引、唯一索引\r\n\r\n　　并非所有的数据库都以相同的方式使用索引，作为通用规则，只有当经常查询列中的数据时才需要在表上创建索引。\r\n\r\n5． 引用传值和非引用传值的区别，什么时候该用引用传值?什么时候该用非引用传值?\r\n\r\n按值传递：函数范围内对值的改变在函数外都会被忽略。\r\n\r\n按引用传递：函数范围内对值的任何改变在函数外也将反应出这些修改。\r\n\r\n按值传递时，php必须复制值，如果操作的是大型的对象和字符串，这将是一个代价很大的操作。按引用传递不需要复制值，因此对性能的提高有好处。\r\n\r\n当需要在函数内改变源变量的值时用引用传递，如果不想改变原变量的值用传值。\r\n\r\n6． 写几个魔术方法并说明作用？\r\n\r\n__call()当调用不存在的方法时会自动调用的方法\r\n\r\n__autoload()在实例化一个尚未被定义的类是会自动调用次方法来加载类文件\r\n\r\n__set()当给未定义的变量赋值时会自动调用的方法\r\n\r\n__get()当获取未定义变量的值时会自动调用的方法\r\n\r\n__construct()构造方法，实例化类时自动调用的方法\r\n\r\n__destroy()销毁对象时自动调用的方法\r\n\r\n__unset()当对一个未定义变量调用unset()时自动调用的方法\r\n\r\n__isset()当对一个未定义变量调用isset()方法时自动调用的方法\r\n\r\n__clone()克隆一个对象\r\n\r\n__tostring()当输出一个对象时自动调用的方法\r\n\r\n7． $_REQUEST、$_POST、$_GET、$_COOKIE、$_SESSION、$_FILE的意思是什么?\r\n\r\n它们都是PHP预定义变量。\r\n\r\n$_REQUEST用来获取post或get方式提交的值\r\n\r\n$_POST用来获取post方式提交的值\r\n\r\n$_GET用来获取get方式提交的值\r\n\r\n$_COOKIE用来获取cookie存储的值\r\n\r\n$_SESSION用来获取session存储的值\r\n\r\n$_FILE用来获取上传文件表单的值\r\n\r\n \r\n\r\n8． 数组中下标最好是什么类型的，为什么？\r\n\r\n数组的下标最好是数字类型的，数字类型的处理速度快。\r\n\r\n9. ++i和i++哪一个效率高，为什么？\r\n\r\n++i效率比i++的效率更高，因为++i少了一个返回i的过程。\r\n\r\n10．magic_quotes_gpc()、magic_quotes_runtime()的意思是什么？\r\n\r\nMagic_quotes_gpc()是php配置文件中的，如果设置为on则会自动POST,GET,COOKIE中的字符串进行转义，在\'之前加\\\r\n\r\nMagic_quotes_runtime()是php中的函数，如果参数为true则会数据库中取出来的单引号、双引号、反斜线自动加上反斜杠进行转义。\r\n\r\n11.Echo()、print()、print_r()的区别？\r\n\r\nEcho() 是PHP语法，可以输出多个值，不能输出数组。\r\n\r\nPrint() 是php的语言结构，可以输出单个简单类型的变量值。\r\n\r\nPrint_r() 是php函数，可以打印出复杂类型变量的值，如数组，对象。\r\n\r\n12．谈谈你对Mvc的认识\r\n\r\nMVC是一种设计模式，强制使输入、处理、输出分开，MVC的三个核心部分：M模型，V视图，C控制器。\r\n\r\n视图就是用户看到并与之交互的界面。\r\n\r\n模型就是程序的数据业务规则。\r\n\r\n控制器接收用户的数组调用模型和视图去完成用户需求。\r\n\r\n使用MVC的优点：低耦合、高重用性、较低的生命周期成本、快速开发部署、可维护性、可扩展性，有利于软件工程化管理。\r\n\r\nMVC的缺点：没有明确的定义，完全理解并不容易。小型项目不适合用MVC。\r\n\r\n13.框架中什么是单一入口和多入口，单一入口的优缺点\r\n\r\n多入口就是通过访问不同的文件来完成用户请求。\r\n\r\n单一入口只web程序所有的请求都指向一个脚本文件的。\r\n\r\n单一入口更容易控制权限，方便对http请求可以进行安全性检查。\r\n\r\n缺点：URL看起来不那么美观，特别是对搜索引擎来说不友好。\r\n\r\n14.打印一个用‘.’链接的字符串时候，还可以用什么代替‘.’链接效率更高些?\r\n\r\n可以用,代替.,效率更高。\r\n\r\n15.提示类型200、404、502是什么意思?\r\n\r\n200是请求成功，404是文件未找到，502是服务器内部错误。\r\n\r\n16.编写一个自定义函数提取这段路径的的后缀名。\r\n\r\n“Www/hello/test.php.html?a=3&b=4”\r\n\r\nFunction geturltype($url){\r\n\r\n$info=parse_url($url);\r\n\r\nReturn end(explode(\'.\',$info[\'path\']));\r\n\r\n}\r\n\r\n17.你对Memcach的理解，优点有哪些？\r\n\r\nMemcache是一种缓存技术，在一定的时间内将动态网页经过解析之后保存到文件，下次访问时动态网页就直接调用这个文件，而不必在重新访问数据库。使用memcache做缓存的好处是：提高网站的访问速度，减轻高并发时服务器的压力。\r\n\r\nMemcache的优点：稳定、配置简单、多机分布式存储、速度快', '1', '1', '2019-01-11 11:11:00', '2019-01-13 23:26:29');
INSERT INTO `posts` VALUES ('7', '10', '0', '2', 'PHP引用（&）的考察点', 'PHP引用（&）的考察点', '## 引用的概念\r\n\r\n在PHP中引用意味着用不同的名字访问同一个变量内容。\r\n\r\n### 定义方式\r\n\r\n使用 & 符号来表示\r\n\r\n变量的引用\r\n```\r\n$a = \'ABC\'; //开辟一块内存空间存储数据，$a指向该空间\r\n$b = &$a; //创建引用变量，此时$b也指向上述空间\r\necho $b; //输出ABC\r\n$b = \'EFG\'; //\r\necho $a; //输出EFG，$a 和 $b指向的是同一个变量，修改的是同一个变量\r\n```\r\n值得注意的是，PHP有一个COW机制（copy on wrtite）:\r\n```\r\n$a = \'ABC\';\r\n$b = $a; //此时并没有使用引用变量，但是由于COW机制，$b 仍然指向$a的空间\r\n$b = \'ABC\'; //此时对$b 进行 了写操作 ，触发cow，$b指向新的空间，$a不\r\n发生变化\r\n```\r\n### 函数引用\r\n\r\n对于函数的引用，值得一提的是，必须在申明和调用时都加上&才算是真正的引用。\r\n```\r\n<?php\r\nfunction &test(){ \r\n    static $b=0;//申明一个静态变量 \r\n    $b=$b+1; \r\n    echo $b; \r\n    return $b; }\r\n}\r\n$a=test();//这条语句会输出　$b的值　为１ \r\n$a=5; $a=test();//这条语句会输出　$b的值　为2\r\n$a=&test();//这条语句会输出　$b的值　为3 \r\n$a=5; $a=test();//这条语句会输出　$b的值　为6\r\n?>\r\n```\r\n如果只使用$a=test()，其实和普通的函数调用是一样的，只是获得了函数的返回值，而使用$a=&test()方式来调用，则$a指向了$b的地址，改变$a的值，也会改变$b的值。\r\n\r\n对象的引用\r\n\r\n```\r\n<?php\r\nclass a{\r\n    var $abc=\"ABC\";\r\n} \r\n$b=new a; \r\n$c=$b; \r\necho $b->abc;//这里输出ABC \r\necho $c->abc;//这里输出ABC $b->abc=\"DEF\"; \r\necho $c->abc;//这里输出DEF\r\n?>\r\n```\r\n在PHP5中，对象的复制是通过引用来实现的，如果想复制的话，可以使用__clone\r\n\r\n### 取消引用\r\n\r\nunset只会取消变量名和变量内容之间的联系，并不会销毁变量内容本身\r\n```\r\n<?php\r\n$a = 1;\r\n$b = &$a;\r\nunset($b);\r\necho $a;//这里仍然会输出1，因为并没有销毁变量内容\r\n```\r\n\r\n考察题\r\n\r\n```\r\n<?php\r\n    \r\n    $data = [\'a\',\'b\',\'c\'];\r\n    \r\n    foreach ($data as $key => $value) {\r\n        $value = &$data[$key];\r\n    }\r\n\r\n/**\r\n * 1、程序运行时，每一次循环结束后，变量$data的值是什么，请解释\r\n * 2、程序执行完成后，变量$data的值是什么？\r\n */\r\n```\r\n\r\n#### 第一次进入循环：\r\n\r\n$data的第一个元素的key，value被赋值给$key 和 $value，\r\n\r\n此时$key=0，$value=a，执行$value = &$data[$key];时，$value指向$data[0]；\r\n\r\n此时第一次循环结束，$data值没有发生变化，还是[\'a\',\'b\',\'c\']；\r\n\r\n#### 第二次进入循环：\r\n\r\n$data的第二个元素的key，value被赋值给$key 和 $value，\r\n\r\n此时$key=1，$value=b，而此时的$value指向的是$data[0]的地址，因此$data[0]的值也变成b，执行$value = &$data[$key];时，$value指向$data[1]；\r\n\r\n此时第二次循环结束，$data的值为[\'b\',\'b\',\'c\']；\r\n\r\n后面类推，第三次循环结束$data的值为[\'b\',\'c\',\'c\']。', '1', '1', '2019-01-13 15:49:51', '2019-01-13 15:49:51');
INSERT INTO `posts` VALUES ('8', '4', '0', '2', 'Twig模版语言入门', 'Twig模版语言入门', 'Twig中有两种定界符{% ... %} 和 {{ ... }} ， \r\n\r\n前一种用来执行语句，比如for循环、IF判断、过滤等操作，后一种模版中用来显示变量。\r\n\r\n## Twig常用用法\r\n\r\n### 可用符号\r\n```\r\n== != < > >= <= + - ~ * / // % ** | [] . .. and or not in is b-and b-or b-xor\r\n```\r\n\r\n### 部分符号的含义如下\r\n```\r\n~：连接两字符串，相当于 PHP 中的点号\r\n//：整除\r\n**：乘方，相当于 PHP 中的 ^\r\nb-and、b-or、b-xor：按位与、按位或、按位异或\r\n-：减法以及去除空白的简写用法，如 {{- 数据 }} => 去除左边的空白、{{ 数据 -}} => 去除右边的空白、{{- 数据 -}} => 去除两边的空白\r\n```\r\n\r\n**注释**\r\n```\r\n{# This is Twig Comment #}\r\n```\r\n\r\n**变量**\r\n\r\nfoo 为PHP赋值变量， 则模版中可以使用 {{ foo }}\r\n如果该变量为数组或者对象，则可以使用 {{ foo.bar }}来表示，也可以直接调用类中的方法，如 {{ foo.getName }} 或当有参数传递时使用 {{ foo.getName(p1, p2, p3) }}\r\n\r\n当模版中使用{{ foo.bar }}时，PHP会做如下判断来检测对应变量的值：\r\n```\r\n1. 检测foo是否是数组，并且bar是一个有效的KEY\r\n2. 如果foo为对象，则检测bar是否为有效的属性\r\n3. 如果foo为对象，但bar不是一个有效的属性，则检测bar是否为有效方法\r\n4. 如果foo为对象，但bar不是一个有效的方法，则检测getBar是否为有效方法\r\n5. 如果foo为对象，但getBar不是有效方法，则检测isBar是否为有效方法\r\n6. 如果没有，则返回null\r\n```\r\n\r\n当foo为数组时，模版也可以这样使用：\r\n```\r\n{{ foo[\'bar\'] }}\r\n```\r\n\r\n变量未定义默认值设置：\r\n```\r\n{{ var|default(\'var is not defined\') }}\r\n```\r\n可使用 {% set 变量名=变量值 %} 声明变量，也可写成 {% set 变量名 %} 变量值 {% endset %}\r\n\r\nPHP 中非关联数组被映射成 [元素1, 元素2, ...]，关联数组则被映射成 {键1: 值1, 键2: 值2, ...}\r\n\r\n#### 数组遍历\r\n\r\n-- 按数组value遍历：\r\n```\r\n{% for value in foo %}\r\n    {{ value }}\r\n{% endfor %}\r\n```\r\n-- 按数组key遍历：\r\n```\r\n{% for key in foo|keys %}\r\n    {{ key }}\r\n{% endfor %}\r\n```\r\n\r\n-- 按key，value遍历\r\n```\r\n{% for key, value in foo %}\r\n    {{ key}}:{{value }}\r\n{% endfor %}\r\n```\r\n\r\n-- 如果 foo 非数组，还可以使用else语句，如：\r\n```\r\n{% for key, value in foo %}\r\n    {{ key}}:{{value }}\r\n{% else %}  \r\n    foo is Not a Array\r\n{% endfor %}\r\n```\r\n\r\n-- 也可以直接带条件，遍历二维数组时比较有用，可用value.field来判断：\r\n```\r\n{% for key, value in foo if value == 1%}\r\n    {{ key}}:{{value }}\r\n{% endfor %}\r\n```\r\n\r\n循环体内部变量：\r\n```\r\nloop.index	循环的次数（从1开始）\r\nloop.index0	循环的次数（从0开始）\r\nloop.revindex	循环剩余次数（最小值为1）\r\nloop.revindex0	循环剩余次数（最小值为0）\r\nloop.first	当第一次循环的时候返回true\r\nloop.last	当最后一次循环的时候返回true\r\nloop.length	循环的总数\r\nloop.parent	被循环的数组\r\n```\r\n\r\n#### 条件语句\r\n\r\n-- 需要使用 or 和 and 代替 ||、&&\r\n```\r\n{% if a == \'1\' or b == \'2\' %}\r\na = 1 or b = 2\r\n{% endif %}\r\n```\r\n\r\n-- 判断变量是否定义\r\n```\r\n{% if var is not defined %}\r\n    {# do something #}\r\n{% endif %}\r\n```\r\n\r\n-- 是否为NULL\r\n```\r\n{% if var is null %}\r\n    {# do something #}\r\n{% endif %}\r\n```\r\n-- 是否为false\r\n```\r\n{% if var is sameas(false) %}\r\n    {# do something %}\r\n{% endif %}\r\n```\r\n\r\n解析定界符\r\n```\r\n{{ \'{{\' }}\r\n \r\n{% raw %}\r\n    <ul>\r\n    {% for item in seq %}\r\n        <li>{{ item }}</li>\r\n    {% endfor %}\r\n    </ul>\r\n{% endraw %}\r\n```\r\n\r\n控制结构\r\n```\r\n{% if aaa %} xxx {% elseif bbb %} yyy {% else %} zzz：判断语句\r\n{% for %} xxx {% endfor %}：迭代变量\r\n{% do %}：没什么其他含义，{% do 1+2 %} 等同于 {{ 1+2 }}\r\n{% flush %}：刷新输出缓冲，等同于 flush\r\n{% include %}：包含模板\r\n{% extends %}：扩展模板\r\n{% embed %} xxx {% endembed %}：包含模板并扩展该模板的内容，相当于 include 和 extends 的结合体\r\n{% use %}：包含模板，近似于多重继承\r\n{% from aaa import bbb as ccc %}：从指定模板导入宏并设置别名\r\n{% macro %} xxx {% endmacro %}：定义宏以便多次调用，与定义 PHP 函数无异\r\n{% sandbox %} {% include xxx %} {% endsandbox %}：对导入的模板指定沙箱模式，只对 include 语句有效，只在沙箱模式已开启的情况下生效\r\n{% block xxx %} 或 {% block %} xxx {% endblock %}：定义代码块或覆盖代码块\r\n{% set xxx %} 或 {% set %} xxx {% endset %}：在模板内定义变量\r\n{% filter %} xxx {% endfilter %}：多行过滤器\r\n{% spaceless %} xxx {% endspaceless %}：去除 HTML 片段中的空格\r\n{% autoescape %} xxx {% endautoescape %}：将字符串安全地处理成合法的指定数据\r\n{% verbatim %} xxx {% endverbatim %}：阻止模板引擎的编译，是 raw 的新名字\r\n```\r\n\r\n内建过滤器\r\n\r\n过滤器用来修饰数据，各过滤器可以用竖线分隔进行链式调用，用括号传递参数\r\n\r\n也可以将过滤器当成单独的函数来用，形式如下：\r\n```\r\n{% filter 过滤器名 %}\r\n待处理的数据\r\n{% endfilter %}\r\n```\r\n\r\nbatch：将数组按指定的个数分割成更小的数组，可选的第二个参数用来在元素不够的情况下进行填充。\r\n如 \r\n```\r\n{{ [1, 2, 3, 4, 5]|batch(2, \'NoItem\') }} => [[1, 2], [3, 4], [5, \'NoItem\']]\r\n```\r\ndate_modify：修改时间，常与 date 联用。\r\n\r\n如 {{ \'\'|date_modify(\'+3 days\')|date(\'Y-m-d\') }} => 将当前时间加3天后显示\r\n\r\ndefault：当所修饰的数据不存在或为空时，提供默认值。\r\n\r\n如 {{ \'\'|default(\'Ruchee\') }} => \'Ruchee\'\r\n\r\nescape：将字符串安全地处理成合法的指定数据，可简写为 e，支持多种转换模式，默认模式为 html，其他可选模式有 html_attr、js、css、url\r\n\r\nfirst：返回数组的第一个元素或字符串的第一个字符。如 {{ {a: 1, b: 2, c: 3}|first }} => 1\r\n\r\nlast：返回数组的最后一个元素或字符串的最后一个字符。如 {{ {a: 1, b: 2, c: 3}|last }} => 3\r\n\r\nreplace：替换一个字符串中的指定内容。如 {{ \'%s1 love %s2\'|replace({\'%s1\': \'Ruchee\', \'%s2\': \'Vim\'}) }} => \'Ruchee love Vim\'\r\n\r\nraw：让数据在 autoescape 过滤器里失效\r\n\r\n借用自PHP自带函数的过滤器\r\n```\r\nabs：取绝对值\r\nnl2br：将字符串里的 \\n 替换成 <br/>\r\njoin：将数组的各个元素按指定分隔符组成字符串\r\nsort：对数组排序\r\ntrim：去除字符串首尾的指定字符，默认为空格\r\ndate：格式化时间，可处理与 strtotime 兼容的字符串，或 DateTime/DateInterval 的实例，可选的第二个参数用于指定时区，如果所修饰的数据为空则默认为当前时间\r\nreverse：反转一个数组或字符串，在 array_reverse 的基础上增加了对字符串的处理\r\nslice：截取数组或字符串的一部分，在 array_slice 的基础上增加了对字符串的处理\r\nkeys：将数组的全部键名提取成一个数组，等同于 array_keys\r\nmerge：合并两数组，近似于 array_merge 。如 {{ 数组1|merge(数组2) }}\r\nlength：返回数组元素的个数或字符串的长度，等同于 count 和 strlen 的结合体\r\ncapitalize：将字符串的首字母大写，等同于 ucfirst\r\ntitle：将字符串中每个单词的首字母大写，等同于 ucwords\r\nlower：将字符串所有字母全部变成小写，等同于 strtolower\r\nupper：将字符串所有字母全部变成大写，等同于 strtoupper\r\nsplit：将字符串分割成数组，等同于 str_split\r\nstriptags：去除字符串中的 HTML/PHP 标记，等同于 strip_tags\r\nurl_encode：编码链接字符串，等同于 urlencode\r\njson_encode：编码 JSON 格式，等同于 json_encode\r\nformat：格式化一个字符串，近似于 printf 。如 {{ \'My name is %s, and I love %s\'|format(\'Ruchee\', \'Vim\') }} => \'My name is Ruchee, and I love Vim\'\r\nnumber_format：格式化数值，等同于 number_format\r\nconvert_encoding：编码转换，第一个参数指定转换后的编码，第二个参数指定转换前的编码，近似于 iconv\r\n```\r\n\r\n#### 内建函数\r\n```\r\neven：是否为偶数\r\nodd：是否为奇数\r\nempty：是否为空\r\nnull：是否为 null\r\ndefined：是否已定义\r\nsameas：目标变量与指定值是否指向的是内存中的同一个地址，使用形式 if 变量值 is sameas(指定值)\r\ndivisibleby：目标数值是否能够被指定值整除，使用形式 if 目标数值 divisibleby(指定值)，其中指定值不能为 0\r\niterable：目标变量是否是数组或者是否可迭代，使用形式 if 变量值 is iterable\r\nattribute：动态获取变量属性值，两种使用形式为 attribute(数组, \'元素名\') 和 attribute(对象, \'方法名\', 可选参数)\r\nblock：重复引用指定代码块，如 {{ block(\'title\') }}\r\nconstant：从字符串或对象取得常量值\r\ncycle：循环显示一个数组的元素，调用形式为 cycle(数组, 一个循环变量)\r\ndate：格式化时间\r\ndump：在开启调试模式的情况下显示详细的变量信息，等同于 var_dump\r\ninclude：包含其他模板文件\r\nparent：在覆盖代码片段时用于引用父片段的内容\r\nrandom：制造一个随机数\r\nrange：返回一个指定区间的数组，可指定步长，Twig 使用 .. 作为其简用法，等同于 range\r\ntemplate_from_string：根据字符串加载模板\r\n```', '1', '1', '2019-01-13 16:08:07', '2019-01-13 16:08:07');
INSERT INTO `posts` VALUES ('9', '3', '0-3', '2', 'php mb_substr()函数的详细解释！', 'php mb_substr()函数的详细解释！', 'PHP substr()函数可以分割文字，\r\n\r\n但要分割的文字如果包括中文字符往往会遇到问题，\r\n\r\n这时可以用mb_substr()/mb_strcut这个函数，\r\n\r\nmb_substr() /mb_strcut的用法与substr()相似，\r\n\r\n只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，\r\n\r\n但是 一般的服务器都没打开php_mbstring.dll，需要在php.ini中把php_mbstring.dll打开。\r\n```\r\n<?php \r\necho mb_substr(\'菜鸟变大神的phpms框架\',0,9); \r\n?>\r\n```\r\n输出：菜鸟变\r\n\r\n现在我们加上字符集utf-8\r\n```\r\n<?php \r\necho mb_substr(\'菜鸟变大神的phpms框架\',0,9,\'utf-8\'); \r\n?>\r\n```\r\n输出：菜鸟变大神的php; \r\n\r\n第一个是以三个字节为一个中文，这就是utf-8编码的特点，下面加上utf-8字符集说明，所以，是以一个字为单位来截取的\r\n\r\n \r\n\r\n下面是ecshop里面的截取UTF-8编码下字符串的函数\r\n```\r\n function sub_str($str, $length = 0, $append = true){\r\n       $str = trim($str);\r\n       $strlength = strlen($str);\r\n   \r\n       if ($length == 0 || $length >= $strlength)\r\n       {\r\n           return $str;  //截取长度等于0或大于等于本字符串的长度，返回字符串本身\r\n       }elseif ($length < 0)  //如果截取长度为负数\r\n       {\r\n          $length = $strlength + $length;//那么截取长度就等于字符串长度减去截取长度\r\n          if ($length < 0)\r\n          {\r\n              $length = $strlength;//如果截取长度的绝对值大于字符串本身长度，则截取长度取字符串本身的长度\r\n          }\r\n      }\r\n  \r\n      if (function_exists(\'mb_substr\'))\r\n      {\r\n          $newstr = mb_substr($str, 0, $length, EC_CHARSET);\r\n      }elseif (function_exists(\'iconv_substr\'))\r\n      {\r\n         $newstr = iconv_substr($str, 0, $length,EC_CHARSET);\r\n      }else\r\n      {\r\n          //$newstr = trim_right(substr($str, 0, $length));\r\n          $newstr = substr($str, 0, $length);\r\n      }\r\n  \r\n      if ($append && $str != $newstr)\r\n      {\r\n          $newstr .= \'...\';\r\n      }\r\n  \r\n      return $newstr;\r\n  }\r\n```\r\n菜鸟程序员不懂什么是算法，好的程序员是一切皆为算法。', '1', '1', '2019-01-13 16:25:08', '2019-01-22 02:28:02');
INSERT INTO `posts` VALUES ('10', '4', '0', '2', '【Git】Git pull 强制覆盖本地文件', 'git fetch --all  \r\ngit reset --hard origin/master \r\ngit pull\r\n\r\n\r\n\r\n备注：\r\n\r\ngit fetch 只是下载远程的库的内容，不做任何的合并 \r\n\r\ngit reset 把HEAD指向刚刚下载的最新的版本', '\r\n```\r\ngit fetch --all  \r\ngit reset --hard origin/master \r\ngit pull \r\n```\r\n\r\n\r\n备注：\r\n\r\ngit fetch 只是下载远程的库的内容，不做任何的合并 \r\n\r\ngit reset 把HEAD指向刚刚下载的最新的版本', '1', '1', '2019-01-13 18:54:11', '2019-01-13 18:54:11');
INSERT INTO `posts` VALUES ('11', '1', '0', '2', '近期面试总结（PHP后端开发工程师）（部分笔试题）', '近期面试总结（PHP后端开发工程师）（部分笔试题）', '## 近期面试总结\r\n1.字符串\"0\"在PHP和js中转换为布尔值是false还是true\r\n```\r\nphp:false;  php 弱语言 \'0\'和0一样；\r\n \r\njs:true；字符串除了空字符串(\'\')其他都是true（包括\' \' 这种中间有空格的）;\r\n```\r\n\r\n2.   echo，print_r ，print,var_dump 区别\r\n\r\n```\r\necho：语句结构；\r\nprint：是函数，有返回值\r\nprint_r：能打印数组，对象\r\nvar_dump:能打印对象数组，并且带数据类型\r\n```\r\n \r\n3.如何获取客户端的IP（要求取得一个int）和服务器端的IP的代码\r\n\r\n``` \r\n$ip = $_SERVER[\"REMOTE_ADDR\"];  \r\n//或者：getenv(\'REMOTE_ADDR\'); \r\n//转化为int  \r\n$intIP =  ip2long($ip);\r\n$_SERVER[\"SERVER_ADDR\"];\r\ngethostbyname(\'www.baidu.com\');\r\n```\r\n\r\n4.mysql联合索引index_a_b_c(a,b,c) charset=utf8，a int(10),b varchar(10),c tinyint(1),问条件where a = 5 and c = 1用到的索引长度。\r\n```\r\n索引长度：4+1 = 5  (用到a，c)\r\n```\r\nwhere a=5 and b = \"hahah\"; \r\n```\r\n索引长度：4+10*3+2 = 36 (用到a,b)\r\n```\r\n5.json和jsonp的区别，什么时候用。\r\n```\r\njsonp 跨域请求\r\n```\r\n6.写出点击一个div出现相应的序号的js\r\n\r\n7.session和cookie的区别和联系\r\n\r\n8.PHP实现遍历出文件夹和他下面子文件的代码\r\n\r\n```\r\n<?php\r\n   $dir = \'/Users/zhaoning/Desktop/算法\';\r\n   function getAllFile($dir){\r\n        $allFileArr = array();\r\n             if (is_dir($dir)) {                     \r\n                $res = opendir($dir);\r\n                while ($row = readdir($res)) {\r\n                  if ($row == \'.\' || $row == \'..\') {\r\n                      continue;\r\n                  }\r\n                  if (is_file($dir.\'/\'.$row)) {\r\n                      $allFileArr[] = $row;\r\n\r\n                  }else if (is_dir($dir.\'/\'.$row)) {\r\n                    $allFileArr[$row] =getAllFile($dir.\'/\'.$row);\r\n                  }\r\n\r\n             }\r\n\r\n             closedir($res);\r\n\r\n        }\r\n\r\n        return $allFileArr;\r\n\r\n      }\r\n\r\n      var_dump(getAllFile($dir));\r\n\r\n?>\r\n```\r\n\r\n9.写出匹配html标签的而不匹配div span img的正则表达式\r\n\r\n10.写出下面正则表达式的含义\r\n\r\n$  ^   [^]  ?    ?:   \r\n\r\n\r\n11.PHP中this和self的区别\r\n```\r\n        this：对象\r\n\r\n        self：类\r\n```\r\n12.如何防止SQL注入，XSS攻击和CSRF攻击\r\n```\r\nSQL注入：mysqli_real_escape_string()转义关键字符；\r\nXSS攻击：alert把一些cookie信息打印出来；过滤掉<>等关键字符串\r\nCSRF攻击：跨站攻击。防止：token，验证码\r\n```\r\n\r\n13.Linux的命令：查找出文件名后缀是.txt的，内容包含delete的文件，并删除\r\n```\r\nfind / -name \"*.txt\" | xargs -n1 -I(这是i) \'xxx\' grep -l(这是L)  \'delete\' \'xxx\' | xargs -n1 -I \'zzz\' rm -f \'zzz\'\r\n```\r\n\r\n14.PHP解决多进程读写一个文件的方法\r\n```\r\nfunction putFile($file,$mode=\"w\"){\r\n           $file = fopen($file,$mode);\r\n            if(flock($file,LOCK_EX)){\r\n                    fwrite($file,\'write a word\');\r\n                    flock($file,LOCK_UN);\r\n            }else{\r\n                    echo \"无法访问\";\r\n\r\n            }\r\n            fclose($file);\r\n}\r\n```\r\n\r\n15.数据库表的引擎有哪几种？区别和场景\r\n```\r\nMyISAM:多用于select\r\n\r\nInnodb：事务\r\n\r\nmemory：内存中，存储快\r\n\r\nmerge:用于日志和数据仓库\r\n\r\narchive：用于日志，只有select和insert，不支持索引。\r\n```\r\n\r\n16.nginx和PHP的工作原理\r\n\r\n17.ES连接PHP的扩展叫什么名字\r\n```\r\nelasticsearch \r\n```\r\n\r\n18.调用接口需要什么，签名怎么生成的，登陆接口的实现\r\n```\r\n签名：(  token + 时间戳  )  加密  =  sign  \r\n```\r\n\r\n19.接口返回包含哪几部分。\r\n```\r\n{\r\n\r\n       code:\r\n\r\n       msg:\r\n\r\n       data:{}\r\n\r\n}\r\n```\r\n1.不知道什么的英文\r\n\r\n2.PHP错误种类.\r\n\r\n3.var_dump(0123==123);var_dump(\'0123\'==123);  false true\r\n\r\n4.36个人，6个赛道，没有秒表，比赛多少次能够得出前三名？\r\n\r\n5.正方形四个角有四个虫子，虫子沿边走，问：虫子相遇（两个碰头）的概率是多少？\r\n\r\n6.A去买水果3.5斤共14元，给老板B  20 元 ，B没零钱，找隔壁C换20元，回来后找A  6元，C发现这个钱是假的，找B，B又给C 20 元。问：B一共亏了多少钱。\r\n\r\n7.快排\r\n\r\n8.同一个ip，10分钟能只能访问5次\r\n\r\n9.设计微博粉丝互粉，用户1亿。\r\n\r\n问答：\r\n\r\nhttp协议包含几部分。\r\n\r\n接口是怎么实现的。\r\n\r\ntoken 是怎么生成的。\r\n\r\n你知道哪些加密。\r\n\r\n如何防止http包的数据篡改。比如说转账10块，http包被劫，改成100块了。\r\n\r\n \r\n针对有项目经验的面试梳理：\r\n\r\n1.自我介绍。\r\n\r\n在哪工作，多长时间。做了什么东西，项目背景，用到的技术，负责什么工作。\r\n\r\n```\r\n答案：之前在北京一家软件外包公司工作，工作1年多。参加的项目有vbank8素材管理和小乐定制订单管理。vank8是一款用户上传个人素材，他人下载即可获取收益软件。主要用的PHP+smarty+云oss。我主要oss的大文件管理，以及防盗链处理。小乐定制主要是面向企业及个人开发的，主要是卖台历，也可以自定义台历的背景，客户可以编辑自己的台历，分享，获取一定的收益。我主要负责后台图集和模板素材这一块。\r\n```\r\n\r\n问：redis起什么作用？\r\n```\r\n减少访问es的次数\r\n\r\n懒加载（访问redis没有数据，然后去查ES，把结果导入数据redis里面）有什么弊端？\r\n\r\n数据不同步的问题。\r\n```\r\n\r\n怎么解决数据不同步？\r\n```\r\n1.把懒加载换成定时跑数据。\r\n\r\n2.从ES里面读取近期是否有数据变化，如果有从新读取ES。没有的话在还用原来的redis里面的数据。\r\n```\r\n\r\n2.apache和nginx的区别\r\n```\r\n工作模式：\r\n\r\napache 有两种模式perfork，worker模式\r\n\r\nperfork：\r\n\r\nworker：\r\n\r\nnginx的epoll和select：\r\n\r\nepoll：模式单线程异步非阻塞。\r\n\r\nselect：选择性的\r\n```\r\n\r\n3.Innodb和My ISAM的区别\r\n```\r\nMyISAM：\r\n\r\n支持全文索引，\r\n\r\n不支持事务。\r\n\r\n存储结构：三个文件，一个数据文件，一个索引文件，一个表文件。\r\n\r\n表级别的锁。\r\n\r\nInnodb：\r\n\r\n不支持全文索引，\r\n\r\n支持事务。\r\n\r\n存储结构：所有表同一个文件。\r\n\r\n行级别的锁。\r\n```\r\n\r\n4.hash索引和b+tree索引的区别\r\n```\r\nHash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。\r\n\r\n可能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。\r\n\r\n（1）Hash 索引仅仅能满足\"=\",\"IN\"和\"<=>\"查询，不能使用范围查询。\r\n\r\n由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。\r\n\r\n（2）Hash 索引无法被用来避免数据的排序操作。\r\n\r\n由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；\r\n\r\n（3）Hash 索引不能利用部分索引键查询。\r\n\r\n对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。\r\n\r\n（4）Hash 索引在任何时候都不能避免表扫描。\r\n\r\n前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。\r\n\r\n（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。\r\n\r\n对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。\r\n\r\nhash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间。\r\n\r\nb-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小。\r\n```', '1', '1', '2019-01-13 23:18:10', '2019-01-13 23:18:10');
INSERT INTO `posts` VALUES ('12', '14', '0', '2', '八个小步骤建立你的微习惯，最简单实用自我管理法则', '八个小步骤建立你的微习惯，最简单实用自我管理法则', '如何提升自我控制力，今天想和大家探讨是建立你的微习惯，心理学发现，我们总是会习惯性高估自己的自控力这就是我们常说的欲望和能力不匹配。\r\n\r\n所以如果我们真想培养一个习惯，不如从一个微小的习惯开始，比如，我们每天想做100个俯卧撑，可以变成每天做一个，或者每天想看一本书，变成每天看两页书，把大目标变成微小目标，就能逐步提升我们的自控力。微习惯可以说运用最少的意志力强迫我们自己做一件事，也是最容易实施落地的。今天和大家分享下心理学家斯蒂芬.盖斯如何通过自身实践，建立微习惯，大幅提升你的自我管理能力技巧：\r\n\r\n## 1、选择最适合你的微习惯和计划，以周为习惯评估你的微计划实施情况\r\n\r\n把你想要的某一时刻拥有习惯列成一张简要清单，建议刚开始从一个微小习惯开始，比如像我刚刚所说，锻炼身体可以从每天先练习一个俯卧撑开始，往往很多时候，一个微小的行动就开启了我们生命真正的改变。\r\n\r\n如果你足够自律，微习惯数量也不要超过四个。然后通过这个微习惯，先进行一周的评估，如果你的大脑还挺适应，就可以继续进行。\r\n\r\n## 2、挖掘每个微习惯内在价值\r\n\r\n很多人没有建立微习惯主要原因实际上最重要的就是没有认清这个习惯来源，这个正如韩寒所说，“为什么我们听说过这么多道理依然过不好这一生”。其实最重要是我们没有理解每个微习惯内在价值，所以很多人即使知道健康很重要，但还是不愿意付出时间去健身，因为还没有触及到他内心价值点。\r\n\r\n所以在做这一步的时候，问清楚为什么，我们要做这个事情内在动力是什么，请记住不是外部压力，而是你的内在动力，例如，我想每天写作，主要原因不是外在压力，而是因为这种方式是我喜欢方式。我想通过写作和大家建立联系帮助他们，而且我享受这个过程。\r\n\r\n\r\n\r\n## 3、明确习惯依据，纳入你的日程\r\n\r\n通常来说，培育习惯常见方式有两种，时间和行为方式，通常来说，朝九晚五人群日程非常规律，可以选择时间来选择，比如选择周一或者周四进行锻炼。而如果日程安排比较灵活的人，建议用行为方式，比如说我每天吃完饭后去锻炼，这个依据主要依靠你的生活方式，通过这种方式建立好自己的习惯依据，会让你更为舒服。\r\n\r\n\r\n## 4、建立回报机制，以奖励提升成就感\r\n\r\n如果你想建立你的微习惯，最好是能建立你的头脑回报机制，因为我们的大脑运作方式就是这样，如果没有回报，大脑其实会变成一种抵触，所以一旦建立了回报机制，就能激发你后续的努力。比如锻炼可以让我们拥有马六甲线，可以有良好的感觉或者健康的体魄，比如写作可以让我拥有好的文笔，深度思考等都是比较正向的回报关联，这种回报关联能让我们对习惯养成更好基础，也会持续增强我们意志力。\r\n\r\n\r\n\r\n## 5、记录与复盘完成情况\r\n\r\n当你想到某件事情的时候，立刻把它写下来，有研究表明，一旦我们把想法写在纸上，会让大脑更加突出。所以每天坚持复盘会让我们更容易记住这个习惯，建议用日历的方式进行追踪或者现在流行的打卡都是一种有效方式。\r\n\r\n## 6、微量开始，超额完成\r\n\r\n制定微小的习惯不是说缩小我们目标，而是通过微小习惯逐步建立可以掌控的意志力，意志力的优点是伴随我们习惯可以逐步得到强化。微习惯从最小的量开始，帮助我们强化意志力，让我们从当下就取得进步，从而建立一种正向的循环。\r\n\r\n\r\n## 7、服从计划安排，摆脱高期待值\r\n\r\n期待是我们对目标与习惯养成的一种重要因素，因为期待所以让我们继续有动力去逐步完成我们习惯建立，但是最好避免是某种行为产生较高的期待值。而微习惯就是让我们逐步提高对自己的期待，每天微小目标养成让我们可以保持良好的自信，因为我们知道自己每天都在为我们微目标而努力，这样就开始建立起与我们大脑合作，而不再只是对抗。\r\n\r\n\r\n## 8、留意我们微习惯养成标志\r\n\r\n我们每天开始建立微习惯动作就是确保每天养成微习惯，只有真正微习惯建立起来了，我们才算真正的成功，什么时候代表我们微习惯建立了，可以从下面几个方面挖掘：\r\n```\r\n1）再也没有抵触情绪，做起来很容易；\r\n\r\n2）通过时间累积，非常认同你微习惯身份，比如我是健身达人，我是个业余作家等等；\r\n\r\n3）你不再恐惧与担心，刚开始微习惯你会担心自己坚持不下去，但是等到有一天你发现你一直习惯做这个事情，已经变成你很深刻烙印了；\r\n\r\n4）、常态化，习惯是一种情绪化，当你情绪更为平和的时候，不再激动，另一方面你会发现他也不再令你完全兴奋，而是它切实对你有好处。\r\n```\r\n此时通过这些你内心变化，你会发现这个习惯已经逐步在你大脑中形成了，从而变成你一生的财富。', '1', '1', '2019-01-14 00:59:52', '2019-01-14 00:59:52');
INSERT INTO `posts` VALUES ('13', '14', '0', '39', '十分钟读完《微习惯》', '十分钟读完《微习惯》', 'by 斯蒂芬 • 盖斯 (Stephen Guise)\r\n\r\n```\r\n一家银行可能因为规模太大而不至于失败，而微习惯是因为太小而不至于无法完成。\r\n```\r\n\r\n## 第1章 微习惯是什么\r\n\r\n一起开始你的第一个微习惯吧。\r\n\r\n每天至少读两页这本书，直到读完为止。可以多读一些，但每天绝不能少于两页。从现在开始，你可以一边阅读关于微习惯的本书，一边体会真正“拥有”一个微习惯是什么感受。\r\n\r\n### 一切的源头：挑战1个俯卧撑\r\n\r\n“太可悲了！1个俯卧撑有什么用，我得多锻炼才行！”可每当我想按最初计划行动时，又做不到了。因为我的30分钟锻炼计划总是失败，最后我心想“管他呢，就做1个俯卧撑得了”，于是我趴在地上做了1个俯卧撑，然后，我的人生从此走向了光明。\r\n\r\n我把一个俯卧撑变成了看似不可能的30分钟锻炼，第二天我就写下了《挑战1个俯卧撑》，它成了我的博客上迄今为止人气最高的文章之一。\r\n\r\n### 只为培养好习惯\r\n\r\n微习惯策略只会帮你培养好习惯，给你的生活增添积极行为，持续丰富你的生活。消除坏习惯和建立好习惯有着共同的目标——用更好的行为方式取代原有的行为方式。\r\n\r\n### 微习惯简介\r\n\r\n微习惯体系的基础在于“微步骤”，那些“小得不可思议的一小步”。如果你想培养一个新习惯，微习惯基本上就是它经过大幅缩减的版本——把“每天做100个俯卧撑”缩减成每天1个，把“每天写3000字”缩减成每天写50字，把“始终保持积极思考”缩减成每天想两件好事。微习惯就是你强迫自己每天做的微不足道的积极行动。\r\n\r\n### 习惯和大脑探秘\r\n\r\n没有什么比习惯更重要了。杜克大学的一项研究表明：我们的行为中大约有45%源于习惯。习惯其实远比这45%的比重代表的含义更重要，因为习惯是不断重复的行为，而且大部分每天都在重复，长远看，这种不断的重复叠加起来，要么收益颇丰，要么贻害无穷。\r\n\r\n### 习惯在大脑里的样子\r\n\r\n神经通路是大脑里的沟通渠道，这些通路就是习惯在身体里的“长相”。它的工作机制是这样的：一旦某个习惯指定的神经通路被一个想法或外部信号触发，脑中就会有一个电荷沿着这条通路放电，然后你就会有一股想进行这项习惯行为的强烈欲望。比如，如果你每天醒后都要马上洗澡，那就会有一个神经通路和这个行为关联。你一醒来，这个“洗澡神经元”就会放电，然后你就会像僵尸一样走过去洗澡——根本无须思考！\r\n\r\n### 习惯还与压力有关\r\n\r\n已有研究显示，压力会促进习惯性行为，无论这种习惯是好是坏。温迪 • 伍德博士根据她在《人格和社会心理学杂志》上发表的研究提出：“遇到压力时，人们无法轻易做出决定，意志力会减弱或令人感到不知所措。你没有精力做出决定时，往往会重复平时的做法。”\r\n\r\n### 养成新习惯需要多长时间？\r\n\r\n一个行为变成习惯所需的时间平均为66天，但不同行为所需时间相差很大，从18天到254天不等，这表明人们将习惯自动化所需时间千差万别，在某些案例中，这个时间可能惊人地长。\r\n\r\n## 第2章 大脑的工作原理\r\n\r\n建立习惯的目标是用重复来改变大脑。可是大脑会抗拒改变，除非它们能大方地给大脑一些回报。\r\n\r\n### 变化缓慢、状态稳定的大脑\r\n\r\n人类大脑很稳定，不易改变。它有一套对外部世界做出反应的固定体系。有一个不易改变的大脑有时会让人感到沮丧，可总体上说，好处还是相当多的。试想如果你的人格和生活习惯能一天变一个样会如何——你肯定会发疯的！\r\n\r\n### 愚蠢的重复者与聪明的管理者\r\n\r\n你大脑中绝大部分是愚蠢的。好吧，确切地说，不只是你一个人的大脑——你抽烟的时候，它不会考虑到肺癌的可能性，你锻炼之前，它也不会幻想漂亮腹肌的好处，从这个意义上看，每个人类大脑的某一个部分都是愚蠢的。更糟糕的是，它是大脑里比较顽固的部分，会找到长期维持这种状态的方法。它会识别并重复模式，直接接收到不同的新指令。它的名字叫作基底神经节。\r\n\r\n然而，大脑的另一个区域前额皮层则相当聪明。它就在前额的后面，是个可以理解长远利益和结果的管理者，感谢上天，它拥有抑制基底神经节的能力。它还负责处理短期思维和决策。\r\n\r\n## 第3章 动力 v.s. 意志力\r\n\r\n我非常讨厌采用动力作为启动策略，动力和意志力不是非此即彼的，二者之间存在重要的关系。\r\n\r\n### “激发动力”策略的诸多问题\r\n\r\n激发动力有效果吗？答案有时让人很恼火。\r\n\r\n### 动力并不可靠\r\n\r\n动力之所以不可靠，是因为它以人的感受为基础，而人类的感受容易改变且无法预测已经是几百年来公认的事实了。\r\n\r\n### 你不会每次都愿意激发动力\r\n\r\n问题在于，动力是很难(有时几乎不可能)按需培养的。当你累了，生病了，头疼，感觉“不在状态”或只想做一些更好玩的事情时，激发动力容易吗？只有在精力充沛、思维模式健康而且没有受到强烈诱惑时，我们才能依靠动力成功。\r\n\r\n### 有人习惯地认为动力是行动的唯一基础\r\n\r\n坚信必须有动力才能行动是一种毁灭性的习惯。如果只是“我想激发动力”，那它就不成问题；可是如果不激发动力就什么都做不了，那它就是个问题。它是坠入“懒惰漩涡”的完美路线。懒惰会让你感到什么都不想干，如果你总是在什么都不想干的同时奉行动力法则，那你就会一直懒下去，没有出路。\r\n\r\n### “热情递减法则”是动力让我们失败的原因\r\n\r\n当一种行为成为一个习惯，你会变得没有刚开始时那么情绪高涨，这种行为甚至开始有些乏味无聊。\r\n\r\n刚开始做一件事的兴奋在最初会有很大帮助，可是等这股劲头渐渐消失，你开始怀疑有什么地方出了什么问题的时候，它又会成为强大的敌人。如果最开始就选择不依赖动力和感受，就能有效降低这种风险。\r\n\r\n### 为什么意志力能打败动力？\r\n微习惯的意志力策略能帮助人们提升动力。借助意志力，动力会变得更加可靠；而且如果先采取行动，动力就会被迅速地激发。\r\n\r\n### 意志力很可靠\r\n\r\n如果你能强迫自己做到某件事，无论是什么事，这种成功都会体现意志力的可靠性。\r\n意志力可以被强化\r\n和动力不一样，意志力可以像肌肉一样得到强化。1999年，自控力研究领域的顶尖学者罗伊 • 鲍迈斯特发现：和没有进行健身的学生相比，那些花两周时间磨炼意志力以改善体形的学生“在随后的自控力测试中有显著的进步”。\r\n\r\n### 意志力策略可以通过计划执行\r\n\r\n如果运用意志力，你可以给某项活动安排一个时间表。不管到时候有没有足够动力，你都可以顺利完成，这样就容易坚持下去，既有利于习惯养成，也有利于时间安排。\r\n\r\n### 意志力的工作原理\r\n\r\n人们曾认为意志力能给我们提供取之不尽、用之不竭的意志。鲍迈斯特在1996年进行了一项多少有些残酷的研究，纠正了这个观点。\r\n\r\n### 做决定也会消耗意志力\r\n\r\n一项自控力研究发现：在同一天里做过艰难决定的人在后来面对诱惑时屈服的可能性更高，这体现了自控力的下降。\r\n\r\n### 一项重要的意志力元分析\r\n\r\n元分析是从指定主题的相关文献中提取出重要结论的过程，可以说是“对研究的研究”，它有助于消除个体研究中出现的偏差。2010年，研究人员针对87项自我损耗研究进行了一次元分析。这项元分析发现了引起自我损耗的5个最重要的因素：努力程度、感知难度、消极情绪、主观疲劳和血糖水平。\r\n\r\n## 第4章 微习惯策略\r\n微习惯策略就是强迫你自己每天实施1到4个“小到不可思议”的计划好的行动，这些行动小到不会失败，小到不会因为特殊情况就被你轻易放弃。它们有双重作用——激励你继续做下去，并会成为(微)习惯。\r\n\r\n### 以微习惯方式运用意志力\r\n当你的意志力储备充足时，微习惯策略会让你开始行动，能帮你获得额外进步。当你彻底精疲力竭，意志力耗尽时，微习惯策略在任何情况下都能让你采取行动，帮你把当时的能力发挥到最佳水平。\r\n\r\n### 努力程度\r\n\r\n微习惯需要非常少的实际努力。比如，你打算做一个俯卧撑，写50字，阅读2页书，或完成其他非常简单的任务。\r\n\r\n### 感知难度\r\n\r\n微习惯的本质决定它几乎不会让你在还没做的时候就感到困难，这个重要的优点在你超额完成任务时更为显著。一旦你开始做且能随心所欲地继续下去，“已经开始”带来的心理影响会让感知难度明显降低。\r\n\r\n### 消极情绪\r\n即使微习惯取代了一件令你开心的事情，你要做的努力也太少了，少到你根本不会感觉到任何消极情绪。\r\n\r\n### 主观疲劳\r\n\r\n一想到你的微目标，你就会感到精力充沛，而且会有一种能量涌现的感觉。甚至当我(主观感到)疲惫不堪时，我仍感觉有足够精力阅读2页书或写50字。\r\n\r\n### 血糖水平\r\n\r\n虽然血糖水平和微习惯相对独立，但微习惯的确会节约能量和意志力，而且会在心理上不断给予你能量，所以它可以在最大程度上保留血糖。在你因为血糖低而感觉疲劳时，最有可能让你行动起来的就是微习惯。\r\n\r\n### 微习惯如何拓宽你的舒适区\r\n\r\n你现在有一个心理舒适区(comfort zone)，把它想象成一个圆圈。在圆圈时你感觉最舒适，而圆圈外是你想达到的目标。微习惯的策略就像走到圆圈的边缘，然后向外迈出一步。这是一个相对不舒适的地方，但因为你知道走一步就可以回到舒适区里，所以差别不会很明显。也许在前几次尝试时，你可能会退回舒适区里(在只实现了微目标后)。可当你继续向圆圈外走去时，你的潜意识就会逐渐适应，接下来你的圆圈就会拓宽(我指的是微习惯开始形成)。\r\n\r\n## 第5章 微习惯的独特之处\r\n\r\n### 微习惯与现有习惯一较高下\r\n微习惯策略的竞争力远超其他习惯策略。你试图养成一个新习惯时，好像没经过任何训练就参加了一场举重比赛，本来竞争就很激烈，更糟糕的是，对手经验丰富，久经考验，而且力量更强。大多数习惯策略在这个节点就会犯错了，它们会让你相信，你现在就可以跟这些更强大的习惯硬碰硬。这些策略鼓励你做出大幅度的改变，比如从很少写作到每天写2000字，或者从在沙发上躺着到每天锻炼一小时。\r\n\r\n### 微步骤+意志力是必胜组合\r\n\r\n个人成长的完美组合就是微步骤加上意志力。只要你有足够的意志力完成一个行动，就可以采取这项行动。微习惯几乎不需要意志力，所以这就让你好像拥有了无穷的意志力。\r\n\r\n### 微习惯没有截止时间\r\n习惯的形成需要18到254天，具体要视习惯和个体而定。微习惯策略没有具体的截止时间，因为我们并不知道形成一个习惯需要多大时间，但我们要寻找的是行为变成习惯的信号。\r\n\r\n### 微习惯能提升自我效能感\r\n“自我效能感”是指对自己影响事件结果的能力的信念。微习惯策略是一个产出自我效能感的机器，重点是，你不需要任何自我效能感就能成功地开始行动，而你每天的成功会帮助你提升自我效能感。\r\n\r\n### 微习惯能给予你自主权\r\n\r\n你会以天或星期为时间段给自己设定严格的目标，可是它们实践起来特别轻松，所以你在潜意识里不会感到自己被你的计划控制(这是重点！)，在完成微目标后，你就可以自由选择做自己想做的事。\r\n\r\n### 抽象和具体目标与微习惯相结合\r\n\r\n因为微习惯能促进抽象目标和具体目标的进展，所以不管总体上更擅长哪一种目标，你都能成功。\r\n\r\n### 远离恐惧、怀疑、胆怯或犹豫\r\n\r\n行动是征服这些消极情绪的最佳武器。微习惯会强迫你迈出第一步，因为这实在太简单了。即使你迈出第一步后马上就回到了舒适区，明天仍然会走出来，你最终会迈出\r\n第二步。\r\n\r\n微习惯增强正念和意志力，给你超乎想象的惊喜\r\n\r\n正念是一个人能培养出的最重要的技能之一，它指的是对自己思维和行动有清醒的认识。如果你的微习惯是每天喝一杯水，那么你就会对自己总共喝了多少水有所认识。如果你必须每天监控一件事，不管这件事有多微不足道，你的意识都会越来越多地关注它，甚至在完成目标之后还想着它。\r\n\r\n另一个惊喜是意志力的增长。意志力需要原始力量，但更需要耐力，所以频繁重复小任务就是“锻炼”意志力的理想方法。你的意志力越强，对自己身体的控制就越好。\r\n\r\n## 第6章 彻底改变只需八步\r\n\r\n### 第1步：选择适合你的微习惯和计划\r\n\r\n把你想在某一时刻拥有的习惯列成一张简要的清单，重要的习惯会很快浮现在你脑海里。它将成为你在第一步的参考清单。\r\n\r\n### 一周弹性计划(推荐)\r\n\r\n根据这个计划，你从一个习惯开始，使用微习惯策略一周时间，然后进行评估并选择一个长期计划。\r\n\r\n### 单一微计划\r\n\r\n能持续写作是你最想达到的目标吗？你想认真健身吗？你想每天投入地阅读吗？这个单一微计划把你所有的注意力都放在一个计划上，因此成功率相当高。\r\n\r\n### 多项微计划\r\n\r\n如果你渴望养成好几个习惯，或者不满足于一次培养一个，那么多项微计划就很适合你。\r\n\r\n把你的习惯变成“小得不可思议的一小步”\r\n\r\n当某件事听起来“小得不可思议”时，大脑会认为它毫无威胁。你在实践微习惯的过程中会掌握一项技能——如果感到抵触，那就找到有创意的方法让行动变得越来越小吧。\r\n\r\n### 如何培养每周微习惯\r\n\r\n我发现有些事情不适合每天做。我们可以用有创意的方法将每周习惯转变为每日目标。比如，如果你想每周开车去健身，就设定一个混合微习惯吧。\r\n\r\n### 第2步：挖掘每个微习惯的内在价值\r\n想知道习惯是否值得我们付出努力的最佳方法是先认清来源。最好的习惯直接源于你的生活观念。\r\n\r\n### 用“为什么钻头”找到来源\r\n\r\n列好习惯后，看看你为什么想要实现它们，但别在这一步就停止。再问问为什么，不断地问下去，直到形成循环和重复为止，因为这时候你已经找到了核心。\r\n\r\n### 第3步：明确习惯依据，将其纳入日程\r\n\r\n培养习惯的常见依据有两种，时间和行为方式。如果你打算根据时间来选择习惯，可能会说“我打算周一、周三和周五下午3点锻炼”。如果你打算根据行为方式来选择习惯，可能会说“我打算吃完最后一口午饭之后30分钟再去锻炼”。\r\n\r\n### 自由度高的非具体习惯\r\n\r\n非具体习惯指的是有多个行为依据的习惯。微习惯小到不可能失败，所以有没有依据无所谓。\r\n\r\n如果你有一个小到不可能失败而又没有依据的习惯，会怎样呢？你会发展出多个习惯依据。\r\n\r\n### 一些可供选择的依据：\r\n\r\n每天完成一次非具体微习惯行为。\r\n\r\n根据时间进行的微习惯行为可在下午3:00或晚上9:45等时间完成。\r\n\r\n根据行为方式进行的微习惯行为可在吃完午饭以后、开始工作之前、开车时、如厕后等时间完成。\r\n\r\n### 第4步：建立回报机制，以奖励提升成就感\r\n锻炼能获得意义重大的重要回报，如发达的腹肌、良好的感觉和健康的体魄，但你的第一次锻炼距离这些还远着呢。\r\n\r\n### 回报关联\r\n\r\n我们能做的是将行为与完全不相关的回报建立关联，一段时间过后，大脑就会把这个行为和回报联系起来，这就是我们想要的！\r\n\r\n### 回报策略\r\n\r\n我的经验法则是在此过程中要让自己感到快乐。快坚持不下去时，我就会给自己一点奖励，休息一下。\r\n\r\n回报对意志力的重建作用\r\n\r\n你可以通过各种类型的回报来恢复意志力，可能你会觉得这个建议匪夷所思。\r\n\r\n### 第5步：记录和追踪完成情况\r\n不管你选择什么策略，我建议你到睡前再检查自己是否成功。\r\n\r\n### 大日历(推荐)\r\n\r\n我就是用这个策略来追踪自己的微习惯进展的，用的是我房间墙上的一个巨大的日历。我把微习惯写在旁边的一个白板上，然后每天在日历上核对是否完成。保持微习惯几个月以后，给成功完成任务的一天打钩的感觉依然很棒！\r\n\r\n### 数字化追踪\r\n\r\n有些人愿意使用智能手机，虽然我现在更喜欢老式的方法，但智能手机的一些优点不容忽视。\r\n```\r\nIOS系统和安卓系统上追踪微习惯最方便的应用有：\r\nLift (iOS系统，免费)\r\nHabit Streak Plan (安卓系统，免费)\r\n台式电脑/笔记本电脑的解决方案：\r\n对台式电脑用户来说，我认为简单的习惯追踪方案里最好的就是Joe\'s Goals (joesgoals.com)。它确实很简单。\r\nLift.do 是Lift应用的电脑版网站。上面还有很多在线日历，你可以选用。\r\n我的朋友哈利 • 切还有一个目标/习惯解决网站，叫作Goals On Track (goalsontrack.com)。在我用过的所有应用或网站中，我最喜欢这个。\r\n```\r\n\r\n### 第6步：微量开始，超额完成\r\n\r\n我们明明可以设定更高的目标，为什么还要制定这么小的习惯呢？\r\n\r\n### 强化意志力的微习惯\r\n\r\n我们给自己制定意志力要求较低但是频率很高的任务。久而久之，像这样反复不断地强迫自己执行可实现的任务，我们的意志力就会变得更强大。这就叫练习。\r\n\r\n### 带来进步的微习惯\r\n\r\n如果一个行为从数量上看过于渺小，那它如何能给你实打实的成效呢？\r\n```\r\nA. 微习惯超额环节：看到自己采取行动比任何其他事都更激励人心，更能激发动力。你一旦开始，就会希望多完成一些。\r\nB. 微习惯安全网(培养实实在在的微习惯)：你不想成为那个每天写50字的人——你想让自己迅速变成每天能写出4000字的人，那就写吧，对微习惯来说，不存在上限。你可以把自己累垮，让自己疯狂工作。只要你能保证第二天仍能达到最低要求，就没有问题。\r\n```\r\n\r\n### 减轻意志力损耗的微习惯\r\n\r\n即使你的意志力已经耗尽，微习惯的任务要求是如此之低，你总能找到方法完成。\r\n\r\n### 第7步：服从计划安排，摆脱高期待值\r\n\r\n从潜意识层面看，超额完成目标后，大脑会设定一个新的期待值，它承载了你以前设定过的典型目标(你懂的，那些无效目标)带来的负担和压力。所以，一定要提醒自己，你每天的目标并没有改变，这一点极为重要。\r\n\r\n### 第8步：留意习惯养成的标志\r\n\r\n代表行为已成为习惯的信号有：\r\n\r\n没有抵触情绪：该行为似乎做起来容易，不做反而更难。\r\n\r\n身份：现在你认同该行为，而且可以信心十足地说“我常看书”或“我是个作家”。\r\n\r\n行动时无须考虑：你不需要做出执行的决定就能开始该行为。\r\n\r\n你不再担心了：刚开始时，你也许会担心自己漏掉一天或者早早放弃，可当行为变成习惯后，你知道你会一直做这件事，除非出现紧急情况。\r\n\r\n常态化：习惯是非情绪化的。\r\n\r\n它很无聊：好的习惯并不会让人兴奋，它们只是对你有好处而已。\r\n\r\n## 第7章 微习惯策略的八大规则\r\n\r\n事实上，如果你发现自己用微习惯很难取得进步，很可能是因为你违背了其中一条规则。\r\n\r\n### 1. 绝不要自欺欺人\r\n\r\n微习惯体系中有几种作弊方式。第一个也是最常见的一种是给自己制定一个微习惯，比如每天做1个俯卧撑，却偷偷要求自己完成不止1个俯卧撑。\r\n\r\n### 2. 满足每一个进步\r\n\r\n对小小的进步感到满意和标准低不是一回事。李小龙有一句名言能很好地总结这一点：“要满意，但别满足。”\r\n\r\n### 3. 经常回报自己，尤其在完成微习惯之后\r\n\r\n当你在完成一个微习惯后回报自己的时候——不管是用食物、出去痛快玩一夜还是对着镜子告诉自己你有多了不起——这种回报会激励你再次执行微习惯，它会通过这种方式奖励你。\r\n\r\n### 4. 保持头脑清醒\r\n\r\n冷静的头脑是建立习惯的最佳思维模式，因为它很稳定，而且可以预见。在不断取得进步的过程中，你可能会兴奋起来，但别让这种兴奋变成你实施行动的原动力。变得依赖动力或情绪正是许多个人成长计划最终失败的原因。\r\n\r\n### 5. 感到强烈抵触时，后退并缩小目标\r\n\r\n如果你的目标是“去健身房锻炼”，可以将要求缩小到“自己开车去健身房”。如果这招还不行，那你能做的就是打开衣橱。完成这个任务后，拿出健身时的服装穿好。如果你觉得这么做很傻，那就太棒了，因为如果这个任务听起来很傻，就意味着你的大脑已经同意这么做了。\r\n\r\n### 6. 提醒自己这件事很轻松\r\n\r\n当你面对自己的微任务并感到抵触时，你可能没有在想，它有多么轻松。\r\n忘记那些无法激发动力的经历吧，忘记轰轰烈烈的意志力大战吧。微习惯的门槛特别低，所以你可能再也不用体验失败了。\r\n\r\n### 7. 绝不要小看微步骤\r\n\r\n采取微步骤能让你持续控制大脑。如果你意志力较弱，微步骤有时是你前进的唯一途径，学会爱上它们，你就会看到不可思议的结果！\r\n\r\n### 8. 用多余精力超额完成任务，而不是制定更大目标\r\n\r\n如果你急于取得巨大进步，那就把精力投入超额完成任务中。大目标在纸面上看着漂亮，但只有行动才算数。目标渺小、结果丰硕的状态比反过来好多了。\r\n', '1', '1', '2019-01-11 11:11:00', '2019-01-13 17:29:09');
INSERT INTO `posts` VALUES ('14', '14', '0-14', '2', '《微习惯》 | 始于微，终必久', '《微习惯》 | 始于微，终必久', '大概是颈椎不好的原因，记忆力有点下降了。\r\n\r\n昨天读《微习惯》后，改变了我之前的背单词计划，由每天一百个，变成每小时完成5个，我觉得这会让我有动力很多。\r\n\r\n《微习惯》这本书里告诉我们，好习惯的养成，动力虽然重要，但意志力最重要，要让自己的意志力保持最好，每次就不可以把意志力耗光，总要留一点。\r\n\r\n所以如果你的目标是希望自己一个月瘦五斤，这样完全没问题，但是定目标就显得很宽泛，容易放弃和半途而废。\r\n\r\n如果你把目标具体化，就像作者说的那样，一天一个仰卧起坐。\r\n\r\n保证最小目标的完成，但可以超额完成，这就很厉害了。\r\n\r\n微习惯的意义就在于“微”，【你起初虽然微小，但终久必甚发达】这是我《圣经》里很喜欢的一句话，现在起更觉得充满意义。\r\n\r\n给自己下载了一个监督完成微习惯的App，每完成一个，就打卡，今天如约完成了早起的任务，接下来就开始准备背单词的任务。\r\n\r\n昨天试着背单词，基本上背完都忘记了。为自己的记忆力堪忧。不承认不行，虽然还不想称自己人到中年，但身体和大脑却在向自己证明这件事，只有以后更加注意饮食和健身，希望自己能保持好的精力。\r\n\r\n昨天有一个很强烈的念头：就算人生平庸，灵魂却要不凡。对于灵魂的喂养，就在自己时刻的所见所看所想里，这也需要自己不断的学习新知识，不断的培养自己的新的好习惯，一点点累积起来。昨天我才明白一件事，意志力是自己能否坚持的最终决定因素，在这一路的成长里，自己有许多的失去和放弃，其实想想，都少不了是意志力脆弱的原因，自己放弃了。关于这一点，幸好还有机会来弥补，相信我自己。\r\n\r\n早上做平板支撑一分钟，很累，一边做一边背主祷文，这真的给了我动力。在背主祷文的时候，我也在心里默默和自己说，真的要如主祷文上面说的那样：免我们的债，如同我们免了人的债。\r\n\r\n昨夜的睡眠比前几天好一些，还是有梦到自己讨厌的人，因为讨厌就会时常出现在梦里。既然自己选择了不一样的人生，从前的种种我总要学着释怀，让它过去，不然真正受煎熬的只能是自己。\r\n\r\n希望自己能更辽阔，更有爱，更温暖。\r\n\r\n日更坚持20天啦，读《微习惯》还纠正了我一个误区：以前说一个好习惯的养成需要21天，作者说这实际上是不准确的，一个好习惯的养成，平均时间是66天，有的还需要更长时间，所以好不容易有的好习惯，一定要一直坚持不放弃哦。\r\n\r\n《微习惯》这本书大概就是为意志力不够强大，但又很想努力一把，需要深度培养自控力的同学量身定做的，推荐大家去读啦！\r\n ', '1', '1', '2019-01-13 17:34:42', '2019-01-17 20:30:04');
INSERT INTO `posts` VALUES ('15', '13', '0', '39', '周一打卡（0114）', '微习惯打卡', '## 三篇文章\r\n\r\n1. 《微习惯》 | 始于微，终必久\r\n\r\n2. 十分钟读完《微习惯》\r\n\r\n3. 八个小步骤建立你的微习惯，最简单实用自我管理法则', '1', '1', '2019-01-13 17:40:41', '2019-01-13 17:40:41');
INSERT INTO `posts` VALUES ('16', '7', '0', '2', '什么是数据结构', '什么是数据结构，--来自维基百科 \r\n数据结构，直白地理解，就是研究数据的存储方式。\r\n数据结构是什么? 我认为，数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。', '在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。\r\n\r\n数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。\r\n\r\n大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。\r\n\r\n举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。\r\n\r\n数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。\r\n\r\n一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。\r\n\r\n不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。\r\n\r\n例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。\r\n\r\n正确的数据结构选择可以提高算法的效率（请参考算法效率）。\r\n\r\n在计算机程序设计的过程中，选择适当的数据结构是一项重要工作。许多大型系统的编写经验显示，程序设计的困难程度与最终成果的质量与表现，取决于是否选择了最适合的数据结构。\r\n\r\n系统架构的关键因素是数据结构而非算法的见解，导致了多种形式化的设计方法与编程语言的出现。\r\n\r\n绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于用户界面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类 (计算机科学)来达到这个目的。\r\n\r\n因为数据结构概念的普及，现代编程语言及其API中都包含了多种默认的数据结构，例如 C++ 标准模板库中的容器、Java集合框架以及微软的.NET Framework。\r\n\r\n常见的数据结构\r\n\r\n```\r\n数组（Array）\r\n栈（Stack）\r\n队列（Queue）\r\n链表（Linked List）\r\n树（Tree）\r\n图（Graph）\r\n堆（Heap）\r\n散列表（Hash）\r\n```', '1', '1', '2019-01-11 11:11:00', '2019-01-14 01:54:26');
INSERT INTO `posts` VALUES ('17', '7', '0', '2', '数据结构有哪些，常用数据结构详解', '数据结构有哪些，常用数据结构详解', '通过上节我们知道，数据结构是学习数据存储方式的一门学科，那么，数据存储方式有哪几种呢？\r\n\r\n本节将对数据结构的学习内容做一个简要的总结。\r\n\r\n数据结构大致包含以下几种存储结构：\r\n```\r\n线性表，还可细分为顺序表、链表、栈和队列；\r\n树结构，包括普通树，二叉树，线索二叉树等；\r\n图存储结构；\r\n```\r\n\r\n下面对各种数据结构做详细讲解。\r\n\r\n### 线性表\r\n\r\n线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。\r\n\r\n手拉手的小朋友\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif)\r\n\r\n\r\n例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。\r\n\r\n线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。\r\n\r\n### 顺序表\r\n\r\n顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif)\r\n\r\n#### 顺序表结构\r\n\r\n```\r\n由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。\r\n```\r\n\r\n### 链表\r\n我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图所示。\r\n\r\n链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。\r\n\r\n为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图所示：\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif)\r\n\r\n### 栈和队列\r\n栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。\r\n\r\n栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。\r\n\r\n栈结构示意图\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif)\r\n\r\n栈结构 如上图所示\r\n\r\n像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。\r\n\r\n队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。\r\n\r\n队列结构示意图\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif)\r\n \r\n队列结构 如上图所示\r\n\r\n队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。\r\n\r\n## 树存储结构\r\n\r\n树存储结构适合存储具有“一对多”关系的数据。\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif)\r\n\r\n如上图所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。\r\n \r\n## 图存储结构\r\n图存储结构适合存储具有“多对多”关系的数据。\r\n\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif)\r\n\r\n如上图所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。', '1', '1', '2019-01-14 02:12:04', '2019-01-14 02:12:04');
INSERT INTO `posts` VALUES ('18', '7', '0', '2', '算法时间复杂度和空间复杂度的计算', '算法时间复杂度和空间复杂度的计算', '算法，即解决问题的方法。\r\n\r\n同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。\r\n\r\n就比如要拧一个螺母，使用扳手还是钳子是有区别的，虽然使用钳子也能拧螺母，但是没有扳手好用。\r\n\r\n“条条大路通罗马”，解决问题的算法有多种，这就需要判断哪个算法“更好”。\r\n\r\n## 算法VS程序\r\n\r\n很多人误以为程序就是算法，其实不然：\r\n\r\n算法是解决某个问题的想法、思路；\r\n\r\n而程序是在心中有算法的前提下编写出来的可以运行的代码。\r\n\r\n例如，要解决依次输出一维数组中的数据元素的值的问题，首先想到的是使用循环结构（ for 或者 while ），在有这个算法的基础上，开始编写程序。\r\n\r\n所以，算法相当于是程序的雏形。当解决问题时，首先心中要有解决问题的算法，围绕算法编写出程序代码。\r\n\r\n有算法一定能解决问题吗？\r\n\r\n对于一个问题，想出解决的算法，不一定就能解决这个问题。\r\n\r\n例如拧螺母，扳手相对于钳子来说更好使（选择算法的过程），但是在拧的过程（编写程序的过程）中发现螺母生锈拧不动，这时就需要另想办法。\r\n\r\n为了避免这种情况的发生，要充分全面地思考问题，尽可能地考虑到所有地可能情况，慎重选择算法（需要在实践中不断地积累经验）。\r\n\r\n## “好”算法的标准\r\n\r\n对于一个问题的算法来说，之所以称之为算法，首先它必须能够解决这个问题（称为准确性）。其次，通过这个算法编写的程序要求在任何情况下不能崩溃（称为健壮性）。\r\n\r\n如果准确性和健壮性都满足，接下来，就要考虑最重要的一点：通过算法编写的程序，运行的效率怎么样。\r\n\r\n## 运行效率体现在两方面：\r\n\r\n### 算法的运行时间。（称为“时间复杂度”）\r\n\r\n### 运行算法所需的内存空间大小。（称为“空间复杂度”）\r\n\r\n好算法的标准就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。\r\n\r\n调查表明，人们对于软件或者 APP 的运行效率有极高的要求，例如对于网页打开的忍耐极限是 6 秒甚至更短，如果你设计的网页打开的时间超过 6 秒，多数人会在 4 秒甚至 3 秒的时候毫不犹豫地关掉而去浏览其他网页。\r\n\r\n在这个大背景下，一个好的“算法”更注重的是时间复杂度，而空间复杂度只要在一个合理的范围内就可以。\r\n\r\n## 时间复杂度的计算\r\n\r\n计算一个算法的时间复杂度，不可能把所有的算法都编写出实际的程序出来让计算机跑，这样会做很多无用功，效率太低。实际采用的方法是估算算法的时间复杂度。\r\n\r\n在学习C语言的时候讲过，程序由三种结构构成：\r\n```\r\n顺序结构、分支结构和循环结构。\r\n```\r\n顺序结构和分支结构中的每段代码只运行一次；\r\n\r\n循环结构中的代码的运行时间要看循环的次数。\r\n\r\n由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。\r\n\r\n所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数（称为“频度”）。\r\n\r\n次数越少，算法的时间复杂度越低。\r\n\r\n例如：\r\n```\r\na) ++x; s=0;\r\nb) for (int i=1; i<=n; i++) { ++x; s+=x; }\r\nc) for (int i=1; i<=n; i++) { for (int j=1; i<=n; j++) { ++x; s+=x; } }\r\n```\r\n\r\n上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。\r\n\r\n时间复杂度的表示\r\n\r\n算法的时间复杂度的表示方式为：\r\n\r\nO(频度)\r\n\r\n这种表示方式称为大“O”记法。\r\n\r\n注意，是大写的字母O，不是数字0。\r\n\r\n对于上边的例子而言，a 的时间复杂度为O(1)，b 的时间复杂度为O(n)，c 的时间复杂度为为O(n2)。\r\n\r\n如果a、b、c组成一段程序，那么算法的时间复杂度为O(n2+n+1)。但这么表示是不对的，还需要对n2+n+1进行简化。\r\n\r\n简化的过程总结为3步：\r\n\r\n去掉运行时间中的所有加法常数。（例如 n2+n+1，直接变为 n2+n）\r\n\r\n只保留最高项。（n2+n 变成 n2）\r\n\r\n如果最高项存在但是系数不是1，去掉系数。（n2 系数为 1）\r\n\r\n所以，最终a、b和c合并而成的代码的时间复杂度为O(n2)。\r\n\r\n#### 常用的时间复杂度的排序\r\n\r\n列举了几种常见的算法时间复杂度的比较（又小到大）：\r\n```\r\nO(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n2)平方阶 < O(n3)(立方阶) < O(2n) (指数阶)\r\n```\r\n\r\n\r\n拿时间换空间，用空间换时间\r\n\r\n算法的时间复杂度和空间复杂度是可以相互转化的。\r\n\r\n谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。\r\n\r\n算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。\r\n\r\n如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。', '1', '1', '2019-01-14 02:18:35', '2019-01-14 02:18:35');
INSERT INTO `posts` VALUES ('19', '7', '0', '2', '数据的逻辑结构和存储结构（物理结构）详解', '数据的逻辑结构和存储结构（物理结构）详解', '《数据结构有哪些》一节讲到，数据的存储方式可分为线性表、树和图三种存储结构，而每种存储结构又可细分为顺序存储结构和链式存储结构。\r\n\r\n数据存储方式如此之多，针对不同类型的数据选择合适的存储方式是至关重要的。\r\n\r\n那么，到底如何选择呢？\r\n\r\n数据存储结构的选择取决于两方面，即数据的逻辑结构和存储结构（又称物理结构）。\r\n\r\n## 逻辑结构\r\n\r\n数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。\r\n\r\n家庭成员关系图\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif)\r\n图 1 家庭成员关系图\r\n\r\n例如，图 1 显示是一张家庭的成员关系图，从图中可以看到，张平、张华和张群是兄弟，他们的父亲是张亮，其中张平有两个儿子，分别是张晶和张磊。\r\n\r\n以上所说，父子、兄弟等这些关系都指的是数据间的逻辑关系，假设我们要存储这样一张家庭成员关系图，不仅要存储张平、张华等数据，还要存储它们之间的关系，两者缺一不可。\r\n\r\n```\r\n一组数据成功存储到计算机的衡量标准是要能将其完整的复原。例如图 1 所示的成员关系图，如果所存储的数据能将此成员关系图彻底复原，则说明数据存储成功。\r\n```\r\n\r\n“多对多”关系示意图\r\n![avatar](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif)\r\n图 2 “多对多”关系示意图\r\n\r\n数据之间的逻辑关系可细分为三类，“一对一”、“一对多”和“多对多”：\r\n```\r\n“一对一”：类似集合 {1,2,3,...,n} 这类的数据，每个数据的左侧有且仅有一个数据与其相邻（除 1 外）；同样，每个数据的右侧也只有一个数据与其相邻（除 n 外），所有的数据都是如此，就说数据之间是“一对一”的逻辑关系；\r\n\r\n“一对多”：图 1 中的数据就属于“一对多”，因为对于张平来说，有且仅有一个父亲（张亮），但是有 2（多）个孩子；\r\n\r\n“多对多”：拿图 2 来说，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，对于V1、V2、V3和V4来说，它们之间就是“多对多”的关系；\r\n```\r\n\r\n通过学习数据结构，我们可以学到 3 种存储结构分别存储这 3 类逻辑关系的数据，换句话说：\r\n```\r\n线性表用于存储具有“一对一”逻辑关系的数据；\r\n\r\n树结构用于存储具有“一对多”关系的数据；\r\n\r\n图结构用于存储具有“多对多”关系的数据；\r\n```\r\n由此，我们可以通过分析数据之间的逻辑关系来决定使用哪种存储结构，但具体使用顺序存储还是链式存储，还要通过数据的物理结构来决定。\r\n\r\n## 存储结构（物理结构）\r\n数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。假设要存储大小为 10G 的数据，则集中存放就如图 3a) 所示，分散存放就如图 3b）所示。\r\n![avatar](http://data.biancheng.net/uploads/allimg/181119/1-1Q119202U0V9.gif)\r\n数据的物理存储方式\r\n图 3 数据的物理存储方式\r\n\r\n如果选择集中存储，就使用顺序存储结构；\r\n\r\n反之，就使用链式存储。\r\n\r\n至于如何选择，主要取决于存储设备的状态以及数据的用途。\r\n\r\n我们知道，集中存储（底层实现使用的是数组）需要使用一大块连续的物理空间，假设要存储大小为 1G 的数据，若存储设备上没有整块大小超过 1G 的空间，就无法使用顺序存储，此时就要选择链式存储，因为链式存储是随机存储数据，占用的都是存储设备中比较小的存储空间，因此有一定几率可以存储成功。\r\n\r\n并且，数据的用途不同，选择的存储结构也不同。\r\n\r\n将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。\r\n\r\n因此，如果后期需要对数据进行大量的检索（遍历），就选择集中存储；\r\n\r\n反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。\r\n\r\n至于为什么，我们会在详解两种存储结构时告知大家。', '1', '1', '2019-01-14 02:26:59', '2019-01-14 02:26:59');
INSERT INTO `posts` VALUES ('20', '7', '0', '2', '数据结构和算法的关系和区别', '数据结构和算法的关系和区别', '由于大量数据结构教程中都将数据结构的知识和算法掺杂起来讲，使很多初学者认为数据结构就是在讲算法，这样理解是不准确的。\r\n\r\n数据结构和算法之间完全是两个相互独立的学科，如果非说它们有关系，那也只是互利共赢、“1+1>2”的关系。\r\n\r\n最明显的例子，如果你认为数据结构是在讲算法，那么大学我们还学《算法导论》，后者几乎囊括了前者使用的全部算法，有什么必要同时开设这两门课程呢？\r\n\r\n我们还可以从分析问题的角度去理清数据结构和算法之间的关系。通常，每个问题的解决都经过以下两个步骤：\r\n```\r\n分析问题，从问题中提取出有价值的数据，将其存储；\r\n对存储的数据进行处理，最终得出问题的答案；\r\n```\r\n\r\n数据结构负责解决第一个问题，即数据的存储问题。\r\n通过前面的学习我们知道，针对数据不同的逻辑结构和物理结构，可以选出最优的数据存储结构来存储数据。\r\n\r\n而剩下的第二个问题，属于算法的职责范围。\r\n\r\n算法，从表面意思来理解，即解决问题的方法。\r\n\r\n我们知道，评价一个算法的好坏，取决于在解决相同问题的前提下，哪种算法的效率最高，而这里的效率指的就是处理数据、分析数据的能力。\r\n\r\n因此我们得出这样的结论，数据结构用于解决数据存储问题，而算法用于处理和分析数据，它们是完全不同的两类学科。\r\n\r\n也正因为如此，你可以认为数据结构和算法存在“互利共赢、1+1>2”的关系。\r\n\r\n在解决问题的过程中，数据结构要配合算法选择最优的存储结构来存储数据，而算法也要结合数据存储的特点，用最优的策略来分析并处理数据，由此可以最高效地解决问题。\r\n\r\n顺序表存储数据示意图\r\n![avatar](http://data.biancheng.net/uploads/allimg/181120/2-1Q1200R14U30.gif)\r\n\r\n\r\n图 1 顺序表存储数据示意图\r\n\r\n例如，有这样一个问题，计算“1+2+3+4+5”的值。\r\n\r\n这个问题我们可以这样来分析：\r\n\r\n计算 1、2、3、4 和 5 的和，首先要选择一种数据存储方式将它们存储起来，通过前面的学习我们知道，数据之间具有“一对一”的逻辑关系，最适合用线性表来存储。\r\n\r\n结合算法的实现，我们选择顺序表来存储数据（而不是链表），如图 1 所示；\r\n接下来，我们选择算法。由于数据集中存放，因此我们可以设计这样一个算法，使用一个初始值为 0 的变量 num 依次同存储的数据做“加”运算，最后得到的新 num 值就是最终结果。\r\n\r\n```\r\n选择顺序表而不是链表的原因，是顺序表遍历数据比链表更高效。后续讲顺序表时会做详细介绍。\r\n```', '1', '1', '2019-01-14 02:33:06', '2019-01-14 02:33:06');
INSERT INTO `posts` VALUES ('21', '6', '0', '2', 'php自带排序函数sort()和用自己用php实现的快速排序算法，速度比较', 'php自带排序函数sort()和用自己用php实现的快速排序算法，速度比较', '我今天特地试验了一下两者的性能\r\n\r\nphp自带的排序函数  100000的数据 排序 平均耗时0.068s\r\n```\r\nfor ($i = 0; $i<100000;$i++){\r\n  $arr[] = rand(0,10000);\r\n}\r\n$t1 = microtime(true); \r\nsort($arr); \r\n$t2 = microtime(true);\r\necho \"php自带排序sort()耗时：\".($t2-$t1); \r\n```\r\n\r\n自己写的快速排序 平均耗时1.0s\r\n```\r\n$t1 = microtime(true);\r\n$returnAr = quickSort($arr);\r\n$t2 = microtime(true);\r\necho \"快速排序耗时：\".($t2-$t1); \r\n//快速排序\r\nfunction quickSort($arr) {				\r\n    $length = count($arr);//先判断是否需要继续进行 \r\n    if($length <= 1) {\r\n      return $arr;\r\n    }\r\n    $base_num = $arr[0];//选择第一个元素作为基准\r\n    $left_array = array(); \r\n    $right_array = array(); \r\n    for($i=1; $i<$length; $i++) {	\r\n      if($base_num > $arr[$i]) {\r\n        $left_array[] = $arr[$i];\r\n      } else {\r\n        $right_array[] = $arr[$i];\r\n      }\r\n    }\r\n    $left_array = quickSort($left_array);\r\n    $right_array = quickSort($right_array);\r\n    return array_merge($left_array, array($base_num), $right_array);\r\n}\r\n```', '1', '1', '2019-01-14 02:46:30', '2019-01-14 02:46:30');
INSERT INTO `posts` VALUES ('22', '6', '0', '2', 'php 冒泡排序的两种思路以及优化', 'php 冒泡排序的两种思路以及优化', 'php冒泡排序，两种思路，时间复杂度都是O(n^2)，当然最优的时间复杂度就是O(n)，以下说的都是正序排列(倒序的话，把内层循环的大于号换成小于号就好了)\r\n\r\n## 第一种冒泡排序\r\n\r\n思路就是把第一个数跟所有的数比较，如果碰到比第一个数还小的数字，就把他俩位置交换下，然后把交换后的数字继续往后比较...\r\n\r\n这样第一轮交换能得出什么呢，就是第一轮交换完，数组的第一个位置，一定是最小的数\r\n\r\n循环体内，每次$j = $i + 1, 因为外层每循环一次已经把最小的数压到数字头部了, 没必要从头开始比较了\r\n\r\n```\r\n$numbers = array(-2, 5, 3, 1, -3, -4);\r\nfor ($i=0;$i<count($numbers);$i++) {\r\n    for ($j=$i+1;$j<count($numbers);$j++) {\r\n        if ($numbers[$i] > $numbers[$j]) {\r\n            $tmp         = $numbers[$i];\r\n            $numbers[$i] = $numbers[$j];\r\n            $numbers[$j] = $tmp;\r\n        }\r\n    }\r\n    // var_dump($numbers);\r\n}\r\nvar_dump($numbers);exit;\r\n```\r\n\r\n第一轮交换的过程：拿数组的第一位-2跟5比，发现没有我小，跳过，拿-2跟3比，发小没有我小跳过...\r\n\r\n拿-2跟-3比的时候，发小比我还小，两个交换下位置，下次循环的时候数组第一位已经发生了变化，是-3。嗯，仔细想想\r\n\r\n然后循环还没完，继续拿数组的第一位（-3）,跟数组最后一位-4比较，又交换下位置...\r\n\r\n结果：[-4, 5, 3, 1, -2, -3] \r\n\r\n第二轮循环时候拿5跟数组后面的开始比较，没必要跟前面的比了，因为经过上一轮的比较，第一位肯定是最小的...\r\n\r\n## 第二种冒泡排序\r\n\r\n思路就是一组一组数字(相邻的两个数)比较，如果大于后面的数字就发生交换，这样比较完的结果就是会把最大的数移动到最后的位置\r\n\r\n```\r\n$numbers = array(-2, 5, 3, 1, -3, -4);\r\nfor ($i = 0; $i < count($numbers); $i++) {\r\n    for ($j = 0; $j < count($numbers) - $i - 1; $j++) {\r\n        if ($numbers[$j] > $numbers[$j + 1]) {\r\n            $temp = $numbers[$j];\r\n            $numbers[$j] = $numbers[$j + 1];\r\n            $numbers[$j + 1] = $temp;\r\n        }\r\n    }\r\n    var_dump($numbers);\r\n}\r\n```\r\n\r\n第一轮交换完过程就是: -2不大于5不交换，5大于3交换，5大于1交换，5大于-3交换，5大约-4交换....\r\n\r\n结果: [-2, 3, 1, -3, -4，5]\r\n...\r\n\r\n第二轮交换的时候，注意条件$j < count($numbers) - $i - 1; 已经不跟最后一个比较了，因为你懂的...\r\n\r\n## 关于优化\r\n如果数组是: [5,1,2,3,4] 套用我们第二种思路的话, 是不是我们第一轮循环完(结果是[1,2,3,4,5]), 就可以终止循环了.\r\n\r\n加个变量，如果里面没有发生交换，就意味着数组目前就是有序的，可以退出循环了\r\n\r\n```\r\n$numbers = [5,1,2,3,4];\r\nfor ($i = 0; $i < count($numbers); $i++) {\r\n    $flag = 1;\r\n    for ($j = 0; $j < count($numbers) - $i - 1; $j++) {\r\n        if ($numbers[$j] > $numbers[$j + 1]) {\r\n            $flag = 0;\r\n            $temp = $numbers[$j];\r\n            $numbers[$j] = $numbers[$j + 1];\r\n            $numbers[$j + 1] = $temp;\r\n        }\r\n    }\r\n    if($flag) break;\r\n}\r\nvar_dump($numbers);exit;\r\n```', '1', '1', '2019-01-14 02:56:39', '2019-01-14 02:56:39');
INSERT INTO `posts` VALUES ('23', '6', '0', '2', '算法复杂度分为时间复杂度和空间复杂度', '算法复杂度分为时间复杂度和空间复杂度', '算法复杂度分为时间复杂度和空间复杂度。\r\n\r\n其作用： \r\n\r\n时间复杂度是指执行算法所需要的计算工作量；\r\n \r\n而空间复杂度是指执行这个算法所需要的内存空间。 \r\n\r\n（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。\r\n\r\n简单来说，时间复杂度指的是语句执行次数，空间复杂度指的是算法所占的存储空间\r\n\r\n## 时间复杂度 \r\n\r\n计算时间复杂度的方法：\r\n\r\n用常数1代替运行时间中的所有加法常数\r\n\r\n修改后的运行次数函数中，只保留最高阶项\r\n\r\n去除最高阶项的系数\r\n\r\n按数量级递增排列，常见的时间复杂度有：\r\n \r\n常数阶O(1),对数阶O(log2n),线性阶O(n), \r\n线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),…， \r\nk次方阶O(n^k),指数阶O(2^n)。 \r\n\r\n随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\r\n\r\n举个栗子:\r\n\r\n```\r\nsum = n*(n+1)/2;        //时间复杂度O(1)\r\n \r\n\r\nfor(int i = 0; i < n; i++){\r\n    printf(\"%d \",i);\r\n}                       \r\n//时间复杂度O(n)\r\n \r\n\r\nfor(int i = 0; i < n; i++){\r\n    for(int j = 0; j < n; j++){\r\n        printf(\"%d \",i);\r\n    }\r\n}               \r\n//时间复杂度O(n^2)\r\n \r\n\r\nfor(int i = 0; i < n; i++){\r\n    for(int j = i; j < n; j++){\r\n        printf(\"%d \",i);\r\n    }\r\n}   \r\n//运行次数为(1+n)*n/2\r\n//时间复杂度O(n^2)\r\nint i = 0, n = 100;\r\nwhile(i < n){\r\n    i = i * 2;\r\n}\r\n//设执行次数为x. 2^x = n 即x = log2n\r\n//时间复杂度O(log2n)\r\n```\r\n\r\n最坏时间复杂度和平均时间复杂度 \r\n\r\n　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 \r\n\r\n　这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。\r\n \r\n　平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。设每种情况的出现的概率为pi,平均时间复杂度则为sum(pi*f(n)) \r\n　\r\n\r\n常用排序算法的时间复杂度\r\n\r\n---|最差时间分析 | 平均时间复杂度 | 稳定度   |  空间复杂度   \r\n---|---|---|---|---\r\n冒泡排序  |  O(n^2) |  O(n^2)  |     稳定   |     O(1)  \r\n快速排序  |  O(n^2) |  O(n*log2n) | 不稳定 | O(log2n)~O(n)     \r\n选择排序  |  O(n^2) |  O(n^2)      | 稳定    |  O(1)    \r\n二叉树排序 | O(n^2)  | O(n*log2n)   | 不稳定   |  O(n)     \r\n插入排序  |  O(n^2) |  O(n^2)      | 稳定    |  O(1)    \r\n堆排序    | O(n*log2n) | O(n*log2n)  | 不稳定   |  O(1)    \r\n希尔排序  |  O     |   O        |  不稳定  |   O(1)\r\n\r\n\r\n## 空间复杂度\r\n \r\n空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。\r\n\r\n对于一个算法来说，空间复杂度和时间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。\r\n\r\n有时我们可以用空间来换取时间以达到目的。', '1', '1', '2019-01-11 11:11:00', '2019-01-14 03:23:05');
INSERT INTO `posts` VALUES ('24', '13', '0', '2', '周一打卡（0114）-1', '微习惯打卡', '## 五篇文章\r\n \r\n1. 什么是数据结构\r\n\r\n2. 数据结构有哪些，常用数据结构详解\r\n\r\n3. 算法时间复杂度和空间复杂度的计算\r\n\r\n4. 数据的逻辑结构和存储结构（物理结构）详解\r\n\r\n5. 数据结构和算法的关系和区别', '1', '1', '2019-01-11 11:11:00', '2019-01-14 03:29:59');
INSERT INTO `posts` VALUES ('25', '3', '0', '2', '超文本传输协议', '维基百科，自由的百科全书\r\n（重定向自Http协议）', '## 互联网协议套组\r\n\r\n### 应用层\r\n\r\nBGP DHCP DNS FTP HTTP IMAP LDAP MGCP NNTP NTP POP ONC/RPC RTP RTSP RIP SIP SMTP SNMP SSH Telnet TLS／SSL XMPP 更多...\r\n\r\n### 传输层\r\n\r\nTCP UDP DCCP SCTP RSVP 更多...\r\n\r\n### 网络层\r\n\r\nIP IPv4 IPv6 ICMP ICMPv6 ECN IGMP OSPF IPsec 更多...\r\n\r\n### 链接层\r\n\r\nARP NDP Tunnels L2TP PPP MAC Ethernet DSL ISDN FDDI 更多...\r\n\r\n```\r\nHTTP\r\nHTTP版本\r\nHTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2\r\nHTTP请求方法\r\nOPTIONS GET HEAD POST PUT DELETE TRACE CONNECT PATCH\r\n报文主体\r\n头字段\r\nCookie ETag Location HTTP referer DNT X-Forwarded-For\r\n状态码\r\n301 Moved Permanently 302 Found 303 See Other 307 Temporary Redirect 403 Forbidden 404 Not Found 451 Unavailable For Legal Reasons\r\n其它相关主题\r\n持久 压缩 HTTPS 分块传输编码\r\n```\r\n\r\n \r\n超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。\r\n\r\nHTTP是万维网的数据通信的基础。\r\n\r\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\r\n\r\n通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。\r\n\r\nHTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。\r\n\r\n2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论[2]，于2015年2月17日被批准。[3] HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。[4]\r\n\r\n```\r\n目录\r\n1	协议概述\r\n2	请求方法\r\n2.1	安全方法\r\n2.2	副作用\r\n3	版本\r\n3.1	HTTP/0.9\r\n3.2	HTTP/1.0\r\n3.3	HTTP/1.1\r\n3.4	HTTP/2\r\n4	状态码\r\n5	持续连线\r\n6	协议例子\r\n6.1	请求信息\r\n6.2	客户端请求\r\n6.3	服务器应答\r\n7	类似协议\r\n8	参见\r\n9	参考\r\n10	外部链接\r\n```\r\n\r\n## 协议概述\r\n\r\n在网页浏览器的地址栏上显示HTTP网络协议的插图\r\n\r\nHTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。\r\n\r\n通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。\r\n\r\n我们称这个客户端为用户代理程序（user agent）。\r\n\r\n应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。\r\n\r\n在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。\r\n\r\n尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。\r\n\r\n事实上，HTTP可以在任何互联网协议上，或其他网络上实现。\r\n\r\nHTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。\r\n\r\n因此也就是其在TCP/IP协议族使用TCP作为其传输层。\r\n\r\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。\r\n\r\nHTTP服务器则在那个端口监听客户端的请求\r\n\r\n。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\r\n\r\n## 请求方法\r\n\r\nHTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：\r\n```\r\nGET\r\n向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法\r\nHEAD\r\n与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\r\nPOST\r\n向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\r\nPUT\r\n向指定资源位置上传其最新内容。\r\nDELETE\r\n请求服务器删除Request-URI所标识的资源。\r\nTRACE\r\n回显服务器收到的请求，主要用于测试或诊断。\r\nOPTIONS\r\n这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用\'*\'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\r\nCONNECT\r\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\r\n方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。\r\n\r\nHTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如：\r\n\r\nPATCH（由 RFC 5789 指定的方法）\r\n用于将局部修改应用到资源。\r\n```\r\n\r\n## 安全方法\r\n\r\n对于GET和HEAD方法而言，除了进行获取资源信息外，这些请求不应当再有其他意义。\r\n\r\n也就是说，这些方法应当被认为是“安全的”。 \r\n\r\n客户端可能会使用其他“非安全”方法，例如POST，PUT及DELETE，应该以特殊的方式（通常是按钮而不是超链接）告知客户可能的后果（例如一个按钮控制的资金交易），或请求的操作可能是不安全的（例如某个文件将被上传或删除）。\r\n\r\n但是，不能想当然地认为服务器在处理某个GET请求时不会产生任何副作用。事实上，很多动态资源会把这作为其特性。\r\n\r\n这里重要的区别在于用户并没有请求这一副作用，因此不应由用户为这些副作用承担责任。\r\n\r\n## 副作用\r\n假如在不考虑诸如错误或者过期等问题的情况下，若干次请求的副作用与单次请求相同或者根本没有副作用，那么这些请求方法就能够被视作“幂等(idempotence)”的。\r\n\r\nGET，HEAD，PUT和DELETE方法都有这样的幂等属性，同样由于根据协议，OPTIONS，TRACE都不应有副作用，因此也理所当然也是幂等的。\r\n\r\n假如某个由若干个请求做成的请求序列产生的结果在重复执行这个请求序列或者其中任何一个或多个请求后仍没有发生变化，则这个请求序列便是“幂等”的。\r\n\r\n但是，可能出现若干个请求做成的请求序列是“非幂等”的，即使这个请求序列中所有执行的请求方法都是幂等的。\r\n\r\n例如，这个请求序列的结果依赖于某个会在下次执行这个序列的过程中被修改的变量。\r\n\r\n## 版本\r\n超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。\r\n\r\n在 RFC 2145 中描述了HTTP版本号的用法。\r\n\r\n客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。\r\n \r\n### HTTP/0.9\r\n\r\n已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。\r\n\r\n### HTTP/1.0\r\n\r\n这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。\r\n\r\n### HTTP/1.1\r\n\r\n持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。\r\n\r\nHTTP/1.1相较于HTTP/1.0协议的区别主要体现在：\r\n\r\n```\r\n缓存处理\r\n带宽优化及网络连接的使用\r\n错误通知的管理\r\n消息在网络中的发送\r\n互联网地址的维护\r\n安全性及完整性\r\n\r\n```\r\n\r\n###  HTTP/2\r\n\r\n主条目：HTTP/2\r\n\r\n当前版本，于2015年5月作为互联网标准正式发布。[5]\r\n\r\n## 状态码\r\n\r\n参见：HTTP状态码\r\n\r\n所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。\r\n\r\n状态代码的第一个数字代表当前响应的类型：\r\n```\r\n1xx消息——请求已被服务器接收，继续处理\r\n2xx成功——请求已成功被服务器接收、理解、并接受\r\n3xx重定向——需要后续操作才能完成这一请求\r\n4xx请求错误——请求含有词法错误或者无法被执行\r\n5xx服务器错误——服务器在处理某个正确请求时发生错误\r\n```\r\n\r\n虽然 RFC 2616 中已经推荐了描述状态的短语，例如\"200 OK\"，\"404 Not Found\"，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。\r\n\r\n### 持续连线\r\n\r\n使用多个连接和使用持久链接的对比\r\n\r\n主条目：HTTP持久连接\r\n\r\n在HTTP 0.9和1.0中，TCP连线在每一次请求/回应对之后关闭。\r\n\r\n在HTTP 1.1中，引入了保持连线的机制，一个连接可以重复在多个请求/回应使用。\r\n\r\n持续连线的方式可以大大减少等待时间，因为在发出第一个请求后，双方不需要重新运行TCP握手程序。\r\n\r\nHTTP 1.1还使改进了HTTP 1.0的带宽。 \r\n\r\n例如，HTTP 1.1引入了分块传输编码，以允许传递内容可以在持续连在线被流传输而不必使用到缓冲器。\r\n\r\nHTTP管道允许客户端在收到每个回应之前发送多个请求，进一步减少用户感受到的滞后时间。\r\n\r\n协议的另一个补充是字节服务，允许客户端请求资源的某一部分，服务器仅回应某资源的指明部分。\r\n\r\n### 协议例子\r\n下面是一个HTTP客户端与服务器之间会话的例子，运行于www.google.com，端口80\r\n\r\n### 请求信息\r\n发出的请求信息（message request）包括以下几个:\r\n\r\n请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）\r\n请求头（例如Accept-Language: en）\r\n空行\r\n其他消息体\r\n请求行和标题必须以<CR><LF>作为结尾。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。\r\n\r\n### 客户端请求\r\n```\r\nGET / HTTP/1.1\r\nHost: www.google.com\r\n```\r\n（末尾有一个空行。第一行指定方法、资源路径、协议版本；第二行是在1.1版里必带的一个header作用指定主机）\r\n\r\n### 服务器应答\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Length: 3059\r\nServer: GWS/2.0\r\nDate: Sat, 11 Jan 2003 02:44:04 GMT\r\nContent-Type: text/html\r\nCache-control: private\r\nSet-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy\r\nX9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com\r\nConnection: keep-alive\r\n```\r\n（紧跟着一个空行，并且由HTML格式的文本组成了Google的主页）\r\n\r\n在HTTP1.0，单一TCP连接内仅执行一个“客户端发送请求—服务器发送应答”周期，之后释放TCP连接。\r\n\r\n在HTTP1.1优化支持持续活跃连接：客户端连续多次发送请求、接收应答；\r\n\r\n批量多请求时，同一TCP连接在活跃（Keep-Live）间期内复用，避免重复TCP初始握手活动，减少网络负荷和响应周期。\r\n\r\n此外支持应答到达前继续发送请求（通常是两个），称为“流线化”（stream）。\r\n\r\n## 类似协议\r\nGopher是1990年代早期被HTTP取代的内容传递协议。SPDY是Google开发的HTTP的替代方案，它被新版本的HTTP协议HTTP/2所取代。', '1', '1', '2019-01-14 03:48:16', '2019-01-14 03:48:16');
INSERT INTO `posts` VALUES ('26', '3', '0', '2', 'PHP基础篇 - HTTP协议', 'PHP基础篇 - HTTP协议', '\r\nHTTP协议状态码\r\n\r\n五类响应： 1XX 2XX 3XX 4XX 5XX\r\n```\r\n1XX\r\nInformational\r\n信息性状态码，表示接受的请求正在处理\r\n2XX\r\nSuccess\r\n成功状态码，表示请求正常处理完毕\r\n3XX\r\nRedirection\r\n重定向状态码，表示需要客户端需要进行附加操作\r\n4XX\r\nClient Error\r\n客户端错误状态码，表示服务器无法处理请求\r\n5XX\r\nServer Error\r\n服务器错误状态码，表示服务器处理请求出错\r\n```\r\n\r\n常见状态码\r\n```\r\n200 请求被成功处理，服务器会根据不同的请求方法返回结果\r\n204 该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体\r\n206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求\r\n301 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。\r\n\r\n302 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。\r\n\r\n303 该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源\r\n304 该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况\r\n307 临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址\r\n\r\n400 表示该请求报文中存在语法错误，导致服务器无法理解该请求\r\n401 该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息\r\n403 该状态码表明对请求资源的访问被服务器拒绝了\r\n404 该状态码表明服务器上无法找到指定的资源\r\n500 该状态码表明服务器端在执行请求时发生了错误。\r\n503 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\r\n```\r\n----------------------------------------------------------------------------------------------------------------------------\r\nOSI七层模型\r\n```\r\n物理层 建立、维护、断开物理连接\r\n数据链路层 建立逻辑链接、进行硬件地址寻址、差错校验等功能\r\n网络层 进行逻辑地址寻址，实现不同网络之间的路径选择\r\n传输层	定义传输数据的协议端口号，以及流控和差错校验\r\n协议有:TCP UDP，数据包一旦离开网卡即进入网络传输层\r\n会话层 建立、管理、终止会话\r\n表示层	数据的表示、安全、压缩\r\n应用层	网络服务与最终用户的一个接口\r\n协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP\r\n``` \r\n\r\n![avatar](/public/img/posts/http.jpg)\r\n\r\n## HTTP协议的工作特点和工作原理\r\n\r\n工作特点：\r\n```\r\n   1. 基于B/S模式\r\n\r\n   2. 通信开销小、简单快速、传输成本低\r\n\r\n   3. 使用灵活，可使用超文本传输协议\r\n\r\n   4. 节省传输时间\r\n\r\n   5. 无状态\r\n```\r\n工作原理：\r\n```\r\n客户端发送请求给服务器，\r\n创建一个TCP连接，指定端口号，默认80，\r\n连接到服务器，服务器监听浏览器请求，\r\n一旦监听到客户端请求，分析请求类型后，\r\n服务器回想客户端返回状态信息和数据内容 \r\n```', '1', '1', '2019-01-14 03:57:06', '2019-01-14 03:57:06');
INSERT INTO `posts` VALUES ('27', '3', '0', '2', '【PHP】进一法取整、四舍五入取整、忽略小数等的取整数方法大全', '【PHP】进一法取整、四舍五入取整、忽略小数等的取整数方法大全', '\r\nPHP取整数函数常用的四种方法,下面收集了四个函数；经常用到取整的函数，今天小小的总结一下！其实很简单，就是几个函数而已～～主要是：\r\n```\r\nceil，floor，round，intval\r\n``` \r\n \r\n## 一、ceil — 进一法取整\r\n    \r\n说明\r\n``` \r\nfloat ceil ( float value )\r\n```\r\n返回不小于 value 的下一个整数，value 如果有小数部分则进一位。\r\n\r\nceil() 返回的类型仍然是 float，因为 float值的范围通常比 integer 要大。\r\n    \r\n例子 1. ceil() 例子\r\n```\r\n    < ?php\r\n    echo ceil(4.3); // 5\r\n    echo ceil(9.999); // 10\r\n    ?>\r\n``` \r\n## 二、floor — 舍去法取整\r\n\r\n说明\r\n```    \r\nfloat floor ( float value )\r\n```\r\n返回不大于 value 的下一个整数，将 value 的小数部分舍去取整\r\n。\r\nfloor() 返回的类型仍然是 float，因为float 值的范围通常比 integer 要大。\r\n\r\n例子 1. floor() 例子\r\n```\r\n    < ?php\r\n    echo floor(4.3); // 4\r\n    echo floor(9.999); // 9\r\n    ?>\r\n```\r\n\r\n## 三、round — 对浮点数进行四舍五入\r\n\r\n说明\r\n```\r\nfloat round ( float val [, int precision] )\r\n```\r\n\r\n返回将 val 根据指定精度 precision（十进制小数点后数字的数目）进行四舍五入的结果。\r\n\r\nprecision也可以是负数或零（默认值）。\r\n\r\n例子 1. round() 例子\r\n```\r\n    < ?php\r\n    echo round(3.4); // 3\r\n    echo round(3.5); // 4\r\n    echo round(3.6); // 4\r\n    echo round(3.6, 0); // 4\r\n    echo round(1.95583, 2); // 1.96\r\n    echo round(1241757, -3); // 1242000\r\n    echo round(5.045, 2); // 5.05\r\n    echo round(5.055, 2); // 5.06\r\n    ?>\r\n```\r\n \r\n## 四、intval—对变数转成整数型态\r\n\r\n例子intval()\r\n```\r\n    < ?php\r\n    echo intval(4.3); //4\r\n    echo intval(4.6); // 4\r\n    ?>\r\n```\r\n\r\n \r\n\r\n函数 |	描述 |	PHP\r\n---|---|--- \r\nabs()	|绝对值。	|3\r\nacos()	|反余弦。	|3\r\nacosh()	|反双曲余弦。	|4\r\nasin()	|反正弦。	|3\r\nasinh()	|反双曲正弦。	|4\r\natan()	|反正切。	|3\r\natan2()	|两个参数的反正切。|	3\r\natanh()	|反双曲正切。	|4\r\nbase_convert()|	在任意进制之间转换数字。	|3\r\nbindec()	|把二进制转换为十进制。	|3\r\nceil()	|向上舍入为最接近的整数。	|3\r\ncos()	|余弦。	|3\r\ncosh()	|双曲余弦。	|4\r\ndecbin()	|把十进制转换为二进制。	|3\r\ndechex()	|把十进制转换为十六进制。	|3\r\ndecoct()	|把十进制转换为八进制。	|3\r\ndeg2rad()	|将角度转换为弧度。	|3\r\nexp()	|返回 Ex 的值。	|3\r\nexpm1()	|返回 Ex - 1 的值。	|4\r\nfloor()	|向下舍入为最接近的整数。	|3\r\nfmod()	|返回除法的浮点数余数。	|4\r\ngetrandmax()|	显示随机数最大的可能值。	|3\r\nhexdec()	|把十六进制转换为十进制。	|3\r\nhypot()	|计算直角三角形的斜边长度。	|4\r\nis_finite()	|判断是否为有限值。	|4\r\nis_infinite()	|判断是否为无限值。	|4\r\nis_nan()	|判断是否为合法数值。	|4\r\nlcg_value()	|返回范围为 (0, 1) 的一个伪随机数。	|4\r\nlog()	|自然对数。	|3\r\nlog10()	|以 10 为底的对数。	|3\r\nlog1p()	|返回 log(1 + number)。	|4\r\nmax()	|返回最大值。	|3\r\nmin()	|返回最小值。	|3\r\nmt_getrandmax()	|显示随机数的最大可能值。	|3\r\nmt_rand()	|使用 Mersenne Twister 算法返回随机整数。	|3\r\nmt_srand()	|播种 Mersenne Twister 随机数生成器。	|3\r\noctdec()	|把八进制转换为十进制。	|3\r\npi()	|返回圆周率的值。	|3\r\npow()	|返回 x 的 y 次方。	|3\r\nrad2deg()|	把弧度数转换为角度数。	|3\r\nrand()	|返回随机整数。	|3\r\nround()	|对浮点数进行四舍五入。	|3\r\nsin()	|正弦。	|3\r\nsinh()	|双曲正弦。	|4\r\nsqrt()	|平方根。	|3\r\nsrand()	|播下随机数发生器种子。	|3\r\ntan()|	正切。	|3\r\ntanh()|	双曲正切。	|4\r\n\r\n## PHP  Math  常量\r\n\r\n\r\n常量名|	常量名	|常量值	|PHP\r\n---|---|---|--- \r\nM_E	| e	|2.7182818284590452354	|4\r\nM_EULER	| Euler 常量|	0.57721566490153286061	|5.2.0\r\nM_LNPI	| log_e(pi)|	1.14472988584940017414	|5.2.0\r\nM_LN2	| log_e 2|	0.69314718055994530942	|4\r\nM_LN10	| log_e 10|	2.30258509299404568402	|4\r\nM_LOG2E	| log_2 e|	1.4426950408889634074	|4\r\nM_LOG10E| log_10 e|0.43429448190325182765	|4\r\nM_PI	| Pi	|3.14159265358979323846	|3\r\nM_PI_2	| pi/2	|1.57079632679489661923	|4\r\nM_PI_4	| pi/4	|0.78539816339744830962	|4\r\nM_1_PI	| 1/pi	|0.31830988618379067154	|4\r\nM_2_PI	| 2/pi	|0.63661977236758134308	|4\r\nM_SQRTPI | sqrt(pi)	|1.77245385090551602729	|5.2.0\r\nM_2_SQRTPI| 2/sqrt(pi)	|1.12837916709551257390	|4\r\nM_SQRT1_2| 1/sqrt(2)	|0.70710678118654752440	|4\r\nM_SQRT2	| sqrt(2)	|1.41421356237309504880	|4\r\nM_SQRT3	| sqrt(3)	|1.73205080756887729352	|5.2.0\r\n\r\n', '1', '1', '2019-01-14 05:20:06', '2019-01-14 05:20:06');
INSERT INTO `posts` VALUES ('28', '4', '0', '39', 'git常用命令', '', '## 1、创建仓库（公开）\r\n\r\n　　点击github右上角的+里面的new repository \r\n\r\n　　在repository name栏中输入仓库的名称\r\n\r\n　　description 栏中可以设置仓库的说明\r\n\r\n　　piblic（公开）通用 private（非公开）收费\r\n\r\n　　勾选Initialize this repository with a README ，如果想向GitHub添加手中已有的Git仓库，建议不要勾选\r\n\r\n　　Add.gitignore 下拉框中选择要使用的框架\r\n\r\n　　Add a license选择添加许可协议文件\r\n\r\n　　点击create repository按钮，完成仓库的创建\r\n\r\n## 2、克隆之前首先要选择克隆文件的位置（cd）\r\n\r\n　　clone已有仓库\r\n\r\n　　git clone git@github.com:XXX/yyyy.git //XXX为github的用户名，yyy为仓库名\r\n\r\n## 3、在对应的文件夹中添加新有项\r\n\r\n　　git status\r\n\r\n## 4、提交\r\n　　git add mmm.sss //mmm为文件名称，sss为文件拓展名（常用git add .）\r\n\r\n　　git commit -m \"hhh\" //hhh为git commit 提交信息，是对这个提交的概述\r\n\r\n　　git log//用于查看提交日志\r\n\r\n　　git push //更新GitHub上的仓库\r\n\r\n## 5、用git创建仓库\r\n\r\n　　mkdir nnn //仓库名\r\n\r\n　　cd hhh\r\n\r\n　　git init //初始化仓库\r\n\r\n　　git status //查看仓库状态\r\n\r\n　　touch README.md //创建READEME.md文件\r\n\r\n　　git add ERADME.md //添加ERADME.md至暂存区\r\n\r\n　　git commit -m \"hhh\" //如果想要提交信息记录的更详细，请不要加 -m\r\n\r\n　　git log --pretty=short //加--pretty=short 只显示提交信息的第一行\r\n\r\n　　git log ggg //ggg是指指定的文件或目录，用于查看指定的目录、文件的日志\r\n\r\n　　git log -p //查看提交所带来的改动\r\n\r\n　　git log -p ggg //查看指定文件的改动\r\n\r\n　　git diff //可以查看工作树，暂存区，最新提交之间的差别\r\n\r\n　　git diff HEAD //查看工作树与最新提交的差别\r\n\r\n## 6、分支操作\r\n\r\n　　git branch //显示分支一览表，同时确认当前所在的分支\r\n\r\n　　git checkout -b aaa //创建名为aaa的分支，并且切换到aaa分支\r\n　　\r\n  （git branch aaa //创建名为aaa的分支\r\n \r\n　　git checkout aaa // 切换到aaa分支\r\n　　）能和git branch -b aaa 得到同样的效果\r\n\r\n　　git checkout - //切换到上一分支\r\n\r\n## 7、合并分支\r\n\r\n　　git checkout master //切换到master分支\r\n\r\n　　git marge --no--ff aaa // 加--no--ff 参数可以在历史记录中明确地记录本次分支的合并\r\n\r\n　　git log --graph //以图表形式查看分支\r\n\r\n## 8、更改提交的操作\r\n\r\n　　git reset //回溯历史版本\r\n\r\n　　git reset --hrad //回溯到指定状态，只要提供目标时间点的哈希值\r\n\r\n## 9、推进历史\r\n\r\n　　git reflog //查看仓库的操作日志，找到要推历史的哈希值\r\n\r\n　　git checkout master\r\n\r\n　　git reset --hrad ddd //ddd为要推进历史的哈希值\r\n\r\n## 10、修改提交信息 git commit --amend\r\n\r\n　　压缩历史 git rebase -i 错字漏字等失误称作typo\r\n\r\n　　根据以前的步骤在GitHub上创建仓库，应于本地的仓库名相同 GitHub上面创建的仓库的路径为git@github.com: 用户名/仓库名.git\r\n\r\n　　git remote add eee git@github.com: 用户名/仓库名.git //添加远程仓库，并将git@github.com: 用户名/仓库名.git远程仓库的名称改为eee\r\n\r\n　　git push -u eee master //推送至远程仓库 master分支下 -u 参数可以在推送的同时，将eee仓库的master分支设置为本地仓库的当前分\r\n　　支的的upstream（上游）。添加这个参数，将来运行git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从eee的master\r\n分支中获取内容\r\n\r\n　　git checkout -b feature d eee/feature d //获取远程的feature d分支到本地仓库，-b参数后面是本地仓库中新建的仓库的名称\r\n\r\n　　git pull eee feature d //将本地的feature d分支更新为最新状态\r\n\r\n\r\n　　在GitHub上面查看两个分支之间的差别，只需要在地址栏中输入http://github.com/用户名/仓库名/分支1...分支2\r\n\r\n## 11、查看master分支在最近七天内的差别\r\n　　http://github.com/用户名/仓库名/master@{7.day.ago}...master （同样，day，week，month，year都是可以哒）\r\n\r\n## 12、查看与指定日期之间的差别\r\n　　http://github.com/用户名/仓库名/master@{xxxx-xx-xx}...master （xxxx-xx-xx代表年月日）', '1', '1', '2019-01-13 21:50:45', '2019-01-13 21:50:45');
INSERT INTO `posts` VALUES ('29', '14', '0', '39', '1-微习惯是什么', '千里之行，始于足下。    ——老子', '```\r\n千里之行，始于足下。    ——老子\r\n```\r\n一起开始你的第一个微习惯吧。\r\n\r\n每天至少读两页这本书，直到读完为止。可以多读一些，但每天绝不能少于两页。读\r\n两页书花不了多少时间和精力，所以你没借口可用。从现在开始，你可以一边阅读关于微习惯的本书，一边体会真正“拥有”一个微习惯是什么感受。\r\n\r\n现在，摸你的鼻子。没错，就是做摸鼻子的动作，我稍后会解释原因。接下来，请思\r\n考下列事实对你来说意味着什么：\r\n```\r\n1. 如果没有产出什么结果，再大的决心也毫无价值。比如，我可以“说”我要每天锻炼两小时，可根本就没这么做，决心再大也就没有意义了。实际上，脱离行动的决心反而会有损自信。\r\n2. 研究表明：人们总会习惯性地高估自己的自控力。\r\n```\r\n这两点虽然道理浅显，却揭示了很多人难以改变的原因。\r\n\r\n他们雄心勃勃，却高估了自己的能力，为求改变而勉强自己做超出自己能力的事情。\r\n\r\n这就是欲望和能力不匹配。\r\n\r\n你还应考虑下面两个事实：\r\n```\r\n1. 哪怕是一点点行动，也比毫不作为强无数倍（在数学意义上如此，实际生活中也是如此）。\r\n2. 相比某一天做很多事，每天做一点儿事的影响力会更大。能大多少？答案是惊人的。因为每天完成一点儿事，积累起来就形成了一辈子的固定习惯。很快，你将看到它的影响到底有多大。\r\n```\r\n如果上面的观点听起来挺合理，那么我们就能得出核心结论了：\r\n```\r\n小决心比大决心的效果更好。\r\n```\r\n是不是很有意思？不过，好戏才刚刚开始。\r\n\r\n你有没有经历过瓶颈期？\r\n\r\n有没有竭尽全力想提高自己却最终失败的经历？\r\n\r\n你是否在无数次尝试后遭遇失败，然后便很久不敢重新开始呢？\r\n\r\n其实，这些我们都经历过。请回答这些更有意思的问题：\r\n```\r\n你没能实施行动，\r\n也没能实现计划，\r\n但有没有可能这并不是你的错，\r\n而是大多数人采用并认可的策略出了问题呢？\r\n```\r\n如果研究人类行为、意志力和大脑方面的科学家给出了一个更好的替代方案，它能帮你实现计划，但极少有人实践或推荐，你会如何选择？\r\n\r\n如果改用这个新策略，你的一切都将改变，不管你内心感受如何，你很清楚只要采取行动，就能养成好习惯、实现目标并最终改变人生，你又会如何选择？\r\n\r\n### 欢迎来到微习惯的世界！\r\n\r\n我知道，这一切听起来有些夸张，可你刚刚读到的正是我的简版自传。\r\n\r\n这就是我从 2012 年末开始逐渐领悟的事实和真理。此前 10 年的生活中，我不断探索，力求进步，结果却总是令人失望。2012 年，我尝试了一种新方法，终于实现了前所未有的突破。\r\n\r\n于是我急于弄明白：\r\n```\r\n究竟为什么这个古怪的策略会这么有效，能让一切和谐运转，我当时（现在也）对此惊讶不已。\r\n后来，就有了这本书。我们总是急于责怪自己没什么进步，却无法及时意识到是策略出了问题。\r\n之后，我们又会重蹈覆辙，还幻想着能看到一些成效。\r\n可是问题在于，如果一种策略已经失败好几次，那就该试试别的了。\r\n如果它不适合你，就算适合别人，那也没有价值。真希望多年前我就能明白这个道理！\r\n```\r\n我之前让你摸自己的鼻子，是因为我希望你能明白一个道理。首先，请注意，摸鼻子\r\n不会带来任何回报。其次，你还是这样做了，只是因为这件事你能做到。如果你刚才没摸，现在摸吧，这样下面的内容就容易理解了（如果你不想摸鼻子，也可以选择其他动作）。\r\n\r\n你能摸到自己的鼻子，是因为你对这件事的抵触情绪比你的意志力弱。\r\n\r\n恭喜恭喜，你现在已经有资格学习微习惯了。\r\n\r\n这还只是意志力的初级练习。如果你能强迫自己摸鼻子，那你也能成功运用这本书里\r\n的策略，这不是玩笑，我是很认真的。这本书的问世，源自于我在 2012 年 12 月 28 日做的 1 个俯卧撑。就是因为这个俯卧撑，我现在能一口气做 16 个俯卧撑了，身材也练好了。因为这个俯卧撑，我每天都忙着读书和写作。正是从这个俯卧撑开始，我的人生开始出现了美妙的变化。\r\n\r\n每一个伟大的成就都建立在之前打好的基础之上。追根溯源，你会发现一切都始于那\r\n一小步。如果没有这个俯卧撑，现在我还要拼命激励自己健身，纠结怎么坚持阅读和写作。这个俯卧撑启发我找到了新策略，让我受益颇丰。\r\n\r\n想知道一个小小的动作是怎么彻底改变我的吗？\r\n\r\n一切的源头：\r\n```\r\n挑战 1 个俯卧撑\r\n```\r\n我正考虑要不要把它命名为“黄金俯卧撑”。\r\n\r\n那天是 2012 年 12 月 28 日，新年将近。\r\n\r\n跟其他人一样，我回顾了我的 2012 年，结果不太满意，所以我希望我能在 2013 年活得更精彩，一个最强烈的想法就是健身。\r\n\r\n可我又不想定一个“新年愿望”——多年前我就决定不这么干了，因为实现的可能性低得可怜。\r\n\r\n我总觉得，我在拉斯维加斯赢钱的可能性都比我在生活中获得成功的大。从高中后半段开始，我就一直想把锻炼培养成习惯。尽管我付出了不少努力，但 10 年里一直没有坚持下来。\r\n\r\n这样下去我还能有什么自信呢？\r\n\r\n偶尔斗志大爆发，我也只能坚持两周，最终因为各种原因放弃，有时连原因都没有就直接放弃了。1 月 1 日毕竟是一个表决心的日子，我想赶在新年之前有所行动，所以决定用原地锻炼 30 分钟的方式开个头。可我站在那里，一动不动，毫无动力。我试了试平时激励自己的那一套话：“加油啊，斯蒂芬，想成为真正的赢家，就必须加倍努力才行。”我试着听快节奏的音乐，试着幻想自己拥有能在沙滩上炫耀的完美身材。各种方法都试过了，一点儿作用都没有。我觉得自己身材走形，无精打采，就像个废物，什么都做不了。\r\n\r\n那一刻，30 分钟的锻炼对我来说就像攀登珠穆朗玛峰一样。我完全不想锻炼，感觉自己特别失败，事实上我的确很失败。\r\n\r\n其实，不是 30 分钟锻炼要花的时间和精力吓到我了，而是为达到我的健身目标需要投入的努力加在一起多得吓人。两者相比，真是天壤之别，光 1 年的运动量就够我受的了。还什么都没干，我就已经内心惭愧，不知所措，心灰意冷了。\r\n\r\n### 终结失败的转折点\r\n\r\n几个月前，我看了迈克尔·米哈尔科（Michael Michalko）写的《米哈尔科商业创意全攻略》（Thinkertoys ），这本书超棒，讲的是创造性思维以及如何解决问题。他提到的创造性思维技巧中的一个叫作“假面具”。按照这个方法，如果你想解决一个问题，可以从它的对立面着手思考，看会有什么创意迸发出来。举个简单的例子：如果想盖一座摩天大楼，就反过来想如果造一座深入地下的建筑会怎样。这样做可以强迫大脑拓宽思路，看到更多的可能性，进而激发更多创意。\r\n\r\n我手头有个问题需要解决，这个技巧刚好闪现，于是我就开始思考，\r\n```\r\n30 分钟锻炼的对立面是什么？\r\n吃着冰淇淋看电视可以算一个。\r\n```\r\n在那种情况下，我的确觉得 30 分钟是个艰巨无比的挑战（像珠穆朗玛峰一样高）。换个思路吧，从锻炼强度入手。\r\n\r\n如果不是 30分钟的挥汗如雨、浑身酸痛，而只是做 1 个俯卧撑会怎样？\r\n\r\n不必多做，1 个就够了。这正好和我的痛苦锻炼相反！\r\n\r\n最终，我苦笑着打消了这个想法。\r\n```\r\n“太可悲了！1 个俯卧撑有什么用，我得多锻炼才行！”可每当我想按最初计划行动时，又做不到了。因为我的 30 分钟锻炼计划总是失败，最后我心想“管他呢，就做 1 个俯卧撑得了”，\r\n```\r\n于是我趴在地上做了 1 个俯卧撑，然后，我的人生从此走向了光明。\r\n\r\n我摆好俯卧撑姿势后，突然注意到这和 30 分钟锻炼开始时的姿势一模一样。只做了1 个俯卧撑，我的肩膀就快要裂开了，胳膊肘也该加润滑油了，肌肉就像睡了 24 年刚醒过来一样。可是，既然都已经摆好姿势了，我索性又一口气多做了几个。\r\n\r\n每做 1 个俯卧撑，迟钝的肌肉和顽固的大脑都无比煎熬。\r\n\r\n我起身时心想，这总比什么都不做强。需要强调一下，这时我心里想的是“就到此为\r\n止吧”。但紧接着，我又打算再挑战 1 个引体向上，这么简单的动作没什么好拒绝的吧？\r\n\r\n我准备好引体向上的器材，完成了 1 个，然后又完成了几个。心想：“有点意思，虽说有点难，但也没有我想象的那么难。”\r\n\r\n这时，我的肌肉活动开了，有兴趣多做几个了，但因为万事开头难（而且我那时的身材太差了），内心难免还有些抵触。我继续使用相同的策略，每次设立的目标都尽可能小，这样容易坚持。在这次锻炼的俯卧撑环节中，我不得不设定了 7 个微型目标：完成了，再来 1 个，完成了，再来 2 个，现在再来 1 个。\r\n\r\n每次用超简单的挑战来引诱自己后，我都能完成甚至超额完成。这种能够完成目标的新感觉太棒了。\r\n\r\n做完这些时，我已经运动了 20 分钟，而且感觉很好。\r\n\r\n平时锻炼到这个时候，我都会跟着视频完成一组 10 分钟的腹肌练习。\r\n\r\n这个念头刚刚浮现，就果断被我的大脑枪毙了，就像在电子射击游戏里打小鸟一样，大脑仿佛在说：“你已经达到目标了，可别得寸进尺。”但你可能猜到了我接下来是怎么做的。\r\n\r\n我决定铺好垫子，大脑接受了。然后我决定找到腹肌练习视频，大脑也接受了。\r\n\r\n然后我决定按下播放键。10 分钟过后，我的腹肌像着火了一样。需要重点强调一下，这些决定都是单独的，所以完成 10 分钟酸痛难忍的腹肌练习的压力总和一直没有出现在我的大脑里。\r\n\r\n如果真的出现了，我肯定就没法完成了。\r\n\r\n我把一个俯卧撑变成了看似不可能的 30 分钟锻炼，第二天我就写下了《挑战 1 个俯卧撑》，它成了我的博客上迄今为止人气最高的文章之一。\r\n\r\n直到现在，还有人发信息告诉我这件事是如何激励他们坚持锻炼的。\r\n\r\n整个 2013 年，我继续要求自己每天完成 1 个俯卧撑，当然，我通常会多做几个。可有一天，直到进了被窝我才想起这件事，于是我翻过身来，趴下，在床上完成了 1 个俯卧撑。想到最后一秒才完成这项每日目标，我大笑起来。这件事听起来可能意义不大，但是轻松成功并能保持成功的感觉真是太美妙了。之后，我会看到它对我的成功有多么重要。\r\n\r\n我注意到了两件事。\r\n\r\n第一，虽然只是每天做几个俯卧撑，但这种行为的确能在生理和心理上影响你的感受。我的身体更结实了，肌肉也练出来了。\r\n\r\n第二，我意识到锻炼正在变成惯性。即使是面对这么微不足道的挑战，我每天也都在做了不起的事情。定期锻炼变得越来越简单。\r\n\r\n正因为有了这样的正能量经历，我特别想知道有没有哪种科学原理能告诉我，为什么超小的步骤反而会比更大的目标对我更有效。研究表明，确实有这样的科学原理，而且在本书里随处可见，虽然没有哪一项研究直接宣称“答案就是微习惯”，但有许多研究已经揭示了意志力和大脑的本质，以及怎么做才能让行为持久。这套习惯养成原理正是站在这些巨人的肩膀上总结的。\r\n\r\n从 6 月下旬开始，我实现了从家到健身房的跨越。从那时起，我已经练出了一些肉\r\n。9 月 20 日，我意识到了这个秘方在其他生活领域内的潜力，比如阅读和写作。从那天开始，我的工作效率大大提高，身材保持得很好，我自己都感觉很神奇。\r\n\r\n我一直期盼的事情此时正在发生。最近我甚至开始吃大份沙拉了，这是因为我想这么做。如果你在健身和学习这样的关键领域投入了不少时间精力，那么你在其他领域可能也会这么做。\r\n\r\n## 只为培养好习惯\r\n在我们进一步探讨之前，我希望你能明白，本书不会帮你戒烟或者控制赌瘾。微习惯\r\n策略只会帮你培养好习惯，给你的生活增添积极行为，持续丰富你的生活。消除坏习惯和建立好习惯有着共同的目标——用更好的行为方式取代原有的行为方式。\r\n\r\n如果你有坏习惯，你改变自己的主要动力是远离这些消极的东西；\r\n\r\n如果你有好习惯，你改变自己的主要动力是靠近这些积极的东西。\r\n\r\n“靠近”是微习惯策略的重点。\r\n\r\n像药物成瘾这样根深蒂固的主动坏习惯，改变起来需要进行心理治疗，可能还需要专\r\n业的辅助治疗。\r\n\r\n但如果你有懒惰、恐惧或者浪费时间这样的被动坏习惯，想找到长期的解决方案，那么这本书能帮上大忙。\r\n\r\n如果给生活注入好习惯，被动坏习惯通常就会被边缘化。\r\n\r\n如果你把时间都花在好习惯上了，坏习惯还能继续吗？\r\n\r\n说句实话，用这种方式养成好习惯其实很简单。权宜之计一般都不可行，可是你已经和大脑对抗 10 年了（有人甚至更长），一个能让大脑认同的策略显然会不一样。只要改变的策略和知识得当，以前看似不可能的事情会变得完全可能，而且简单明了，这就好比要打开一扇锁着的门一样——只有拿对钥匙才能轻松打开。\r\n\r\n同样的道理，身处黑暗（也许是坏习惯导致的）中的人也需要光明。如果你的生活因\r\n为坏习惯混乱不堪，增加一些好习惯能让它有所改变。\r\n\r\n黑暗不是独立存在的，而是我们给“缺乏光明”起的别名。缺少好习惯的光照，生活中出现了黑暗的空洞，也许人们的坏习惯就是这么来的。当你养成好习惯，它会为你指明一条新路，让你重拾自信，给你希望。它还是个绝好的基础，可以在上面建立起很多东西。\r\n```\r\n这个理念同样也是一套人生哲学，它证明、解释并赞美了“前进的第一步总是最重要的”这一观点。\r\n```\r\n换句话说，除了帮你培养习惯，在其他方面它也能助你一臂之力。我不是仅仅希望这本书能对你有用，而是相信它一定会对你有用，就像我相信大多数人的新年愿\r\n望没法实现一样。从统计学角度看，微习惯成功的概率很高。有了微习惯，你也能用最不可思议的方式改变自己的生活。\r\n\r\n## 微习惯简介\r\n既然整本书都在说“微习惯”，我打算简单解释一下这个概念。\r\n\r\n如果你想培养一个新习惯，微习惯基本上就是它经过大幅缩减的版本——把“每天做 100 个俯卧撑”缩减成每天 1个，把“每天写 3000 字”缩减成每天写 50 字，把“始终保持积极思考”缩减成每天想两件好事，把“像企业家一样创新”缩减成每天想出两个点子（跟其他有企业家风范的行为对比，这一点容易得多）。\r\n\r\n微习惯体系的基础在于“微步骤”，那些“小得不可思议的一小步”。把事情分成小步来做不是什么新概念，但是为什么它效果显著？它的原理是什么？这两个问题还没有明确的答案。\r\n\r\n当然，微步骤的概念因人而异，你的一小步对我来说可能是一次巨大的跨越。“小\r\n得不可思议的一小步”这种称法把它的特点体现得淋漓尽致，因为如果和你的能力上限相比，一个步骤简单得让你匪夷所思，那它就再合适不过了。\r\n\r\n微习惯体系的威力体现在以下几个方面：应用、思维模式、固有正反馈循环机制、对\r\n自我效能感的自然提升，当然，还有把微步骤巧妙转变成一个习惯的方法，我将在后面展开说明，但这个过程也是人类固有的。微习惯体系虽然简单，却有着复杂、智能的后盾。\r\n\r\n按照微习惯策略行动，就是运用少量的意志力强迫自己做一件事情。做一个俯卧撑或\r\n者想出几个点子并不需要大量的意志力。利用微习惯做事，你会收获巨大的惊喜。\r\n\r\n首先，在完成你的微目标之后，你很可能会继续完成“额外环节”，这是因为我们本来就想进行这些积极行为，所以一旦开始，内心的抵触就会减轻。\r\n\r\n第二个收获是惯性。即使你没有超额完成微目标，你的行为也会慢慢发展为微习惯。从这里开始，你会完成“额外环节”或逐步提升习惯，还会接连不断地收获成功。\r\n```\r\n一家银行可能因为规模太大而不至于失败，而微习惯是因为太小而不至于无法完成\r\n```\r\n因此，你不会有机会体验未完成目标导致的常见消极情绪，比如愧疚和挫败感。因为设定的目标能轻易实现，而且自带强大的螺旋状激励机制，微习惯能跻身少数可以切实保证每天成功的目标策略的行列。微习惯让我感觉自己的冲劲无法阻挡；而在利用微习惯之前，我感觉自己想改变也无法开始。\r\n\r\n总结起来，微习惯就是你强迫自己每天做的微不足道的积极行为。微步骤每次都能有\r\n效果，而习惯来自坚持，所以它俩注定要在一起，这个爱情故事可比《暮光之城》好多了。\r\n\r\n### 习惯和大脑探秘\r\n为什么不在日常生活中运用微步骤呢？当然要用了！习惯就像生活的骨架一样重要，\r\n所以忽视习惯就大错特错了。我在挑战一个俯卧撑时发现了微步骤的威力，当时我就像一个刚发现自己有超能力的超级英雄一样，特别想知道要怎么最大限度地运用这种能力，答案正是——**习惯**。\r\n\r\n本书重点讲运用微步骤培养习惯的方法，因为没有什么比习惯更重要了。杜克大学的\r\n一项研究表明：\r\n```\r\n我们的行为中大约有 45% 源于习惯。习惯其实远比这 45% 的比重代表的含义更重要，因为习惯是不断重复的行为，而且大部分每天都在重复，长远看，这种不断的重复叠加起来，要么收益颇丰，要么贻害无穷。\r\n```\r\n\r\n习惯了每天写 1000 字，一年下来就是 36.5 万字，相当于 7 本 5 万字的小说，当然，肯定没法跟列夫· 托尔斯泰 58 万字的巨著《战争与和平》比了。\r\n看看这些 5 万字左右的经典小说吧：\r\n```\r\n● 道格拉斯·亚当斯的《银河系漫游指南》（46333 字）\r\n● 斯蒂芬·克莱恩的《红色英勇勋章》（50776 字）\r\n● F. 斯科特·菲茨杰拉德的《了不起的盖茨比》（50061 字）\r\n```\r\n你第一次（或者前 100 次）尝试写的小说可能无法成为这样的世界名著，可是如果每年都写 7 本，就可以通过多次尝试不断完善自己的水平，对吧？\r\n\r\n可能改变你一生的习惯还有：\r\n```\r\n● 习惯每天锻炼 20 分钟，足够改变你的体格。\r\n● 习惯吃更加健康的食物，可能延长你的寿命，而且会让你的精力更充沛。\r\n● 习惯每天早上早起 1 小时，每年就会多阅读 365 小时。\r\n```\r\n按照平均每分钟阅读 300 字算，利用这些额外的阅读时间，你每年能多读 657 万字，或 131 本 5 万字的书。这可是相当多的书了，肯定会帮你增长知识。\r\n\r\n像“积极思考”和“懂得感恩”这样的例子虽然相对抽象，也会对生活产生深远影响。有了微习惯，这家为生活提供福利的“超市”便可以开张营业了。选择你最爱的习惯，放到购物车里，登录 minihabits.com，了解更多关于微习惯的观点——等等！先回来，别太激动，你得先看完这本书才行。后面还有很多对你的成功会大有帮助的重要内容。\r\n\r\n韦氏词典给“习惯”下的定义是“一种常见的行为方式：一个人以规律、重复的方式做\r\n的事”。因为倾向从抵触情绪和意志力的方面考虑问题，我认为习惯是“做起来容易，不做反而更难的一种行为”。\r\n\r\n习惯不能直接获得——你无法马上就建立或去除一个习惯。它们是在长期不断重复中\r\n被塑造出来的。\r\n\r\n### 习惯在大脑里的样子\r\n神经通路是大脑里的沟通渠道，这些通路就是习惯在身体里的“长相”。\r\n\r\n它的工作机制是这样的：一旦某个习惯指定的神经通路被一个想法或外部信号触发，\r\n脑中就会有一个电荷沿着这条通路放电，然后你就会有一股想进行这项习惯行为的强烈欲望。\r\n\r\n比如，如果你每天醒来后都要马上洗澡，那就会有一个神经通路和这个行为关联。你\r\n一醒来，这个“洗澡神经元”就会放电，然后你就会像僵尸一样走过去洗澡——根本无须思考！这就是拥有习惯的神奇或悲惨之处，至于到底神奇还是悲惨就要看习惯是好是坏。\r\n\r\n随着习惯根深蒂固，与之关联的神经通路会变得更粗、更牢固。\r\n\r\n理解这一点后，我们的目标变得简单明了。如果想要建立并强化特定的神经通路，我\r\n们就要不断重复。这说起来容易，但我们必须突破人类与生俱来的限制因素才能做到。许多现有的传统习惯策略并没有把这些已被证实的限制因素考虑在内，低估了它们的严重程度，或者说一些含糊无益的话，比如“这个过程确实很难，所以你一定要让自己渴望得到它才行”，如果没有应对这些限制的可靠计划，即使动力十足，你也会精疲力竭，无法坚持，最终过早放弃。\r\n\r\n你有没有发现我有点儿反对动力策略？\r\n\r\n那是因为我用了它十年，却一无所获，稍后我们再讨论这个问题。\r\n\r\n### 习惯还与压力有关\r\n我们在讨论习惯有多重要的同时，还应该考虑压力。\r\n\r\n当今世界的生活节奏比以往任何时候都快，所以我们的压力似乎也更大了。生活并不\r\n完美，没有压力，生活就不可能正常进行。\r\n\r\n大多数人从未想过这样的问题：“压力是怎样影响我们的习惯的？”\r\n\r\n已有研究显示，压力会促进习惯性行为，无论这种习惯是好是坏。加州大学洛杉矶分\r\n校的两项实验和杜克大学的一项试验都发现：\r\n```\r\n压力会促进人们更加依赖惯性行为。\r\n```\r\n温迪·伍德（Wendy Wood）博士根据她在《人格和社会心理学杂志》（Journal of Personality and Social Psychology ）上发表的研究提出:“遇到压力时，人们无法轻易做出决定，意志力会减弱或令人感到不知所措。\r\n你没有精力做出决定时，往往会重复平时的做法。”好习惯是这样，坏习惯也是如此。这个结论深刻地揭示了习惯在生活中的重要性。\r\n\r\n现在试想一下：如果坏习惯让你压力过大，你会怎么做。压力是负反馈循环的绝佳导\r\n火索，它会触发一个坏习惯，坏习惯又会触发内疚感、内心的焦虑和更多压力，这些消极因素会再次触发这个习惯。再想想，如果习惯本身就能缓解压力会怎样？拿锻炼来说，你的压力把你拽到健身房，锻炼会帮你缓解焦虑。以上两种方式对生活的影响会有惊人的差别，因为一个让你不顾艰难险阻积极地走向成功，而另一个随时会把你扔进消极的螺旋里。我是个橄榄球迷，常常会想起比赛里的那些大逆转：一支球队即将从一码线触地得分，可是四分卫被拦截了，对方球队回传并触地得分。这不仅送给对手 7 分，还丢了自己队伍本来可能得到的 7 分！所以，这是个 14 分的大逆转。\r\n\r\n面对压力时，所有的习惯都可能成为“14 分的大逆转”。\r\n\r\n它给我们的另一个暗示与改变的难度有关。压力越多，生活就越难改变。正如伍德教\r\n授所说，“你往往会重复平时的做法”。如果压力让我们走向习惯，那么它也会让我们远离其他的一切，包括我们所青睐的新积极行为（我们希望它能成为习惯）。\r\n\r\n此刻，我正在微笑，可是你看不见。当我们有压力时，标准习惯法则就会崩溃，因为现有的习惯会强化，但是在这方面，微习惯策略不会让你失望。\r\n\r\n### 养成新习惯需要多长时间？\r\n视情况而定。如果有人给了你不一样的答案，肯定也是从别处听到的（而且是错的）\r\n\r\n不是 21 天，也不是 30 天 。天哪，我真想把这句话贴在所有广告牌上。“21 天”谬论可能源自一位整形外科医生麦克斯威尔·马尔茨（Maxwell Maltz）。据说，马尔茨医生发现接受截肢手术的患者需要大约 21 天来适应肢体残缺的事实，\r\n\r\n因此，他认为 21 天是人们适应任何生活变化所需的时间长度。医生，真的是这样吗？在我看来，习惯肢体残缺和努力多喝水可不是一回事，而且我还要补充一点：这两件事都和争取每天做 150 个俯卧撑大不相同。\r\n\r\n关于习惯形成所需时长，被引用最多的是发表于 2009 年的《欧洲社会心理学杂志》（European Journal of Social Psychology ）上的一项研究，研究的每位参与者选择 “每天在同样的条件下（比如“早饭过后”）进食、饮水或做其他活动，总共 12 周”，他们有什么发现呢？\r\n\r\n一个行为变成习惯所需的时间平均为 66 天 ，但不同行为所需时间相差很大，从 18天到 254 天不等，这表明人们将习惯自动化所需时间千差万别，在某些案例中，这个时间可能惊人地长。“21 天”和“30 天”挑战很流行，但很多类型的习惯完全不可能在这么短的时间内养成。\r\n\r\n每天喝一杯水可能属于 21 天就能养成的习惯，但是像每天 100 个仰卧起坐\r\n这样更具有挑战性的行为则要几百天甚至更长时间才能变成习惯。\r\n\r\n以上是坏消息。好消息是，习惯没有“开关键”——如果你连续 60 天做 100 个仰卧起坐，即使还没有形成全自动行为，第 61 天时做得也会比第 1 天时轻松很多。建立习惯就好像骑自行车上陡坡：爬坡，到顶，下坡。刚开始，你必须用双腿的最大力量蹬自行车，之后会渐渐变得轻松，但是你必须一直蹬到山顶，否则就会倒退回原地，让之前所有的进步付诸东流。\r\n\r\n根据我的经验，习惯形成的第一个信号是抵触情绪减弱，这很好理解。我们的思维通\r\n过在这些神经通路中发送电脉冲来实现内部沟通，众所周知，电流总是选择阻力最小的路径。与此类似，我们的大脑偏爱执行习惯，因为它们有现成的路径，也有已知的回报。可是新的行为没有经过实践，存在风险，而且没有建立起神经通路，因此，在这个行为还没有形成坚固的路径时，你必须特意压制平时的行为。这个过程不断重复，新生的神经通路就会开始成长，总有一天，它能和之前的行为抗衡。\r\n\r\n至于过程，形成一个习惯需要多久并不重要，因为你的目标是用它一辈子。你已经锻\r\n炼了 6 个月，为什么要在达到目标的时候放弃呢？如果已经达到了这个程度，却又倒退回原点，你不会觉得灰心丧气吗？关键在于能够识别宣告行为变成习惯的信号，之后你就可以把关注点转移到其他事情上，同时继续这种行为。\r\n\r\n2009 年的那项研究里还有一点更有趣的记录。研究人员得出了一个结论：\r\n```\r\n从生理学角度看，漏掉一天也不会耽误习惯的养成，一天成就不了这个过程，也毁灭不了这个过程；但从心理学角度看，这可能会带来问题。如果你真的漏掉了一天，请记住，以后要尽量坚持下去，一天都不要偷懒，因为坚持才能防止你受到打击并前功尽弃。\r\n```\r\n', '1', '1', '2019-01-11 11:11:00', '2019-01-15 06:49:47');
INSERT INTO `posts` VALUES ('30', '3', '0', '2', 'php字符串 函数 ', '字符串 函数  更多强大的字符串处理函数，参见 Perl 兼容正则表达式函数。 需要处理多字节字符集，参见 多字节字符函数。', '[字符串函数](http://www.php.net/manual/zh/ref.strings.php)\r\n\r\n[Perl 兼容正则表达式函数](http://php.net/manual/zh/ref.pcre.php)\r\n\r\n[多字节字符函数](http://php.net/manual/zh/ref.mbstring.php)\r\n```\r\naddcslashes — 以 C 语言风格使用反斜线转义字符串中的字符\r\naddslashes — 使用反斜线引用字符串\r\nbin2hex — 函数把包含数据的二进制字符串转换为十六进制值\r\nchop — rtrim 的别名\r\nchr — 返回指定的字符\r\nchunk_split — 将字符串分割成小块\r\nconvert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种\r\nconvert_uudecode — 解码一个 uuencode 编码的字符串\r\nconvert_uuencode — 使用 uuencode 编码一个字符串\r\ncount_chars — 返回字符串所用字符的信息\r\ncrc32 — 计算一个字符串的 crc32 多项式\r\ncrypt — 单向字符串散列\r\necho — 输出一个或多个字符串\r\nexplode — 使用一个字符串分割另一个字符串\r\nfprintf — 将格式化后的字符串写入到流\r\nget_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表\r\nhebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）\r\nhebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符\r\nhex2bin — 转换十六进制字符串为二进制字符串\r\nhtml_entity_decode — Convert HTML entities to their corresponding characters\r\nhtmlentities — 将字符转换为 HTML 转义字符\r\nhtmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符\r\nhtmlspecialchars — 将特殊字符转换为 HTML 实体\r\nimplode — 将一个一维数组的值转化为字符串\r\njoin — 别名 implode\r\nlcfirst — 使一个字符串的第一个字符小写\r\nlevenshtein — 计算两个字符串之间的编辑距离\r\nlocaleconv — Get numeric formatting information\r\nltrim — 删除字符串开头的空白字符（或其他字符）\r\nmd5_file — 计算指定文件的 MD5 散列值\r\nmd5 — 计算字符串的 MD5 散列值\r\nmetaphone — Calculate the metaphone key of a string\r\nmoney_format — 将数字格式化成货币字符串\r\nnl_langinfo — Query language and locale information\r\nnl2br — 在字符串所有新行之前插入 HTML 换行标记\r\nnumber_format — 以千位分隔符方式格式化一个数字\r\nord — 转换字符串第一个字节为 0-255 之间的值\r\nparse_str — 将字符串解析成多个变量\r\nprint — 输出字符串\r\nprintf — 输出格式化字符串\r\nquoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串\r\nquoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串\r\nquotemeta — 转义元字符集\r\nrtrim — 删除字符串末端的空白字符（或者其他字符）\r\nsetlocale — 设置地区信息\r\nsha1_file — 计算文件的 sha1 散列值\r\nsha1 — 计算字符串的 sha1 散列值\r\nsimilar_text — 计算两个字符串的相似度\r\nsoundex — Calculate the soundex key of a string\r\nsprintf — Return a formatted string\r\nsscanf — 根据指定格式解析输入的字符\r\nstr_getcsv — 解析 CSV 字符串为一个数组\r\nstr_ireplace — str_replace 的忽略大小写版本\r\nstr_pad — 使用另一个字符串填充字符串为指定长度\r\nstr_repeat — 重复一个字符串\r\nstr_replace — 子字符串替换\r\nstr_rot13 — 对字符串执行 ROT13 转换\r\nstr_shuffle — 随机打乱一个字符串\r\nstr_split — 将字符串转换为数组\r\nstr_word_count — 返回字符串中单词的使用情况\r\nstrcasecmp — 二进制安全比较字符串（不区分大小写）\r\nstrchr — 别名 strstr\r\nstrcmp — 二进制安全字符串比较\r\nstrcoll — 基于区域设置的字符串比较\r\nstrcspn — 获取不匹配遮罩的起始子字符串的长度\r\nstrip_tags — 从字符串中去除 HTML 和 PHP 标记\r\nstripcslashes — 反引用一个使用 addcslashes 转义的字符串\r\nstripos — 查找字符串首次出现的位置（不区分大小写）\r\nstripslashes — 反引用一个引用字符串\r\nstristr — strstr 函数的忽略大小写版本\r\nstrlen — 获取字符串长度\r\nstrnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）\r\nstrnatcmp — 使用自然排序算法比较字符串\r\nstrncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）\r\nstrncmp — 二进制安全比较字符串开头的若干个字符\r\nstrpbrk — 在字符串中查找一组字符的任何一个字符\r\nstrpos — 查找字符串首次出现的位置\r\nstrrchr — 查找指定字符在字符串中的最后一次出现\r\nstrrev — 反转字符串\r\nstrripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）\r\nstrrpos — 计算指定字符串在目标字符串中最后一次出现的位置\r\nstrspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。\r\nstrstr — 查找字符串的首次出现\r\nstrtok — 标记分割字符串\r\nstrtolower — 将字符串转化为小写\r\nstrtoupper — 将字符串转化为大写\r\nstrtr — 转换指定字符\r\nsubstr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）\r\nsubstr_count — 计算字串出现的次数\r\nsubstr_replace — 替换字符串的子串\r\nsubstr — 返回字符串的子串\r\ntrim — 去除字符串首尾处的空白字符（或者其他字符）\r\nucfirst — 将字符串的首字母转换为大写\r\nucwords — 将字符串中每个单词的首字母转换为大写\r\nvfprintf — 将格式化字符串写入流\r\nvprintf — 输出格式化字符串\r\nvsprintf — 返回格式化字符串\r\nwordwrap — 打断字符串为指定数量的字串\r\n```', '1', '1', '2019-01-14 19:08:13', '2019-01-14 19:08:13');
INSERT INTO `posts` VALUES ('31', '3', '0', '2', 'php笔记，希望对你有所帮助', '俗话说好记性不如烂笔头，\r\n什么是php进程，php生命周期，类的自动加载，线程安全，扩展的钩子函数', '## FPM\r\n\r\nfpm的实现就是创建一个master进程，在master进程中创建并监听socket，然后fork出多个子进程，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说fpm的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求，这一点与nginx的事件驱动有很大的区别，nginx的子进程通过epoll管理套接字，如果一个请求数据还未发送完成则会处理下一个请求，即一个进程会同时连接多个请求，它是非阻塞的模型，只处理活跃的套接字。\r\n\r\nfpm的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等，当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。\r\n\r\nfpm可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程，类似nginx中server概念。\r\n\r\nfpm 通过 master fork 出 worker进程，每一个 worker独自处理accept，且是阻塞模型，一个 worker同时只能处理一个请求。\r\n\r\n## master是如何管理worker进程的\r\n\r\n首先介绍下三种不同的进程管理方式：\r\n\r\nstatic: 这种方式比较简单，在启动时master按照pm.max_children配置fork出相应数量的worker进程，即worker进程数是固定不变的\r\n\r\ndynamic: 动态进程管理，首先在fpm启动时按照pm.start_servers初始化一定数量的worker，运行期间如果master发现空闲worker数低于pm.min_spare_servers配置数(表示请求比较多，worker处理不过来了)则会fork worker进程，但总的worker数不能超过pm.max_children，如果master发现空闲worker数超过了pm.max_spare_servers(表示闲着的worker太多了)则会杀掉一些worker，避免占用过多资源，master通过这4个值来控制worker数\r\n\r\nondemand: 这种方式一般很少用，在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出\r\n\r\n这就是我们在 php-fpm.ini 中配置参数的用途。\r\n\r\n## PHP 的生命周期\r\n\r\n![avatar](/public/img/posts/php.png)\r\n\r\n通过这张生命周期图可以看到，整个 PHP 内核工作的流程，我只能说 666666。。。\r\n\r\n## 变量\r\narray是PHP中非常强大的一个数据结构，它的底层实现就是普通的有序HashTable\r\n\r\nPHP中的 引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况 ，也就是没有C语言中指针的指针的概念。\r\n\r\n硬拷贝带来的一个问题是效率低，比如我们定义了一个变量然后赋值给另外一个变量，可能后面都只是只读操作，假如硬拷贝的话就会有多余的一份数据，这个问题的解决方案是： 引用计数+写时复制 。PHP变量的管理正是基于这两点实现的。\r\n\r\n用到引用计数的类型：\r\n\r\n|     type       | refcounted |\r\n|----------------|------------|\r\n|simple types    |            |\r\n|string          |      Y     |\r\n|interned string |            |\r\n|array           |      Y     |\r\n|immutable array |            |\r\n|object          |      Y     |\r\n|resource        |      Y     |\r\n|reference       |      Y     |\r\n\r\n写时复制是指：\r\n```\r\n多个变量可能指向同一个value，然后通过refcount统计引用数，这时候如果其中一个变量试图更改value的内容则会重新拷贝一份value修改，同时断开旧的指向，写时复制的机制在计算机系统中有非常广的应用，它只有在必要的时候(写)才会发生硬拷贝，可以很好的提高效率\r\n```\r\n这里我们可以结合一下自己的 PHP 代码，仔细考虑下面这个场景：\r\n\r\n有一个保存配置的 array数组，这个配置信息很多，数组占用内存也会多一些。当我们向函数传值的时候你是不是考虑过会多占用一个配置数组内存的问题。毕竟函数传值使用的是copy的方式。看到写时复制，你就大可放心，完全可以直接把整个数组传进去，只要在函数内部没有对数组进行写入操作，那就是零拷贝，只是使原数组的引用计数值+1，不会有内存上涨问题。\r\n\r\n不是所有类型都可以copy的，比如对象、资源，实时上只有string、array两种支持\r\n\r\n写时复制发生写操作的时候，实际上只能在 string和array类型上生效。如果是对象：$a = new user;$b = $a;$a->name = \"dd\";这种情况是不会复制object的，$a、$b指向的对象还是同一个。\r\n\r\n基于引用计数的垃圾回收其实是存在内存泄露风险的，比如：\r\n```\r\n$a = [1];\r\n$a[] = &$a;\r\n\r\nunset($a);\r\n```\r\n\r\nunset($a)之前引用关系：\r\n\r\n![avatar](/public/img/posts/gc_2.png)\r\n\r\nunset($a)之后:\r\n\r\n![avatar](/public/img/posts/gc_2.png)\r\n\r\n可以看到，unset($a)之后由于数组中有子元素指向$a，所以refcount > 0，无法通过简单的gc机制回收，这种变量就是垃圾，垃圾回收器要处理的就是这种情况，目前垃圾只会出现在array、object两种类型中，所以只会针对这两种情况作特殊处理：当销毁一个变量时，如果发现减掉refcount后仍然大于0，且类型是IS_ARRAY、IS_OBJECT则将此value放入gc可能垃圾双向链表中，等这个链表达到一定数量后启动检查程序将所有变量检查一遍，如果确定是垃圾则销毁释放。\r\n\r\n## PHP代码的编译\r\nC程序在编译时将一行行代码编译为机器码，每一个操作都认为是一条机器指令，这些指令写入到编译后的二进制程序中，执行的时候将二进制程序load进相应的内存区域(常量区、数据区、代码区)、分配运行栈，然后从代码区起始位置开始执行，这是C程序编译、执行的简单过程。\r\n\r\n同样，PHP的编译与普通的C程序类似，只是PHP代码没有编译成机器码，而是解析成了若干条opcode数组，每条opcode就是C里面普通的struct，含义对应C程序的机器指令，执行的过程就是引擎依次执行opcode，比如我们在PHP里定义一个变量:$a = 123;，最终到内核里执行就是malloc一块内存，然后把值写进去。\r\n\r\n所以PHP的解析过程任务就是将PHP代码转化为opcode数组，代码里的所有信息都保存在opcode中，然后将opcode数组交给zend引擎执行，opcode就是内核具体执行的命令，比如赋值、加减操作、函数调用等，每一条opcode都对应一个处理handle，这些handler是提前定义好的C函数。\r\n\r\n编译 PHP 代码，其实就是把 PHP 的代码转化成 Zend 引擎能识别的操作码（这里叫 opcode ）,每一条操作码都对应 Zend 引擎事先定义好的处理函数。执行编译后的 opcode ，就是在执行 Zend 引擎预定义的 C 函数。所以我们可以看到在一些场合下跑 PHP 的基准测试，速度飞快（甚至比 go、java还要快），原因就在于此。\r\n\r\n## 类的自动加载\r\n\r\n在实际使用中，通常会把一个类定义在一个文件中，然后使用时include加载进来，这样就带来一个问题：在每个文件的头部都需要包含一个长长的include列表，而且当文件名称修改时也需要把每个引用的地方都改一遍，另外前面我们也介绍过，原则上父类需要在子类定义之前定义，当存在大量类时很难得到保证，因此PHP提供了一种类的自动加载机制，当使用未被定义的类时自动调用类加载器将类加载进来，方便类的同一管理。\r\n\r\n在内核实现上类的自动加载实际就是定义了一个钩子函数，实例化类时如果在EG(class_table)中没有找到对应的类则会调用这个钩子函数，调用完以后再重新查找一次。这个钩子函数保存在EG(autoload_func)中。\r\n\r\nPHP中提供了两种方式实现自动加载：\r\n\r\n```\r\n__autoload()\r\nspl_autoload_register()。\r\n```\r\n\r\n```\r\n__autoload():这种方式比较简单，用户自定义一个__autoload()函数即可，参数是类名，当实例化一个类是如果没有找到这个类则会查找用户是否定义了__autoload()函数，如果定义了则调用此函数\r\n```\r\n\r\n```\r\nspl_autoload_register():相比__autoload()只能定义一个加载器，spl_autoload_register()提供了更加灵活的注册方式，可以支持任意数量的加载器，比如第三方库加载规则不可能保持一致，这样就可以通过此函数注册自己的加载器了，在实现上spl创建了一个队列来保存用户注册的加载器，然后定义了一个spl_autoload函数到EG(autoload_func)，当找不到类时内核回调spl_autoload，这个函数再依次调用用户注册的加载器，没调用一个重新检查下查找的类是否在EG(class_table)中已经注册，仍找不到的话继续调用下一个加载器，直到类成功注册为止。\r\n```\r\n\r\n```\r\nbool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )\r\n参数$autoload_function为加载器，可以是函数名，\r\n第2个参数$throw用于设置autoload_function 无法成功注册时，\r\nspl_autoload_register()是否抛出异常，\r\n最后一个参数如果为true时spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。\r\n```\r\n\r\n我们用 PHP 代码实现的自动加载类，本质上就是 Zend 引擎调用钩子函数，钩子函数去调用我们注册的 __autoload() 或者 spl_autoload_register() 方法的过程，每调用完成一次，就去检查class_table中该方法是否被注册，直到注册成功或者调用全部方法完成之后停止。\r\n\r\n所以当我们使用spl_autoload_register() 注册了多个自动加载器，典型的如使用composer 引入了多个包之后，这个自动查找流程就会相对比较长（虽然还是会很快）。\r\n\r\n## 线程安全\r\n\r\n在C语言中声明在任何函数之外的变量为全局变量，全局变量为各线程共享，不同的线程引用同一地址空间，如果一个线程修改了全局变量就会影响所有的线程。所以线程安全是指多线程环境下如何安全的获取公共资源。\r\n\r\nPHP的SAPI多数是单线程环境，比如cli、fpm、cgi，每个进程只启动一个主线程，这种模式下是不存在线程安全问题的，但是也有多线程的环境，比如Apache，或用户自己嵌入PHP实现的环境，这种情况下就需要考虑线程安全的问题了，因为PHP中有很多全局变量，比如最常见的：EG、CG，如果多个线程共享同一个变量将会冲突，所以PHP为多线程的应用模型提供了一个安全机制：Zend线程安全(Zend Thread Safe, ZTS)。\r\n\r\nPHP中专门为解决线程安全的问题抽象出了一个线程安全资源管理器(Thread Safe Resource Mananger, TSRM)，实现原理比较简单：既然共用资源这么困难那么就干脆不共用，各线程不再共享同一份全局变量，而是各复制一份，使用数据时各线程各取自己的副本，互不干扰。\r\n\r\n我们下载 PHP 扩展的时候，经常会看到 NTS TS字样的扩展标识，它就是上述线程不安全和安全的意思。一般情况下搭配Nginx的就是 NTS，Apache的是 TS。命令行是NTS.\r\n\r\n## 扩展的钩子函数\r\nPHP为扩展提供了5个钩子函数，PHP执行到不同阶段时回调各个扩展定义的钩子函数，扩展可以通过这些钩子函数介入到PHP生命周期的不同阶段中去\r\n\r\n这几个钩子函数执行的先后顺序：\r\n```\r\nmodule startup -> request startup -> 编译、执行 -> request shutdown -> post deactivate -> module shutdown。\r\n```\r\nmodule_startup_func:这个函数在PHP模块初始化阶段执行，通常情况下，此过程只会在SAPI启动后执行一次。这个阶段可以进行内部类的注册，如果你的扩展提供了类就可以在此函数中完成注册；除了类还可以在此函数中注册扩展定义的常量；另外，扩展可以在此阶段覆盖PHP编译、执行的两个函数指针：zend_compile_file、zend_execute_ex，从而可以接管PHP的编译、执行，opcache的实现原理就是替换了zend_compile_file，从而使得PHP编译时调用的是opcache自己定义的编译函数，对编译后的结果进行缓存。\r\n\r\n大名鼎鼎的 C 扩展应用框架Cphalcon就是在这步初始化自身的，从而保持框架在内存中，在之后的运行过程不会再耗费额外的解析编译资源。\r\n\r\n鸟哥的 Yaf 、 Yac，查询IP归属的GeoIP也是如此。\r\n\r\nrequest_startup_func:此函数在编译、执行之前回调，fpm模式下每一个http请求就是一个request，脚本执行前将首先执行这个函数。如果你的扩展需要针对每一个请求进行处理则可以设置这个函数，如：对请求进行filter、根据请求ip获取所在城市、对请求/返回数据加解密等。\r\n\r\nrequest_shutdown_func:这个函数比较特殊，一般很少会用到，实际它也是在请求结束之后调用的，它比request_shutdown_func更晚执行\r\n\r\nmodule_shutdown_func:模块关闭阶段回调的函数，与module_startup_func对应，此阶段主要可以进行一些资源的清理', '1', '1', '2019-01-14 20:03:28', '2019-01-14 20:03:28');
INSERT INTO `posts` VALUES ('32', '14', '0', '39', '2-大脑的工作原理', '大脑是我的一切，华生。身体只是附件而已。  ——阿瑟·柯南·道尔，《福尔摩斯探案集》\r\n', '```\r\n大脑是我的一切，华生。身体只是附件而已。 ——阿瑟·柯南·道尔，《福尔摩斯探案集》\r\n```\r\n在这一章里，我擅自把大脑分成两个不同的部分——潜意识部分和意识部分。\r\n\r\n大脑由许多部分组成，远比这种分法更复杂，但对我们的目的来说，这种分法已经足够了。\r\n请你把接下来的观点渗透到大脑最深处，永久保存在那里，请记住：\r\n```\r\n重复就是（潜意识）大脑使用的语言。\r\n多重复几遍，就不会忘记。这是最初也是最后一个关于大脑的笑话。\r\n```\r\n建立习惯的目标是用重复来改变大脑。可是大脑会抗拒改变，除非它们能大方地给大\r\n脑一些回报。因此，从大脑的角度看，在事实上改变习惯的两个关键是重复和回报。\r\n```\r\n如果有回报，大脑会更愿意重复一件事。\r\n```\r\n\r\n你有没有开过不带转向助力装置的汽车？\r\n\r\n方向盘转了好几圈，车的反应却很小。大脑对改变的反应就像不带转向助力装置的汽车一样。每次重复产生的作用可以忽略不计，可是如果不断重复下去，这些微小的变化会给大脑（和生活）带来巨大的改变。潜意识大脑喜欢效率，这就是我们能养成习惯的原因。\r\n\r\n当你重复某个行为一段时间后，大脑就能自动完成这个过程了。比起每次都要有意识地进行权衡和选择再决定以同样的方式行动，这种做法更节能。\r\n\r\n如果你快速地做出了决定，即使你认为自己在主动思考，很可能还是习惯在起作用。从某种程度上说，你之前就已经做出了决定。选自己最喜欢的冰淇淋口味就是一个例子。\r\n\r\n## 变化缓慢、状态稳定的大脑\r\n\r\n人类大脑很稳定，不易改变。\r\n\r\n它有一套对外部世界做出反应的固定体系。\r\n\r\n有一个不易改变的大脑有时会让人感到沮丧，可总体上说，好处还是相当多的。\r\n\r\n试想如果你的人格和生活习惯能一天变一个样会如何——你肯定会发疯的！\r\n\r\n一旦你成功养成健康的新习惯，一切都会变得轻松起来。每天早上自动起床，吃一顿\r\n健康的早餐，然后去健身，而不是和大脑持久战斗。付出很少的努力就能做正确的事情，这对于许多人来说可望而不可即，因为他们只能看到这种稳定性的阴暗面：大脑如何强迫他们吃垃圾食品、看电视、抽烟和咬指甲。但是，坏习惯有多可怕，好习惯就有多神奇。\r\n\r\n我的身份因为锻炼而改变了，所以我知道，它是一个适合我的习惯。如果我没有每周\r\n去几次健身房，会感觉哪里不对劲，觉得自己都不像自己了，可去年我还是个勉强保持正常体形的懒汉呢。这两种情况都是习惯导致的。\r\n\r\n**我们的行为中有 45% 是自动完成、无须思考的，既然如此，最好能让它们对我们的生活和目标有所帮助。为了能专业地实现这一点，我们需要认识大脑里的两个核心角色**。\r\n\r\n## 愚蠢的重复者与聪明的管理者\r\n你大脑中绝大部分是愚蠢的。好吧，确切地说，不只是你一个人的大脑——你抽烟的\r\n时候，它不会考虑到肺癌的可能性，你锻炼之前，它也不会幻想漂亮腹肌的好处，从这个意义上看，每个人类大脑的某一个部分都是愚蠢的。更糟糕的是，它是大脑里比较顽固的部分，会找到长期维持这种状态的方法。它会识别并重复模式，直到接收到不同的新指令。它的名字叫作基底神经节。\r\n\r\n然而，大脑的另一个区域前额皮层则相当聪明。它就在前额的后面，是个可以理解长\r\n远利益和结果的管理者，感谢上天，它拥有抑制基底神经节的能力。它还负责处理短期思维和决策。\r\n\r\n刚才我们已经讲到了习惯改变中的两个关键工具——基底神经节和前额皮层。我很认\r\n同心理学家大卫·诺维尔（David Nowell）博士总结前额皮层和大脑其他部分区别的方式，他表示，前额皮层以外的其他所有部分决定“是什么”，而前额皮层主要决定“可能有什么”。\r\n\r\n让大脑的其他部分喜欢上前额皮层想要的东西，是建立新习惯的唯一方式。是前额皮\r\n层在抵抗巧克力蛋糕的诱惑（但愿真能抵抗住），想学法语，希望身体健康，希望有一天能写一本书。它是大脑的意识部分，你会把这部分看作“你”。可问题是，它容易疲劳。也许更准确地说，因为它的功能太过强大，所以会消耗太多精力，让你感到疲劳。而且当你疲劳时（或者像之前说的那样有压力时），掌管重复的部分就会接管大脑。\r\n\r\n基底神经节意识不到只有人类才有的高层次目标，但是它可以高效率地重复模式，节\r\n省精力。所以，即使不像前额皮层那样“聪明”，它对大脑也有令人难以置信的重要性。而且一旦我们训练基底神经节自动完成积极行为，我们真的会爱上这种感觉。\r\n\r\n我们每个人的大脑里都运行着这种机制。刚开始，它的设计听起来并不合理——聪明\r\n的前额皮层不如没有思想、一味重复的基底神经节有毅力，可是一旦你学会如何运用它，这个设计事实上相当巧妙。聪明的弱者怎么能打败愚蠢但强大的对手呢？给你个提示——不要靠蛮力。这一点你肯定已经知道了，也许因为你回想起了自己想靠蛮力或意志力让意识控制潜意识的失败经历。\r\n\r\n答案当然是运用聪明的策略来克服前额皮层天生的弱点。前额皮层——对抗自动行为的防御武器为了更好地了解前额皮层，我们先看看如果缺少了它会怎样。没有前额皮层，大脑会如何运转呢？不太乐观。下面的这项研究展现了前额皮层和大脑其他部分的功能。\r\n\r\n你去掉某个部件后，就会看到它的功能有多大影响，以及没有它存在时其他部分是如何运转的。\r\n\r\n法国神经学家弗朗索瓦·莱尔米特（Francois Lhermitte）对额叶受损的患者进行了测试。他在以下研究中证明，如果缺少了额叶的一部分、作为“管理者”的前额皮层，大脑的运转方式会发生极大的变化。\r\n\r\n莱尔米特的研究选取了两组人群做对比——额叶受损者和额叶正常者。实验中，被试\r\n坐在实验人员对面，问一些面试风格的问题。实验人员负责对被试的问题表现出冷漠，不回答他们的问题，偶尔随意做出一些让人疑惑不解的动作，比如摸一下鼻子、敬个军礼、折纸然后放到信封里、嚼纸、唱歌、拍腿和抽泣等。\r\n\r\n研究人员有如下发现。正如我们所料，额叶正常的被试觉得实验人员的行为很古怪，\r\n他们的反应是：“这家伙有什么毛病？”许多年轻的参与者甚至哈哈大笑。当被问到他们有没有想过模仿他时，他们说：“没有，根本没有。”\r\n\r\n接下来就更有意思了。几乎所有额叶受损的被试都模仿了实验人员的荒唐动作——而\r\n且相当精确和到位。比如，男人们会心甘情愿地当着其他人的面对着墙小便，没有表现出丝毫惊讶，也完全不在乎。他们无法准确模仿时（比如没有纸可以折或咀嚼），也会找到“完美的”弥补方法。\r\n\r\n以下内容摘自研究报告：“在实验过后的面谈中，所有额叶受损者都能记住实验人员\r\n的动作。当被问到为什么要模仿时，他们表示实验人员做了动作，他们就必须模仿。当被告知没有人让他们模仿这些动作时，他们的回答是既然动作已经做出，自己就必须模仿。在被告知不要模仿后，大多数患者还是表现出了同样的模仿行为。”那些额叶受损者忍不住要模仿实验人员的动作，哪怕有人要求他们不进行模仿。额叶\r\n受损者似乎无法做出某些决定来“抑制”潜意识。潜意识几乎就像另一个物体，或者一台机器一样。同样有趣的是，额叶正常的被试忘记了实验人员的一些动作，而额叶受损者能记住他们的每一个动作。这表明，正常额叶（包括前额皮层）削弱了我们对潜意识型认知的关注，而且能阻止或发起行为，这就是我们把它称作“管理者”的原因。它会监督自发行为，发现有能改进的地方时，它就会介入。现在我们来看看另一方面——如果基底神经节功能失常会怎样？\r\n\r\n## 基底神经节——模式探测器\r\n大脑的基底神经节从生理角度看是一组神经核，它们形成一个整体，在习惯的形成和\r\n程序性学习中起核心作用。\r\n\r\n但研究也指出，大脑的许多系统以复杂的方式相互作用，基底神经节未必能被单独看\r\n作“大脑的习惯部分”。神经科学虽然有助于我们理解大脑，但也无法完全准确解释大脑的工作机制。这不是说它有误导性或不准确，而是说它只给了我们看到一个巨大谜团的冰山一角的机会。大脑的工作机制太过错综复杂，现代科学还需要在很多方面展开探索。\r\n\r\n即便如此，知道基底神经节在习惯形成中起主导作用还是有用的。结合经验、实验以及充分的了解，我们对大脑工作机制的有限认识就会成为个人成长的强大助力。\r\n\r\n莱尔米特对额叶功能有障碍或受损人群的研究体现了大脑执行功能的重要性，有了它\r\n，我们才不会机械地做一些我们不愿意做的事情。可如果基底神经节受损或功能失常会怎样呢？关于这个问题也有一项研究，研究认为基底神经节受损或功能障碍会导致你丧失形成习惯的能力。\r\n\r\n研究人员召集了 3 类人群——健康人群、帕金森综合征患者和有记忆障碍的人群。由\r\n于细胞坏死，帕金森综合征患者的大脑很难把神经递质多巴胺运送到基底神经节，从而导致基底神经节功能障碍。\r\n\r\n参与者会拿到 4 张卡片，卡片上的图形是随机的，他们被要求预测每张卡片代表的是雨水还是阳光。人们很难有意识地在卡片和结果之间建立联系，但可以在潜意识中掌握某种微妙的联系模式。这项研究总共进行了 50 次测试，大约 10 次之后，健康的参与者和有记忆障碍的参与者都能逐渐提高猜测的准确率，从 50% 提高到 65%~70%；他们在潜意识中掌握了暗示雨水或阳光的模式。而帕金森综合征患者的准确率最终也没有超过  50%。因为不具备正常的基底神经节，他们的大脑无法探测到模式（因此，他们很难养成新习惯）。\r\n\r\n如果用最简单的术语表述，我们能从这些研究中看出，大脑是由执行决策和进行自动\r\n行为模式识别的两部分组成的系统。前额皮层的管理功能相当活跃，反应灵敏，但同时也消耗了大量的精力（和意志力）。基底神经节的自动功能不仅强大，而且效率\r\n高。\r\n\r\n它们能节省精力，无须持续监督就能处理各种任务。\r\n\r\n这就引出了下一个核心问题——我们该如何运用这两个大脑元件，才能让自己做任何\r\n事时都持之以恒呢？\r\n\r\n在行为变成习惯之前，激励你的两个途径是动力和意志力。在阅读下一章之前，最后\r\n一次和动力说再见吧，因为你再也不需要它了。', '1', '1', '2019-01-12 11:10:00', '2019-01-15 07:13:37');
INSERT INTO `posts` VALUES ('33', '14', '0', '39', '3-动力 v.s. 意志力', '情绪要么顺服你，要么支配你，这要看谁说了算。\r\n——吉米·罗恩', '```\r\n情绪要么顺服你，要么支配你，这要看谁说了算。  ——吉米·罗恩\r\n```\r\n我非常讨厌采用动力作为启动策略，动力和意志力不是非此即彼的，二者之间存在重\r\n要的关系。本章节的基本前提不是说有动力不好，而是如果想持久改变，动力并不是可靠的策略。\r\n\r\n现在你肯定想打断我，问“那微习惯哪儿去了”，在此之前，我需要一些时间说明一下。我做了一个简单的图来展示意志力和动力之间的关系，见图 3-1。\r\n![avatar](/public/img/posts/wxg_3.png)\r\n图 3-1 动力和意志力之间的关系\r\n\r\n说明：X 轴是动力，Y 轴是意志力消耗量。当动力处于峰值时（右下角），意志力消耗量为 0 或可忽略不计。这是因为你无须强迫自己做你本来就愿意做的事。可是当动力降为 0 时，强烈的内心抵触意味着意志力消耗量会变得很高（左上角，意志力消耗量为 100，动力为 0）。\r\n\r\n\r\n在意志力一章中，我们将进一步详细讨论这种关系，但目前你只需知道，当你做事缺\r\n乏动力时，意志力的消耗量就会猛涨。意志力消耗量较高时，你会难以长期维持一个行为并将其培养成习惯。\r\n\r\n接下来，我们要仔细审视一下“激发动力”策略。尽管完全无法保持长期有效，它却在心理自助书籍中占据了主流地位。\r\n\r\n## “激发动力”策略的诸多问题\r\n激发动力有效果吗？答案有时让人很恼火。你偶尔能激发出动力来锻炼身体或写 2000 字，可是下一次就未必了，也许你会打个盹，看一会儿电视，或喝杯啤酒。这可是个大问题，因为如果你的策略是“激发动力”，那么你就无法建立起习惯。\r\n我们都知道习惯的养成需要不断重复。在之前的研究中，参与者的大脑到第 10 次测试时才掌握了模式，而行为则需要更长时间才能获得认可。\r\n\r\n不要误解我的意思。动力是一种能带来诸多好处的重要感觉，但是当它出现时，请把\r\n它看作一个额外的奖励，一件美好的事物。我知道有些人目前依赖激发动力策略做事，那么这一章的目标就是说服你放弃该策略。我衷心希望你为了自己的利益放弃这个观念，现在让我来告诉你为什么。\r\n\r\n## 动力并不可靠\r\n\r\n动力之所以不可靠，是因为它以人的感受为基础，而人类的感受容易改变且无法预测已经是几百年来公认的事实了。很多东西都能改变你的感受：一次事件、血糖水平、抑郁、化学物质紊乱、荷尔蒙、健康、外界刺激、信仰甚至猫的呕吐物。换句话说，任何东西都能改变你的感受，你真的愿意把希望放在如此……不稳定的东西上吗？任何事物能成为基础的第一原则就是它必须牢固可靠，而“激发动力”策略就像是在液体上盖房子。\r\n\r\n每个人都有不在状态的时候，这时精力相对不足。这意味着你希望高效率办事的动力\r\n也会更低。“激发动力”策略劝我们依赖这些东西：励志视频、文章、给自己打气的话和其他能短期提升士气的方法。\r\n\r\n记住：如果选择“激发动力”策略，你不仅要有动力做一件事，还必须动力十足才行。\r\n\r\n因此，想要激发出锻炼的动力，你想锻炼的意愿必须比想吃薯条和看电视的意愿更强烈才行。在这种情况下，你尝试很多次才可能成功一次。\r\n\r\n那些对我们有益的事（吃生西蓝花，跑 13 公里，再吃更多的西蓝花）可不是简简单单激发动力就能完成的。和坐在沙发上看着电视吃冰淇淋相比，生西蓝花和锻炼的短期回报要逊色不少，我选择前者的动力明显高出很多。\r\n\r\n## 你不会每次都愿意激发动力\r\n\r\n成长动力学说的内容是这样的：如果我真心想做一件事，那么我无须强迫自己做这件\r\n事（也就是用意志力）。这么说其实没错，当你有动力时，做事很容易，也不需要太多意志力（如果有的话）。还记得这一章开头的图吗？当你的动力到达峰值时，意志力消耗量为 0 。乍看之下，这似乎是最佳方案，当你发现意志力是有限资源（后文会谈及）时会更加认同。因此，理论上说，动力相当值得拥有，可俗话说得好，“每朵玫瑰都有刺，不仅会扎你的手，还会让你疼得在侄子面前爆粗”，所以动力也有着不尽如人意的方面。\r\n\r\n问题在于，动力是很难（有时几乎不可能）按需培养的。只要看看你自己的经历就能\r\n证实这一点。当你累了，生病了，头疼，感觉“不在状态”或只想做一些更好玩的事情时，激发动力容易吗？如果你认为人类能仅仅根据利益改变内心的欲望，那么你就太不了解人类的感受有多强大、影响有多大了。我们很难靠想法来改变感受。只有在精力充沛、思维模式健康而且没有受到强烈诱惑时，我们才能依靠动力成功。可到该行动的时候，局面似乎远没有那么有利，我们就会决定“明天再做吧”。\r\n\r\n最近有一次，我感到很累，头也疼，没什么励志名言或想法能让我继续写这本书，我\r\n也不愿激发动力，只想睡觉。感谢上天，还好我不依赖动力。生活中总有那么几次，你不愿为了激发动力而激发动力。意思是（别嫌我唠叨）你根本不想让自己想让自己想锻炼。（没错，连续用了三个“想”！）这是为了帮你体会到如果选择以动力为基础的思维模式，你会有多难采取实施行动。你必须让自己想做一件事而不是直接做这件事，可有的时候，你积聚动力只是为了让自己有动力激发动力而已。这个过程和这句话一样怪异。如果你不愿意激发动力，而激发动力又是你做事的策略，那么战斗\r\n还没开始你就已经输了，你的习惯也会早早流产。\r\n\r\n有人习惯性地认为动力是行动的唯一基础有些心理自助书籍的作者只会照搬一切，他们把“激发动力”塑造成促进行动、改善生活的唯一途径，而很少会有人提出质疑，因为这是标准程序。人们纷纷登录励志网站寻找他们的“励志救星”，导致这些网站也跟着发展起来。\r\n\r\n我承认，“激发动力”是个比“什么都不做”更好的策略，但想做些什么并不难。\r\n\r\n举个例子，锻炼的预期效果可能有三种来源：动力、意志力或习惯。虽然每个行为都\r\n是动力和意志力结合后的产物，但我们往往会更依赖其中某一个。那么，一边努力激励自我，一边对自己说你无论如何都得做这件事（我们失败后总会这样），你不觉得这自相矛盾吗？\r\n\r\n坚信必须有动力才能行动是一种毁灭性的习惯。如果只是“我想激发动力”，那它就不成问题；可是如果不激发动力就什么都做不了，那它就是个问题。它是坠入“懒惰旋涡”的完美路线。懒惰会让你感到什么都不想干，如果你总是在什么都不想干的同时奉行动力法则，那你就会一直懒下去，没有出路。\r\n\r\n“动力高于行动”的观念是深入人心的，可没有谁规定你的感受和行为必须永远匹配。\r\n\r\n它创造了一种让你处处受限、时刻受挫的生活方式。\r\n\r\n## “热情递减法则”是动力让我们失败的原因\r\n\r\n好吧，假设你能激发动力每天阅读 2 小时，而且能连续坚持 3 周。到这个时候，你可能会看到行动变成习惯的微弱苗头了。可是因为你一直依赖动力，这个关键过渡期很可能就成了进步的终点。\r\n\r\n“热情递减法则”不是一条真正的法则，而是我创造的术语，因为它比对应的经济法则“边际效用递减法则”（The Law of Diminishing Marginal Utility）更好理解。\r\n\r\n这条经济法则认为，吃第五块比萨时的愉悦感会略低于吃第四块时的，吃第四块时的又略低于吃第三块时的。我们在进行重复行为时也存在同样的现象。\r\n当一种行为成为一个习惯，你会变得没有刚开始时那么情绪高涨，这种行为甚至开始\r\n有些乏味无聊。事情当然会变成这样了。杰里米·迪安（Jeremy Dean）在《习惯:改变命运的关键力量》（Making Habits，Breaking Habits ）中写道：“习惯不仅无法被认知捕捉到，而且也不会掺杂情绪。……很奇怪，人们进行习惯行为时是不带有情绪的。”温迪·伍德博士及其同事们在德克萨斯农工大学进行的一项研究中记录了这样的情况：当参与者做出惯性行为时，毫无疑问，他们比平时更缺乏情绪变化。  \r\n\r\n这就是“需要动力才能行动”的想\r\n法在培养习惯时反而会帮倒忙的原因。重复不会让我们兴奋地行动起来，反而会让我们趋于平静。习惯带来的好处在于抵触情绪少了，自发性多了。迪安表示：“惯性行为不会引发强烈情绪，这是它的一大优势。”的确是这样，因为任何依赖人类情感的东西都是完全不可靠的。\r\n\r\n刚开始做一件事的兴奋在最初会有很大帮助，可是等到这股劲头渐渐消失，你开始怀\r\n疑有什么地方出了什么问题的时候，它又会成为强大的敌人。如果最开始就选择不依赖动力和感受，就能有效降低这种风险。\r\n\r\n有热情是好事，但我们应该把这种思维模式看作一种额外奖励，而不是实施行动的信\r\n号。最好因为选择做一件事而做一件事，这样才能为成功打下坚实的基础，成效不会在之后出现剧烈波动。说句似乎有违常理的话：在一段时间过后出现热情不足的情况其实是个积极的信号，表明更稳定和自动的基底神经节正在慢慢夺取控制权。\r\n为什么有这么多人 1 月刚过就中断了新一年的健身计划？这种可预见的热情递减就是原因之一。尽管已经成功锻炼了一阵，他们会注意到自己心中不再充满动力，然后就会放弃。\r\n\r\n如果他们明白动力不足的原因，也许就会重拾信心，继续下去。\r\n\r\n作为一种主流策略，也许动力在日常生活中勉强够用（或许吧），可是和意志力一比\r\n就会逊色不少。\r\n\r\n虽然意志力是最佳策略，可是大多数人并不知道该怎么运用，结果意志力储备很快就\r\n消耗光了。\r\n\r\n虽然我已经说了这么多，但你不用担心，你还可以充分享受原来的生活方式。你依然\r\n是个有感情的人类。我可不是让你放弃感受，而是希望你不要再因为感受而放弃。\r\n \r\n## 为什么意志力能打败动力？\r\n我在上面抨击了“激发动力”策略的缺点，接下来我却要教你怎样获得更多动力，这是不是前后矛盾？不，我不喜欢动力不是因为它不好。例如，为了写出这些文字，我需要最基本的动力，但动力论到处都是，人们将其伪装成个人成长的秘方，虽然这不是它本身的错。这就好像我告诉你胡萝卜能治愈癌症一样，胡萝卜的确对你有益，但它不可能治好任何得癌症的人，于是，这个好东西（胡萝卜）已经被塑造成了真理的敌人，在到处招摇撞骗。这么看来，动力是一根邪恶的胡萝卜。\r\n\r\n微习惯的意志力策略能帮助人们提升动力。再重申一遍，动力是好东西，只是不可靠\r\n而已。我发现，借助意志力，动力会变得更加可靠；而且如果先采取行动，动力就会被迅速地激发。为什么强迫自己用意志力采取行动远比努力激发动力好呢？原因有三个。\r\n\r\n## 意志力很可靠\r\n和动力不一样，意志力极其可靠。如果你能强迫自己做到某件事，无论是什么事，这\r\n种成功都会体现意志力的可靠性，当然，前提是你能强迫自己成功做到。恰好，意志力还有两个让它更可靠的优点。\r\n\r\n## 意志力可以被强化\r\n和动力不一样，意志力可以像肌肉一样得到强化。1999 年，自控力研究领域的顶尖\r\n学者罗伊·鲍迈斯特（Roy Baumeister）发现：和没有进行健身的学生相比，那些花两周时间磨炼意志力以改善体形的学生“在随后的自控力测试中有显著的进步”。\r\n\r\n另有一项研究发现：两个月的有氧运动训练为其他不相关领域内需要自控力的活动带来了进步。\r\n\r\n可见，意志力真是自我提高的不二法门。这些研究表明，我们能通过强化特定的能力\r\n来提高自己的表现。\r\n\r\n如果某种东西最开始无效，接下来也无效，那么进步就只能依靠不断尝试了。动力偶\r\n尔才会产生效果，所以很难评估，对动力策略的长远结果做一番审视，你可能会发现它并不是每次都会奏效。动力也不会轻易改善，因为如果你的狗病死了，你会情绪崩溃，或者你累了或者情绪很差时也会不想锻炼。与此相反的是，你却能提高克服可能来自感情创伤、缺乏自信、情绪糟糕或者精力不足的抵触情绪，进而采取行动的能力，这种能力就是意志力。\r\n\r\n## 意志力策略可以通过计划执行\r\n\r\n如果你依赖动力，严格执行时间计划是很困难的。谁知道你到该写作时究竟有没有动\r\n力呢？动力无法预测，所以不适合制订计划。\r\n \r\n相反，如果运用意志力，你可以给某项活动安排一个时间表。不管到时候有没有足够\r\n动力，你都可以顺利完成，这样就容易坚持下去，既有利于习惯养成，也有利于时间安排。一个在能写作的时候才写作、非要等到出现奇迹时才起身锻炼的笼统计划是无法帮你养成习惯的，你必须给任务制定时间表，然后实施行动。这就要求你拥有意志力。\r\n\r\n还是那个核心问题——我们该怎样运用意志力来保证长久的成功呢？要回答这个问题\r\n，我们需要总结一些关于意志力的科学知识，再从中找到答案。\r\n\r\n## 意志力的工作原理\r\n人们曾认为意志力能给我们提供取之不尽、用之不竭的意志。具体观点是：只要想得\r\n到某个东西的愿望足够强烈，你就一直会有足够的意志力促使自己得到它。鲍迈斯特在 1996 年进行了一项多少有些残酷的研究，纠正了这个观点。实验开始时，一个房间里有 67个被试，很快，房间里就弥漫着现烤的巧克力曲奇诱人的香味，随后，有人把曲奇和其他巧克力做的点心拿了进来。接下来，残忍的折磨就开始了——只有一部分被试可以得到巧克力，其他人的零食只有萝卜！即使我很爱吃生萝卜，我也能感受到他们的痛苦。\r\n\r\n研究人员幽默地记录道，在吃萝卜的人中，有好几位对巧克力有明显的兴趣，他们渴\r\n望地看着巧克力，有几个人还拿起饼干使劲闻了闻。我说得没错吧？这真是个残酷的实验。\r\n\r\n之后，吃巧克力和吃萝卜的被试同样要解答一个难题。在尝试答题所花的时间方面，\r\n吃萝卜组连吃巧克力组的一半都不到，而且在最终放弃之前尝试的次数也更少。没吃到巧克力而只能吃萝卜似乎耗尽了他们继续努力解答难题的意志。鲍迈斯特把这种现象命名为“自我损耗”（ego depletion）。迄今已有多项研究验证了这项突破性研究的结论。\r\n\r\n## 做决定也会消耗意志力\r\n别光责备萝卜。一项自控力研究发现：在同一天里做过艰难决定的人在后来面对诱惑\r\n时屈服的可能性更高，这体现了自控力的下降。重大决定和意志力似乎需要消耗同样的能量。前额皮层负责处理短期记忆和即时思维，所以我猜想，任何使用前额皮层的行为都会\r\n\r\n产生这样的效应，但你可不要因此就认为做艰难决定会对当天晚些时候你抵抗冰淇淋的诱惑或强迫自己锻炼的能力产生负面影响。\r\n\r\n我们能从中得出一个结论——必须把自控力的储备量最大化，这样才能在改变自己时\r\n起作用。我专门说到这一点，是为了体现其他事情是怎么消耗意志力储备量的，这会让微习惯背后的原理显得更加重要。\r\n\r\n一项重要的意志力元分析元分析是从指定主题的相关文献中提取出重要结论的过程，可以说是“对研究的研究”，它有助于消除个体研究中出现的偏差。如果一个理论在历经众多方法得当的研究和数以千计的被试的检验后依然成立，那么其数据很可能是有用的、可靠的，而且具有启发性。\r\n\r\n2010 年，研究人员针对 87 项自我损耗研究进行了一次元分析（自我损耗本质上和意志力损耗或自控力损耗是同一个概念，所以我会交替使用这些术语）。这项元分析发现了引起自我损耗的 5 个最重要的因素：努力程度、感知难度、消极情绪、主观疲劳和血糖水平。\r\n\r\n所以，这些因素就是我们运用基于意志力的策略取得持续成功的 5 个最大的障碍。意志力全部耗尽后我们该做什么？此时就没有任何希望了吗？根据这项研究，动力激励、自控力任务训练以及补充血糖等做法能提升自我损耗人群的自控力。\r\n\r\n这对我们非常有帮助，教会了我们管控意志力的最佳方法。下面是对动力和意志力重\r\n点内容的一次关键总结，掌握了这些内容，我们就可以进入下一章，学习微习惯策略，给生活增添健康习惯了。\r\n```\r\n● 我们是用动力或意志力开启新的（非习惯性）行为的。\r\n● 动力不可靠，所以不能充当建立习惯的策略。\r\n● 意志力可靠，但前提是你没有把它耗尽。\r\n● 引起意志力损耗的 5 大主要因素：努力程度、感知难度、消极情绪、主观疲劳和血糖水平。\r\n● 如果我们能成功克服这 5 项障碍，我们就应该能走向成功。\r\n```\r\n在下一章里，我们会探讨微习惯如何适用于前文提到的全部内容，先从引起意志力损\r\n耗的 5 大主要因素说起。', '1', '1', '2019-01-13 11:11:00', '2019-01-15 07:31:55');
INSERT INTO `posts` VALUES ('34', '14', '0', '39', '4-微习惯策略', '塑造你生活的不是你偶尔做的一两件事，而是你一贯坚持做的事。 ——安东尼·罗宾', '```\r\n塑造你生活的不是你偶尔做的一两件事，而是你一贯坚持做的事。  ——安东尼·罗宾\r\n```\r\n微习惯策略就是强迫你自己每天实施 1 到 4 个“小得不可思议”的计划好的行动。\r\n\r\n这些行动小到不会失败，小到不会因为特殊情况就被你轻易放弃。\r\n\r\n它们有双重作用——激励你继续做下去，并会成为（微）习惯。\r\n\r\n现在，我们来看看微习惯策略是如何广泛应用我们目前学到的原理的。至于微习惯策\r\n略要如何一步步操作，本章后的两章将进行说明。\r\n\r\n## 以微习惯方式运用意志力\r\n曾经有一项自我损耗研究发现了“认为意志力有限”和“意志力变得有限”之间的关联。\r\n\r\n在涉及自我损耗的活动中，那些认为自己拥有无限意志力的人似乎坚持得更久。最初，这个发现看似是对微习惯的一种打击，因为微习惯是基于“意志力有限”这个假设（参考元分析的结果）而设计的。我会说明为什么这两种情况对微习惯都没有影响。\r\n\r\n如果意志力确实是有限的，那么从微小目标开始行动的微习惯确实能起到保存意志力\r\n的作用，可如果意志力只是被“意志力有限”这种想法限制住了呢？\r\n\r\n这对微习惯意味着什么？绝对是大好消息！因为微习惯几乎不会消耗意志力，所以采用微习惯的方法，你便会拥有无穷无尽的意志力。因此，当你的意志力储备充足时，微习惯策略会让你开始行动，能帮你获得额外进步。当你彻底精疲力竭、意志力耗尽时，微习惯策略在任何情况下都能让你采取行动，帮你把当时的能力发挥到最佳水平。它的理论本身就包括“无论在什么情况下都能让你行动起来”这种信念，从来没有让我失望过。我还从未遇到过意志力连完成一个微习惯行为都不够的情况。\r\n\r\n前文提到，针对 87 项研究的元分析发现了自我损耗的 5 大原因，现在我想再强调一遍，已发现的自我损耗 5 大原因是（排名不分先后）：\r\n```\r\n● 努力程度\r\n● 感知难度\r\n● 消极情绪\r\n● 主观疲劳\r\n● 血糖水平\r\n```\r\n我们来仔细看看微习惯是怎样彻底或有效消除意志力这 5 大威胁的。\r\n\r\n## 努力程度\r\n微习惯需要非常少的实际努力。比如，你打算做一个俯卧撑，写 50 字，阅读 2 页书，或完成其他非常简单的任务。任务完成后的超额努力每次都不一样，也就是说有时产出会更高，有时则会相对低一些，这是一种能有效降低精力耗尽的可能性的自然体系。我经常计划写 50 字，最终却写出了 2000 字；在其他时候，字数更接近 50 字，刚好能完成要求。\r\n\r\n从战略角度看，微习惯策略既严格又灵活。刚开始它很严格，会强迫你开始行动，之\r\n后会变得充满弹性，让你自行决定想超额完成多少。最初的尝试几乎不需要什么意志力就能成功。\r\n\r\n采用微习惯策略的结果：自我损耗极少。\r\n\r\n## 感知难度\r\n微习惯的本质决定它几乎不会让你在还没做的时候就感到困难，这个重要的优点在你\r\n超额完成任务时更为显著。还记得我之前说过的吗？30 分钟锻炼就像一座高山一样。\r\n\r\n那次锻炼的感知难度很高——我感觉到的困难比实际的大得多。可是，当我决定以一个俯卧撑开始，然后再以同样的方式继续时，感知难度显著下降了。在任何计划中，设定微目标都是降低感知难度的最佳方式。\r\n\r\n一旦你开始做且能随心所欲地继续下去，“已经开始”带来的心理影响会让感知难度明显降低。正如从物理学角度看，物体的惯性在运动开始前最大，一旦物体处于运动状态，因为存在动量（而且动力也增长了），一切都会变得简单。\r\n\r\n即使是从做小事开始，你也会有脚踏实地的感觉，这一点很重要。在你行动之前，大\r\n脑只能想象某个行为会是什么样的，按我最初的推测，30 分钟锻炼就像攀登珠峰一样艰难，实际上并非如此。当一项活动需要脑力或者体力时，高估其难度是很正常的。\r\n\r\n我从 1个俯卧撑开始，最终完成了 30 分钟锻炼，之后才意识到自己最初的感知难度是多么离谱。\r\n\r\n采用微习惯策略的结果：自我损耗极少（即使在完成预定目标后继续前进的过程中）\r\n。\r\n\r\n开始行动的理由是最难找到的，因为目标的重量造成了巨大的压力。而一旦开始，我们会觉得似乎需要达到最初的目标才算得上成功，这就是我们不愿意启动那些让我们闻之色变的计划的原因。\r\n\r\n如果最终做不到，我们宁可不开始。所以，采用微习惯策略就简单多了，因为我们的目标太小，根本不存在过早放弃的风险。从小任务做起，然后接受做这件事的现实，你便会发现小小的一步并没有刚开始想的那么难，也会发现继续下去也不难。\r\n \r\n## 消极情绪\r\n消极情绪指的就是不愉快的感觉体验。在那项巧克力和萝卜实验中，它起到了明显的\r\n作用。参与者先是被巧克力的外表和味道所诱惑，结果只吃到了不太想要的萝卜。受到了巧克力的诱惑，却一口都吃不到，这就是一种非常消极的情绪，甚至比我们想的更消极。（试想有人向你展示了曲奇后就把它拿走了，这可太过分了！）因为微习惯的目的是为人生增添美好事物，所以它和消极情绪的关系不大，除非你的行为直接取代了一件让你开心的事情，比如，吃萝卜本身不会损耗意志力，可是和巧克力摆在一起时就不一样了。\r\n\r\n采用微习惯策略的结果：一般不会产生自我损耗。即使微习惯取代了一件令你开心的\r\n事情，你要做的努力也太少了，少到你根本不会感觉到任何消极情绪。通常情况下，你会用有益的行为取代浪费时间的行为，这个过程本身就会带来积极情绪。\r\n\r\n## 主观疲劳\r\n这个因素很有意思，它没有直接说疲劳，而是说主观疲劳，意思是我们在评估自己的\r\n疲劳程度时并不是完全客观的。事实上，意志力就是思想的战斗，而且根据这些最容易消耗意志力的因素看，这种战斗似乎与你根据任务投入的力量多少有关。\r\n\r\n还好微习惯只会引起微量的主观疲劳。主观疲劳与很多因素有关，其中一个主要因素\r\n就是你如何看待自己与目标之间的斗争。我发现如果我的目标很高，主观疲劳就会更严重，这很合乎逻辑，因为思维会“预判”接下来的工作，而且会早早感受到压迫。近期的一项研究发现，人类的想象力非常强，甚至会改变我们在现实世界中看到和听到的内容。所以对工作量很重的认知也会影响精力水平，这种说法一点儿也不夸张。这次元分析的研究人员也支持该观点，他们记录道：“对接下来的自我控制行为的意识加剧了（自我损耗）效应。”我发现，当我设定的目标只是 1 个俯卧撑时，我感受到的主观疲劳明显减退了。\r\n\r\n事实上，我感觉自己有充足的能量完成 1 个俯卧撑，而且这种“轻易就能做成一件事”的想法，哪怕是很小的事，也能让我的能量更充足。\r\n\r\n采用微习惯策略的结果：主观疲劳无法彻底消除，但是微习惯可以有效缓解主观疲劳\r\n。一想到你的微目标，你就会感到精力充沛，而且会有一种能量涌现的感觉。甚至当我（主观感到）疲惫不堪时，我仍感觉有足够精力阅读 2 页书或写 50 字。如果你对只做这么一点儿事的意义还心存疑惑，那我可以告诉你，它的价值相当高，后文会详细探讨。\r\n\r\n##血糖水平\r\n葡萄糖是人体首要的能量来源。如果血液中葡萄糖含量变低，你会感觉疲惫。如果低\r\n到危险水平，你甚至可能晕倒。血糖水平是由遗传因素、饮食和生活方式共同决定的。\r\n\r\n微习惯和血糖相互独立，但因为微习惯策略是使用意志力能量的方法中效率最高的，\r\n所以它有助于保留血糖量。如果把一件大工程拆分成“精神上容易消化”而且不会造成压力的小工程，精神能量的利用效率会大大提高。如果制定一年减掉 50 千克的目标，它会变成负担，不断消耗你的能量。就算你减掉了 25 千克，跟这样的目标一比，还是会感觉自己失败了。怎么会有人喜欢这种方式呢？在你订立的目标宏大的计划中，一次锻炼只是沧海一粟，跟你的目标相比算不上什么，所以做完一次锻炼后很难收获好心情。\r\n\r\n然而，如果采用微习惯策略，你会尽可能多地保存意志力，迈出的每一步都会带来成功的感觉，一旦超越了目标，当然会感觉更棒。它正是这样一种让你觉得自己像个成功者的体系，因为一旦你觉得自己像个成功者，你的行为也会向成功者靠拢。\r\n\r\n采用微习惯策略的结果：虽然血糖水平和微习惯相对独立，但微习惯的确会节约能量\r\n和意志力，而且会在心理上不断给予你能量，所以它可以在最大程度上保留血糖。在你因为血糖低而感觉疲劳时，最有可能让你行动起来的就是微习惯。\r\n\r\n## 微习惯如何拓宽你的舒适区\r\n你现在有一个心理舒适区（comfort zone），把它想象成一个圆圈。在圆圈里时你感觉最舒适，而圆圈外是你想达到的目标。你可能会看到圆圈外的自己身材变得健壮了、体重减轻了，也许会想象圆圈外的你写完或读完了某本书，也许会看到自己的消极思想更少、更加幸福，或者更常在家做饭，或者看到你感兴趣的一切都在趋于完美。\r\n\r\n因为这些目标都要在经历不舒适的过程后才能实现（因为偏离了基底神经节目前的程序），所以它们都在舒适区外。\r\n\r\n通常人们处理此类变化的方式是投入，采取“只要能成功怎么做都行”的策略。这就好像你全力冲刺到舒适区外面，拼命挣扎着想留在那里，这时你的潜意识就会说，“有意思，可这么剧烈的变化真让我不舒服”，然后，当你的动力和意志力不足以支撑你停留在那里时，潜意识就强迫你回到圆圈里面。\r\n\r\n而微习惯策略就像走到圆圈的边缘，然后向外迈出一步。这是一个相对不舒适的地方\r\n，但因为你知道走一步就可以回到舒适区里，所以差别不会很明显。也许在前几次尝试时，你可能会退回舒适区里（在只实现了微目标后）。可当你继续向圆圈外走去时，你的潜意识就会逐渐适应，接下来你的圆圈就会拓宽（我指的是微习惯开始形成）。\r\n\r\n与前面例子中的全力冲刺不一样，这种拓宽能永久改变你的舒适区的界线，靠的是微习惯的力量。我希望你在向外迈出第一步后有继续向外探索的强烈冲动，即使你没有这样的冲动，最终也会养成向新行为迈出第一步的愉快习惯。在该领域，它可以充当进一步行动和个人成长的最佳基础。\r\n\r\n以俯卧撑为例，微习惯策略通常的目标是每天做 1 个。你不仅会适应做 1 个俯卧撑的想法，而且总体来看，你会更适应做俯卧撑这项运动，适应每天做若干个俯卧撑的行为，所以这一小步带来的影响比你预想的要大得多。这样一来，逐步加大运动量就会变得非常轻松。的确如此。运用微习惯策略，最糟糕的情况也只是没有超额完成目标而已。\r\n\r\n你偶尔可能会超额完成目标，这种现象的原因可用基础物理学知识来解释。牛顿第一\r\n运动定律的内容包括：\r\n```\r\n1. 除非受到外力作用，否则静止的物体总保持静止状态。\r\n2. 除非受到外力作用，否则处于运动状态中的物体的速度不会改变。\r\n```\r\n你能看出其中的联系吗？一旦你迈出了第一步，就算处于运动状态中了。你会像我一\r\n \r\n样发现正如牛顿（物理学）的运动定律所示，一旦开始做就很难停下，当然，保持前进的难度也很大。此外，没有什么比亲眼看到自己采取行动更能激励和鼓舞自己的了。把所有这些融会贯通，我们就得到了一个新等式：\r\n```\r\n一小步＋想做的事＝较高的进一步行动的可能性\r\n```\r\n出现阻力的两个时间节点我住在弗吉尼亚时养了一只猫。到了下雪天，我们当然想看看这只在室内长大的猫会不会喜欢雪。\r\n\r\n猫都不喜欢水，可是它们会喜欢蓬松、结冰的水吗？答案是否定的。\r\n\r\n第一次尝试：我们走到院子里，把她扔到雪地里。她站在原地一动不动，疑惑了 3 秒钟，然后不高兴地跑回屋里。\r\n\r\n第二次尝试（过了几天）：我们把她放到雪地边缘。这次成功了！她开始在雪地里四\r\n处溜达，还向深处探索了一番。\r\n\r\n你的大脑也是一只雪地里的猫。如果突然出现大规模变化，它会回到它已经适应的行\r\n事套路上，但如果慢慢推进变化，每次推进一点点，它可能会因为好奇（而不是害怕）而深入探索。\r\n\r\n大脑天生抵触变化，而且大多数阻力会在两个特定时刻出现。\r\n\r\n## 行动前的阻力\r\n把自己想象成轨道上的小球，或者是牛顿定律里说的“静止的物体”。动力策略派坚持的观点是你必须在行动之前激发动力，可先向前移动 1 厘米然后借助动量不是更轻松吗？\r\n\r\n没错，这样轻松得多！稍微向前移动后，你就可以继续运动了。一旦动起来，原来的等式就会变为对你更有利的物理定律：“除非受到外力作用，否则处于运动状态中的物体速度不会改变。”\r\n\r\n我们都希望自己能朝着目标运动，走得越远、越频繁越好。要做到这一点，第一个动\r\n作就必须非常简单，因为在任何一项任务里，它都是阻止你前进的第一堵墙。开头是相比之下最难的环节，但这并不是说开头真的很难。“最难”是相对而言的。\r\n\r\n如果第一个动作只是轻轻一推，那么最初的阻力就会小很多。一旦行动开始，就会出\r\n现第二波阻力。这第二波阻力有多强大，取决于你迈出的第一步有多大冲击力（每次都不一样）。\r\n\r\n## 继续行动时面对的阻力\r\n微习惯策略通过微步骤开始行动，制定的总体目标小到不会失败，这样就能应对第一\r\n种内部阻力，这样你就不会不知所措，而会回归以前的做事套路（就像雪地里的猫一样）。\r\n\r\n而你一旦开始行动，还会出现新一波阻力。根据我的经验，迈出这样的第一步往往可\r\n以彻底粉碎第二波阻力，尤其当你有类似经验时。开始行动以后，阻力就会少很多。你能猜到原因吗？想想大脑就知道了。\r\n\r\n这种阻力并不神秘，它只是与惯性行为产生了潜意识冲突。你可以骗过基底神经节，\r\n让它不抵触第一步，可是当你试图继续行动时，它还是会知道第一步的目标是什么。所以，如果第一步不足以消除阻力，你可以再迈出一步。基底神经节不屑于“防御”微步骤，它只会对抗剧烈变化。通过慢慢变化，而且一次只迈进一小步，你就可以按照大脑的规则行动了。\r\n\r\n因此，我在挑战 1 个俯卧撑时不断制定微目标，而我的大脑是能容忍这种行为的,但如果我想做哪怕只有 10 分钟的连续运动，大脑都会说:“不行，绝对不行。年轻人，玩游戏去吧。你被禁足了。”于是我问：“那我能把运动垫子拿出来吗？”它说：“好吧。”接下来的故事你们都知道了。\r\n\r\n如果你在完成微目标之后还想继续，那就继续使用微步骤策略吧（如有必要）。但是\r\n别指望每次都能这么干，这与我们此前探讨过的制定微小目标的原因有关，你肯定不想为了短期收获毁了长远计划。我也不想故意吓你，让你把每次需要完成的任务定得太小，让自己毫无进步，所以我只能这么说：“只要你的目标不管是从理性还是感性角度看都很小，那就没问题了。”\r\n\r\n接下来，让我们更详细地看看微习惯在这一刻是怎么起作用的。\r\n\r\n## 跨越障碍的微习惯\r\n刚才我们探讨了遇到阻力的两种情况（任务或计划开始之前和进行过程中）。现在我\r\n想讨论阻力的两种常见形式——精神方面和身体方面的。\r\n\r\n动力策略不保证每次都能克服阻力，它只能偶尔奏效。动力的宣传口号应该直接引用\r\n电影《王牌播音员》（Anchorman ）里的台词：“在 60% 的时间里，它每次都管用。”\r\n\r\n而不光动力如此，贸然使用意志力同样也会导致效率低下。精明的意志力管理方法正\r\n是个人成长的关键所在，正如精明的理财方法是财富增长的关键一样。通过精明的理财手段，工作普通、收入相对较低的人也可以变成百万富翁，而有些年收入上百万美元的顶级运动员却最终一贫如洗。如果你不好好规划行动策略，就会在无效的意志力\r\n\r\n## 策略和动力策\r\n略之间摇摆不定，最终只会受挫。\r\n\r\n下面讲讲微习惯是如何帮你克服精神和身体障碍的。既然锻炼是人人向往的目标，我\r\n就拿它为例吧。\r\n\r\n精神阻碍：你有锻炼的精力，却不想锻炼\r\n \r\n既然我们要跳过动力，那就只剩下运用意志力这条路可以走了。但是，我们只会说你\r\n必须做一个俯卧撑，而不会说你必须完成一整套锻炼，你必须这么干。不用担心，因为在这种情况下你有精力。而且一旦开始做，你就会发现大多数时候动力都会自然形成。\r\n\r\n在这种情况下，现在的你根本不想锻炼，可是总体来看，你这辈子还是想锻炼的。这\r\n就是当前感受和人生价值之间的想法冲突。做第一个俯卧撑时，你的人生价值通常会对你起到鼓励作用，并取代你此前的犹豫。如果不是这样的话，你也许就得像我在“挑战 1 个俯卧撑”中那样设定几个微目标，但随着你继续前进，你的思维就会适应身体正在做的事情，你迈出的每一步都会让长远的健康目标显得更有吸引力。\r\n在之前关于意志力的章节里，我们已经看到了我们对任务难度的认知是如何决定意志\r\n力的，当我们用“小得不可思议的一小步”的方式来行动时，认知难度和意志力消耗量会显著降低。一旦你开始第一步，大脑就会计算一套完整锻炼的真正难度有多大，而不会出现一个有偏见、懒惰的大脑判断这件事做起来特别痛苦的情况。如果你在一次锻炼或尝试一种新体验之后发现自己的想法是“原来没那么糟糕”，那么这说明你已经熟悉这种现象了。\r\n\r\n如果你从小任务做起后还是会过分使用意志力，结果导致自己心力憔悴，该怎么办呢\r\n？这就是许多自助类书籍作者害怕的情况。如果你只是没有足够的精力而已呢？如果你头疼怎么办？\r\n\r\n我不敢保证微习惯策略能解决所有让行动中断的糟糕情况，但是只要有解决办\r\n法，它肯定是基于行动的唯一最佳策略。\r\n\r\n身体阻碍：因为很累，所以你的身体并不想锻炼\r\n我们一般认为疲劳是一种身体阻碍，可是它同时也是一种精神阻碍。通常精力为零也\r\n就意味着动力为零。我已经无数次用微习惯策略解决过这种情况了，比如，这本书里有 1000 多字是我在头疼的时候写出来的。不光头疼，我还特别累，只想睡觉。此时我完全没有写作动力，精力严重不足，可是我还是写了 50 字（最终积累成 1000 字了）。\r\n\r\n从很多方面看，做 1 个俯卧撑比不做容易。这项挑战太过轻松，你的自尊心这时就会起作用：“也许我很固执，现在很累，可还得加把劲，我一定能做到。”我建议你\r\n经常提醒自己：如果连渺小的习惯目标都无法实现，这多让人无地自容啊。\r\n我在头疼时依然能有产出，是因为我是从小任务做起的。如果根据我最开始的感觉来\r\n判断，这几乎完全不可能实现。而且，要是放在过去，有这么棒的借口，我根本就不会在这种情况下尝试写些什么。我会减少损失，像往常一样对自己承诺之后再完成任务（随着年龄增长，我意识到现在就是昨天的“之后”，所以“之后”是个糟糕的计划）。\r\n\r\n大半夜头疼，累得半死，可以说祸不单行，我发誓，我听到我的床在对我说话。\r\n它说：“斯蒂芬，快来进入美妙的快速眼动睡眠周期。”我呆滞的眼睛贪婪地盯着那暖和的被子，答道：“亲爱的，马上就来。”\r\n\r\n我的目标太轻松了，所以我决定花点时间完成它，然后就不干活了。但最后，我写了\r\n1000 字，我自己都很诧异。这种人生策略有几次向我展示了它的威力，那就是其中一次。\r\n\r\n你能理解微习惯策略是怎样让你变得不可阻挡的吗？你能理解我为什么相信微习惯策\r\n略几乎能帮助所有人养成好习惯了吗？如果我能在这样的情况下——意志力较弱时——运用微习惯策略，那么它就是个好策略。这个策略的基础不在于我的独特经历，而在于意志力的科学理论，只不过我的经历与这个科学理论一致。采用微习惯策略，你只需要最少量的意志力，就能收获最多的动量——完美方案。\r\n\r\n## 把微习惯融入生活\r\n```\r\n你忙吗？\r\n你是否经常因为想做和必须做的事而不堪重负？\r\n```\r\n在考量一种策略时，你一定会关注它是怎么融入你的生活的。\r\n\r\n许多习惯类书籍（明智地）推荐你一次只培养一个习惯的方法，这是因为我们的意志力有限，无法一次应对过多习惯。\r\n\r\n可是谁愿意 6 个月里只专注于一个方面，放弃其他你同样想要提高的方面呢？\r\n\r\n因为习惯有很高的价值，这么做的确值得，可是如果你也想练出好体形，却只能在一段时间里专注于写作这一件事，你是否会感到遗憾呢？\r\n\r\n你目前行为的焦点和你想提高的其他领域之间的紧张关系，会让你偏离原计划。这个重要的问题被严重忽视了，一直以来都没有解决之道，直到现在，你看到了微习惯策略的力量。\r\n', '1', '1', '2019-01-14 01:20:00', '2019-01-15 07:45:40');
INSERT INTO `posts` VALUES ('35', '4', '0', '39', 'github仓库与原始仓库同步的两种方法', 'github仓库与原始仓库同步的两种方法', '## 与原始仓库同步可以使用merge或者rebase两种不同的方法。\r\n\r\n步骤：\r\n\r\n添加原始仓库的路径，这里假设为https://github.com/upstream/master.git \r\n```\r\ngit remote add Upstream https://github.com/upstream/master.git\r\n```\r\ncommit（提交）本地的变更；\r\n\r\n如果本地没有修改内容，此步骤可忽略 \r\n```\r\ngit commit\r\n```\r\n更新远程仓库，从引用 fork 的原仓库地址同步内容，此时原仓库的 master（主干分支）已经可以在本地访问了。 \r\n```\r\ngit remote update Upstream\r\n```\r\ncheckout（检出）用于操作的本地分支 ，比如 master；如果此时分支为已检出状态，此步骤可忽略 \r\n```\r\ngit checkout master\r\n```\r\n直接从远程原始仓库的分支 pull（拉取） 数据 \r\n```\r\ngit pull upstream master \r\n```\r\nPS（第二种方法）：或者本地已检出分支基于远程仓库的分支进行 rebase（变基）操作 \r\n```\r\ngit rebase Upstream/master\r\n```\r\n把本地已检出分支的已提交数据 push（推送） 到自己 fork 的仓库中\r\n``` \r\ngit push origin master\r\n```\r\n解决冲突\r\n\r\n在使用pull，push方法同步， 或者使用rebase，push同步的过程中，也许会出现冲突(conflict)。在这种情况，需要手动解决冲突。\r\n\r\n比如rebase发生冲突时，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: \r\n```\r\ngit rebase --continue \r\n```\r\n这样git会继续应用(apply)余下的补丁。\r\n\r\n在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。\r\n``` \r\ngit rebase --abort\r\n```\r\n\r\n## fetch，pull和rebase的区别\r\nGit中从远程的分支获取最新的版本到本地有这样2个命令： \r\n1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge。\r\n\r\n```\r\ngit fetch upstream\r\ngit checkout master\r\ngit merge upstream/master\r\n```\r\n\r\n上述命令相当于首先从远程的upstream原始仓库下载最新的版本到origin/master分支上， 然后合并到本地的master分支。 \r\n\r\n2. git pull：相当于是从远程获取最新版本并merge到本地。\r\n\r\n``` \r\ngit pull upstream master \r\n```\r\n上述命令其实相当于git fetch 和 git merge。\r\n\r\n在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。因此可以用git fetch和git merge代替git pull，具体操作可以参考git如何与原始仓库同步\r\n\r\n关于rebase与merge的区别还挺复杂的，可以参考advance git，git-变基，git merge 和 git rebase 小结\r\n\r\n保持你的代码最新\r\n当你进行开发的时候，原始的仓库主分支很可能会更新，你应该保持你复制的本地分支是目前最新的。此时你就可以使用 \r\n```\r\n（1）git merge，即git fetch和git merge（或者git pull），\r\n（2）git rebase两种方法获取最新的原始仓库，并保持你自己的修改。\r\n```\r\n--------------------- \r\n --人总是喜欢在失去与得到之间徘徊迷茫，其实，那些经历过的事情都会成为你的财富。', '1', '1', '2019-01-15 02:25:08', '2019-01-15 02:25:08');
INSERT INTO `posts` VALUES ('36', '4', '0', '40', 'phpms框架拓展', 'PHP的可扩展微框架\r\n他有哪些内容，如何实现功能的', '## 路由\r\n\r\nFlight in Routing通过匹配URL模式和回调函数来完成。\r\n```\r\nFlight::route(\'/\', function(){\r\n    echo \'hello world!\';\r\n});\r\n```\r\n回调可以是任何可调用的对象。所以你可以使用常规功能：\r\n```\r\nfunction hello(){\r\n    echo \'hello world!\';\r\n}\r\n\r\nFlight::route(\'/\', \'hello\');\r\n```\r\n或者一个类方法：\r\n```\r\nclass Greeting {\r\n    public static function hello() {\r\n        echo \'hello world!\';\r\n    }\r\n}\r\n\r\nFlight::route(\'/\', array(\'Greeting\',\'hello\'));\r\n```\r\n或者一个对象方法：\r\n```\r\nclass Greeting\r\n{\r\n    public function __construct() {\r\n        $this->name = \'John Doe\';\r\n    }\r\n\r\n    public function hello() {\r\n        echo \"Hello, {$this->name}!\";\r\n    }\r\n}\r\n\r\n$greeting = new Greeting();\r\n\r\nFlight::route(\'/\', array($greeting, \'hello\'));\r\n```\r\n路由按照定义的顺序进行匹配。将调用匹配请求的第一个路由。\r\n\r\n## 方法路由\r\n\r\n默认情况下，路由模式与所有请求方法匹配。您可以通过在URL之前放置标识符来响应特定方法。\r\n```\r\nFlight::route(\'GET /\', function(){\r\n    echo \'I received a GET request.\';\r\n});\r\n\r\nFlight::route(\'POST /\', function(){\r\n    echo \'I received a POST request.\';\r\n});\r\n```\r\n您还可以使用|分隔符将多个方法映射到单个回调：\r\n```\r\nFlight::route(\'GET|POST /\', function(){\r\n    echo \'I received either a GET or a POST request.\';\r\n});\r\n```\r\n## 常用表达\r\n\r\n您可以在路线中使用正则表达式：\r\n```\r\nFlight::route(\'/user/[0-9]+\', function(){\r\n    // This will match /user/1234\r\n});\r\n```\r\n## 命名参数\r\n\r\n您可以在路由中指定命名参数，这些参数将传递给您的回调函数。\r\n```\r\nFlight::route(\'/@name/@id\', function($name, $id){\r\n    echo \"hello, $name ($id)!\";\r\n});\r\n```\r\n您还可以使用:分隔符在命名参数中包含正则表达式：\r\n```\r\nFlight::route(\'/@name/@id:[0-9]{3}\', function($name, $id){\r\n    // This will match /bob/123\r\n    // But will not match /bob/12345\r\n});\r\n```\r\n\r\n## 可选参数\r\n\r\n您可以通过在括号中包装段来指定可选的匹配命名参数。\r\n```\r\nFlight::route(\'/blog(/@year(/@month(/@day)))\', function($year, $month, $day){\r\n    // This will match the following URLS:\r\n    // /blog/2012/12/10\r\n    // /blog/2012/12\r\n    // /blog/2012\r\n    // /blog\r\n});\r\n```\r\n任何不匹配的可选参数都将作为NULL传递。\r\n\r\n## 通配符\r\n\r\n匹配仅在各个URL段上进行。如果要匹配多个段，可以使用*通配符。\r\n```\r\nFlight::route(\'/blog/*\', function(){\r\n    // This will match /blog/2000/02/01\r\n});\r\n```\r\n要将所有请求路由到单个回调，您可以执行以下操作：\r\n```\r\nFlight::route(\'*\', function(){\r\n    // Do something\r\n});\r\n```\r\n## 通过\r\n\r\n您可以通过true从回调函数返回来将执行传递到下一个匹配的路由。\r\n```\r\nFlight::route(\'/user/@name\', function($name){\r\n    // Check some condition\r\n    if ($name != \"Bob\") {\r\n        // Continue to next route\r\n        return true;\r\n    }\r\n});\r\n\r\n\r\nFlight::route(\'/user/*\', function(){\r\n    // This will get called\r\n});\r\n```\r\n\r\n## 路线信息\r\n\r\n如果要检查匹配的路由信息​​，可以通过传入true路由方法中的第三个参数来请求将路由对象传递给回调。路由对象始终是传递给回调函数的最后一个参数。\r\n```\r\nFlight::route(\'/\', function($route){\r\n    // Array of HTTP methods matched against\r\n    $route->methods;\r\n\r\n    // Array of named parameters\r\n    $route->params;\r\n\r\n    // Matching regular expression\r\n    $route->regex;\r\n\r\n    // Contains the contents of any \'*\' used in the URL pattern\r\n    $route->splat;\r\n}, true);\r\n```\r\n\r\n## 扩展\r\n\r\nFlight旨在成为可扩展的框架。该框架带有一组默认方法和组件，但它允许您映射自己的方法，注册自己的类，甚至覆盖现有的类和方法。\r\n\r\n### 映射方法\r\n\r\n要映射您自己的自定义方法，请使用以下map函数：\r\n```\r\n// Map your method\r\nFlight::map(\'hello\', function($name){\r\n    echo \"hello $name!\";\r\n});\r\n\r\n// Call your custom method\r\nFlight::hello(\'Bob\');\r\n```\r\n\r\n### 注册类\r\n要注册自己的类，请使用以下register函数：\r\n```\r\n// Register your class\r\nFlight::register(\'user\', \'User\');\r\n\r\n// Get an instance of your class\r\n$user = Flight::user();\r\n```\r\nregister方法还允许您将参数传递给类构造函数。因此，当您加载自定义类时，它将进行预初始化。您可以通过传入其他数组来定义构造函数参数。这是加载数据库连接的示例：\r\n```\r\n// Register class with constructor parameters\r\nFlight::register(\'db\', \'PDO\', array(\'mysql:host=localhost;dbname=test\',\'user\',\'pass\'));\r\n\r\n// Get an instance of your class\r\n// This will create an object with the defined parameters\r\n//\r\n//     new PDO(\'mysql:host=localhost;dbname=test\',\'user\',\'pass\');\r\n//\r\n$db = Flight::db();\r\n```\r\n如果传入一个额外的回调参数，它将在类构造后立即执行。这允许您为新对象执行任何设置过程。回调函数接受一个参数，即新对象的一个​​实例。\r\n```\r\n// The callback will be passed the object that was constructed\r\nFlight::register(\'db\', \'PDO\', array(\'mysql:host=localhost;dbname=test\',\'user\',\'pass\'),\r\n  function($db){\r\n    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\r\n  }\r\n);\r\n```\r\n默认情况下，每次加载类时，您都将获得一个共享实例。要获取类的新实例，只需将其false作为参数传入：\r\n```\r\n// Shared instance of the class\r\n$shared = Flight::db();\r\n\r\n// New instance of the class\r\n$new = Flight::db(false);\r\n```\r\n请记住，映射方法优先于已注册的类。如果使用相同的名称声明两者，则仅调用映射的方法。\r\n\r\n## 重写\r\n\r\nFlight允许您覆盖其默认功能以满足您自己的需要，而无需修改任何代码。\r\n\r\n例如，当Flight无法匹配路由的URL时，它会调用notFound 发送泛型HTTP 404响应的方法。您可以使用以下map方法覆盖此行为：\r\n```\r\nFlight::map(\'notFound\', function(){\r\n    // Display custom 404 page\r\n    include \'errors/404.html\';\r\n});\r\n```\r\nFlight还允许您替换框架的核心组件。例如，您可以使用自己的自定义类替换默认的Router类：\r\n```\r\n// Register your custom class\r\nFlight::register(\'router\', \'MyRouter\');\r\n\r\n// When Flight loads the Router instance, it will load your class\r\n$myrouter = Flight::router();\r\n```\r\n\r\n框架的方法，如map和register但不能被重写。如果您尝试这样做，将会收到错误消息。\r\n\r\n过滤\r\nFlight允许您在调用它们之前和之后过滤方法。您不需要记住预定义的钩子。您可以筛选任何默认框架方法以及已映射的任何自定义方法。\r\n\r\n过滤函数如下所示：\r\n```\r\nfunction(&$params, &$output) {\r\n    // Filter code\r\n}\r\n```\r\n使用传入的变量可以操作输入参数和/或输出。\r\n\r\n您可以通过执行以下操作在方法之前运行过滤器：\r\n```\r\nFlight::before(\'start\', function(&$params, &$output){\r\n    // Do something\r\n});\r\n```\r\n您可以通过执行以下方法在方法之后运行过滤器：\r\n```\r\nFlight::after(\'start\', function(&$params, &$output){\r\n    // Do something\r\n});\r\n```\r\n您可以根据需要为任何方法添加任意数量的过滤器。它们将按照声明的顺序调用。\r\n\r\n以下是过滤过程的示例：\r\n```\r\n// Map a custom method\r\nFlight::map(\'hello\', function($name){\r\n    return \"Hello, $name!\";\r\n});\r\n\r\n// Add a before filter\r\nFlight::before(\'hello\', function(&$params, &$output){\r\n    // Manipulate the parameter\r\n    $params[0] = \'Fred\';\r\n});\r\n \r\n// Add an after filter\r\nFlight::after(\'hello\', function(&$params, &$output){\r\n    // Manipulate the output\r\n    $output .= \" Have a nice day!\";\r\n});\r\n// Invoke the custom method\r\necho Flight::hello(\'Bob\');\r\n```\r\n这应该显示：\r\n```\r\nHello Fred! Have a nice day!\r\n```\r\n如果您已定义了多个过滤器，则可以通过返回false 任何过滤器函数来中断链：\r\n```\r\nFlight::before(\'start\', function(&$params, &$output){\r\n    echo \'one\';\r\n});\r\n\r\nFlight::before(\'start\', function(&$params, &$output){\r\n    echo \'two\';\r\n\r\n    // This will end the chain\r\n    return false;\r\n});\r\n\r\n// This will not get called\r\nFlight::before(\'start\', function(&$params, &$output){\r\n    echo \'three\';\r\n});\r\n```\r\n注意，核心方法如map和register不能被过滤，因为它们是直接调用而不是动态调用的。\r\n\r\n## 变量\r\n\r\nFlight允许您保存变量，以便可以在应用程序的任何位置使用它们。\r\n```\r\n// Save your variable\r\nFlight::set(\'id\', 123);\r\n\r\n// Elsewhere in your application\r\n$id = Flight::get(\'id\');\r\n```\r\n\r\n要查看是否已设置变量，您可以执行以下操作：\r\n```\r\nif (Flight::has(\'id\')) {\r\n     // Do something\r\n}\r\n```\r\n\r\n您可以通过执行以下操作清除变量：\r\n```\r\n// Clears the id variable\r\nFlight::clear(\'id\');\r\n\r\n// Clears all variables\r\nFlight::clear();\r\n```\r\n\r\nFlight还使用变量进行配置。\r\n```\r\nFlight::set(\'flight.log_errors\', true);\r\n```\r\n\r\n## 查看\r\n\r\nFlight默认提供一些基本的模板功能。要显示视图模板，请render使用模板文件的名称和可选的模板数据调用该方法：\r\n```\r\nFlight::render(\'hello.php\', array(\'name\' => \'Bob\'));\r\n```\r\n传入的模板数据会自动注入模板，并且可以像局部变量一样引用。模板文件只是PHP文件。如果hello.php模板文件的内容是：\r\n```\r\nHello, \'<?php echo $name; ?>\'!\r\n```\r\n输出将是：\r\n```\r\nHello, Bob!\r\n```\r\n\r\n您还可以使用set方法手动设置视图变量：\r\n```\r\nFlight::view()->set(\'name\', \'Bob\');\r\n```\r\n\r\n该变量name现在可用于所有视图。所以你可以简单地做：\r\n```\r\nFlight::render(\'hello\');\r\n```\r\n\r\n请注意，在render方法中指定模板的名称时，可以省略.php扩展名。\r\n\r\n默认情况下，Flight将查找views模板文件的目录。您可以通过设置以下配置为模板设置备用路径：\r\n```\r\nFlight::set(\'flight.views.path\', \'/path/to/views\');\r\n```\r\n\r\n### 布局\r\n\r\n网站通常具有具有交换内容的单个布局模板文件。要呈现要在布局中使用的内容，可以将可选参数传递给render方法。\r\n```\r\nFlight::render(\'header\', array(\'heading\' => \'Hello\'), \'header_content\');\r\nFlight::render(\'body\', array(\'body\' => \'World\'), \'body_content\');\r\n```\r\n\r\n然后，您的视图将保存名为header_content和的变量body_content。然后，您可以执行以下操作来渲染布局：\r\n```\r\nFlight::render(\'layout\', array(\'title\' => \'Home Page\'));\r\n```\r\n\r\n如果模板文件如下所示：\r\n\r\nheader.php：\r\n```\r\n<h1><?php echo $heading; ?></h1>\r\nbody.php：\r\n\r\n<div><?php echo $body; ?></div>\r\nlayout.php：\r\n\r\n<html>\r\n<head>\r\n<title><?php echo $title; ?></title>\r\n</head>\r\n<body>\r\n<?php echo $header_content; ?>\r\n<?php echo $body_content; ?>\r\n</body>\r\n</html>\r\n```\r\n\r\n输出将是：\r\n```\r\n<html>\r\n<head>\r\n<title>Home Page</title>\r\n</head>\r\n<body>\r\n<h1>Hello</h1>\r\n<div>World</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 自定义视图\r\nFlight允许您通过注册自己的视图类来交换默认视图引擎。以下是如何将Smarty 模板引擎用于您的视图：\r\n```\r\n// Load Smarty library\r\nrequire \'./Smarty/libs/Smarty.class.php\';\r\n\r\n// Register Smarty as the view class\r\n// Also pass a callback function to configure Smarty on load\r\nFlight::register(\'view\', \'Smarty\', array(), function($smarty){\r\n    $smarty->template_dir = \'./templates/\';\r\n    $smarty->compile_dir = \'./templates_c/\';\r\n    $smarty->config_dir = \'./config/\';\r\n    $smarty->cache_dir = \'./cache/\';\r\n});\r\n\r\n// Assign template data\r\nFlight::view()->assign(\'name\', \'Bob\');\r\n\r\n// Display the template\r\nFlight::view()->display(\'hello.tpl\');\r\n```\r\n\r\n为了完整性，您还应该覆盖Flight的默认渲染方法：\r\n```\r\nFlight::map(\'render\', function($template, $data){\r\n    Flight::view()->assign($data);\r\n    Flight::view()->display($template);\r\n});\r\n```\r\n\r\n错误处理\r\n错误和例外\r\n所有错误和异常都由Flight捕获并传递给error方法。默认行为是发送HTTP 500 Internal Server Error 带有一些错误信息的通用响应。\r\n\r\n您可以根据自己的需要覆盖此行为：\r\n```\r\nFlight::map(\'error\', function(Exception $ex){\r\n    // Handle error\r\n    echo $ex->getTraceAsString();\r\n});\r\n```\r\n\r\n默认情况下，错误不会记录到Web服务器。您可以通过更改配置来启用此功能：\r\n```\r\nFlight::set(\'flight.log_errors\', true);\r\n```\r\n未找到\r\n当找不到URL时，Flight会调用该notFound方法。默认行为是HTTP 404 Not Found使用简单消息发送响应。\r\n\r\n您可以根据自己的需要覆盖此行为：\r\n```\r\nFlight::map(\'notFound\', function(){\r\n    // Handle not found\r\n});\r\n```\r\n\r\n## 重定向\r\n\r\n您可以使用该redirect方法重定向当前请求并传入新URL：\r\n```\r\nFlight::redirect(\'/new/location\');\r\n```\r\n\r\n默认情况下，Flight会发送HTTP 303状态代码。您可以选择设置自定义代码：\r\n```\r\nFlight::redirect(\'/new/location\', 401);\r\n```\r\n\r\n要求\r\n\r\nFlight将HTTP请求封装到单个对象中，可以通过执行以下操作来访问：\r\n```\r\n$request = Flight::request();\r\n```\r\n\r\n请求对象提供以下属性：\r\n```\r\nurl - The URL being requested\r\nbase - The parent subdirectory of the URL\r\nmethod - The request method (GET, POST, PUT, DELETE)\r\nreferrer - The referrer URL\r\nip - IP address of the client\r\najax - Whether the request is an AJAX request\r\nscheme - The server protocol (http, https)\r\nuser_agent - Browser information\r\ntype - The content type\r\nlength - The content length\r\nquery - Query string parameters\r\ndata - Post data or JSON data\r\ncookies - Cookie data\r\nfiles - Uploaded files\r\nsecure - Whether the connection is secure\r\naccept - HTTP accept parameters\r\nproxy_ip - Proxy IP address of the client\r\n```\r\n\r\n您可以访问query，data，cookies，和files数组或对象的属性。\r\n\r\n因此，要获取查询字符串参数，您可以执行以下操作：\r\n```\r\n$id = Flight::request()->query[\'id\'];\r\n```\r\n或者你可以这样做：\r\n```\r\n$id = Flight::request()->query->id;\r\n```\r\n\r\n## RAW请求机构\r\n要获取原始HTTP请求主体，例如在处理PUT请求时，您可以执行以下操作：\r\n```\r\n$body = Flight::request()->getBody();\r\n```\r\n\r\nJSON输入\r\n如果您发送具有类型application/json和数据的请求，则可以从该属性获取：\r\n```\r\n{\"id\": 123}data\r\n \r\n$id = Flight::request()->data->id;\r\n```\r\nheader.php：停止\r\n\r\n您可以通过调用halt方法随时停止框架：\r\n```\r\nFlight::halt();\r\n```\r\n\r\n您还可以指定可选的HTTP状态代码和消息：\r\n```\r\nFlight::halt(200, \'Be right back...\');\r\n```\r\n\r\n呼叫halt将丢弃任何响应内容。如果要停止框架并输出当前响应，请使用以下stop方法：\r\n```\r\nFlight::stop();\r\n```\r\n\r\n## HTTP缓存\r\nFlight提供对HTTP级缓存的内置支持。如果满足缓存条件，Flight将返回HTTP 304 Not Modified响应。下次客户端请求相同的资源时，系统将提示他们使用本地缓存的版本。\r\n\r\n最后修改\r\n您可以使用该lastModified方法并传入UNIX时间戳来设置上次修改页面的日期和时间。客户端将继续使用其缓存，直到更改上一个修改后的值。\r\n```\r\nFlight::route(\'/news\', function(){\r\n    Flight::lastModified(1234567890);\r\n    echo \'This content will be cached.\';\r\n});\r\n```\r\n\r\n## ETag的\r\nETag缓存类似于Last-Modified，除了您可以为资源指定任何ID：\r\n```\r\nFlight::route(\'/news\', function(){\r\n    Flight::etag(\'my-unique-id\');\r\n    echo \'This content will be cached.\';\r\n});\r\n```\r\n请记住，调用其中之一lastModified或etag将同时设置并检查缓存值。如果请求之间的缓存值相同，Flight将立即发送HTTP 304响应并停止处理。\r\n\r\n## JSON\r\nFlight支持发送JSON和JSONP响应。要发送JSON响应，您需要传递一些数据进行JSON编码：\r\n```\r\nFlight::json(array(\'id\' => 123));\r\n```\r\n\r\n对于JSONP请求，您可以选择传入用于定义回调函数的查询参数名称：\r\n```\r\nFlight::jsonp(array(\'id\' => 123), \'q\');\r\n```\r\n因此，在使用GET请求时?q=my_func，您应该收到输出：\r\n```\r\nmy_func({\"id\":123});\r\n```\r\n\r\n如果您未传入查询参数名称，则默认为jsonp。\r\n\r\n## 组态\r\n您可以通过该set方法设置配置值来自定义Flight的某些行为。\r\n```\r\nFlight::set(\'flight.log_errors\', true);\r\n```\r\n\r\n以下是所有可用配置设置的列表：\r\n```\r\nflight.base_url - Override the base url of the request. (default: null)\r\nflight.case_sensitive - Case sensitive matching for URLs. (default: false)\r\nflight.handle_errors - Allow Flight to handle all errors internally. (default: true)\r\nflight.log_errors - Log errors to the web server\'s error log file. (default: false)\r\nflight.views.path - Directory containing view template files. (default: ./views)\r\nflight.views.extension - View template file extension. (default: .php)\r\n```\r\n\r\n## 框架方法\r\n\r\n飞行的目的是易于使用和理解。以下是框架的完整方法集。它由核心方法和可扩展方法组成，核心方法是常规静态方法，可扩展方法是可以过滤或覆盖的映射方法。\r\n\r\n## 核心方法\r\n```\r\nFlight::map($name, $callback) // Creates a custom framework method.\r\nFlight::register($name, $class, [$params], [$callback]) // Registers a class to a framework method.\r\nFlight::before($name, $callback) // Adds a filter before a framework method.\r\nFlight::after($name, $callback) // Adds a filter after a framework method.\r\nFlight::path($path) // Adds a path for autoloading classes.\r\nFlight::get($key) // Gets a variable.\r\nFlight::set($key, $value) // Sets a variable.\r\nFlight::has($key) // Checks if a variable is set.\r\nFlight::clear([$key]) // Clears a variable.\r\nFlight::init() // Initializes the framework to its default settings.\r\nFlight::app() // Gets the application object instance\r\n可扩展的方法\r\nFlight::start() // Starts the framework.\r\nFlight::stop() // Stops the framework and sends a response.\r\nFlight::halt([$code], [$message]) // Stop the framework with an optional status code and message.\r\nFlight::route($pattern, $callback) // Maps a URL pattern to a callback.\r\nFlight::redirect($url, [$code]) // Redirects to another URL.\r\nFlight::render($file, [$data], [$key]) // Renders a template file.\r\nFlight::error($exception) // Sends an HTTP 500 response.\r\nFlight::notFound() // Sends an HTTP 404 response.\r\nFlight::etag($id, [$type]) // Performs ETag HTTP caching.\r\nFlight::lastModified($time) // Performs last modified HTTP caching.\r\nFlight::json($data, [$code], [$encode], [$charset], [$option]) // Sends a JSON response.\r\nFlight::jsonp($data, [$param], [$code], [$encode], [$charset], [$option]) // Sends a JSONP response.\r\n```\r\n \r\n添加的任何自定义方法与map和register还可以进行筛选。\r\n\r\n## 框架实例\r\n\r\n您可以选择将其作为对象实例运行，而不是将Flight作为全局静态类运行。\r\n\r\n\r\n```\r\nrequire \'flight/autoload.php\';\r\n\r\nuse flight\\Engine;\r\n\r\n$app = new Engine();\r\n\r\n$app->route(\'/\', function(){\r\n    echo \'hello world!\';\r\n});\r\n\r\n$app->start();\r\n```\r\n\r\n因此，不是调用静态方法，而是在Engine对象上调用具有相同名称的实例方法。', '1', '1', '2019-01-15 14:40:28', '2019-01-15 17:13:00');
INSERT INTO `posts` VALUES ('37', '14', '0', '39', '5-微习惯的独特之处', '是故胜兵先胜而后求战，败兵先战而后求胜。   ——孙子，《孙子兵法》', '```\r\n是故胜兵先胜而后求战，败兵先战而后求胜。   ——孙子，《孙子兵法》\r\n```\r\n是什么让微习惯有别于其他号称能改变你生活的策略？\r\n\r\n这套体系为什么会比传统方法更加有效地提升习惯养成和个人成长效果？这些问题问得很好，所以接下来我会给出答案。\r\n\r\n## 微习惯能与现有习惯一较高下\r\n\r\n有人针对试图改变现有习惯的人群做了一些研究，结论让人有些气馁。结果显示，一\r\n旦习惯变得足够牢固，即使是最坚定的决心也很难扭转局面。一天下来，你实际上借助惯性做出的行为比表面上多得多，而当你试图增添新的健康习惯时，这些行为就会形成阻碍。\r\n\r\n微习惯策略的竞争力远超其他习惯策略。你试图养成一个新习惯时，好像没经过任何\r\n训练就参加了一场举重比赛，本来竞争就很激烈，更糟糕的是，对手经验丰富，久经考验，而且力量更强。大多数习惯策略在这个节点就会犯错了，它们会让你相信，你现在就可以跟这些更强大的习惯硬碰硬（抱歉，那么我还是压 400 美元赌“抽烟”和“看电视”胜出）。\r\n\r\n这些策略鼓励你做出大幅度的改变，比如从很少写作到每天写 2000 字，或者从在沙发上躺着到每天锻炼一小时。这样做的问题在于意志力的消耗量，这个数学公式的计算结果可能对你不利，除非你已经拥有了高度自律的能力。否则，你会感到筋疲力尽的（而我会赢得 400 美元）。\r\n\r\n大脑会抗拒大幅度的改变。你是否听别人说过“想要得到工作机会，你只需要一只脚\r\n迈进门里”这句话？微习惯策略也应用了同样的概念，只不过说的是你的大脑，而不是进入一家公司。\r\n\r\n我是这样看待前额皮层的：一直享受支出补贴，直到被大脑的自动区域接替。对每一项任务而言，潜意识大脑都会审查你要求从它那里得到什么，然后让你支付意志\r\n力作为进入主控室的入场费。每天你只能要求获得一定量的人工控制力，可是一旦你进去了，你就在里面了。微习惯策略就像意志力消耗很低的特洛伊木马，它能把轻松访问大脑主控室的能力放大成重大收获，我做第一个俯卧撑的时候就注意到这一点了。它和我每次开始锻炼时做的动作都一样，可是因为我没有向大脑要求进行整套锻炼，所以我没有感受到一套锻炼的压力。\r\n\r\n## 微步骤+意志力是必胜组合\r\n\r\n个人成长的完美组合就是微步骤加上意志力。只要你有足够的意志力完成一个行动，\r\n就可以采取这项行动。微步骤几乎不需要意志力，所以这就让你好像拥有了无穷的意志力。\r\n\r\n如果你用微步骤正确引导自己，几乎能让自己做到任何事情。试试看。\r\n\r\n如果你不好意思向一个女生搭讪，那就下决心先向前迈出左脚，然后右脚，朝她的方\r\n向走过去。你最终会走到她那里，她呢，会问你为什么“走路这么滑稽”。这真是打破僵局的好方法。\r\n\r\n现场直播最新实例：今天打了 3 小时篮球以后，我特别累。大脑和身体都在告诉我今天不可能写作了，我快要睡着了，意志力为零。可我的目标是写 50 字，小到无法抗拒。\r\n\r\n所以，现在我又一次超越了原定目标（而且很清醒）。很多时候你的确很累，但给大脑或者身体找点事情做，身体就会被唤醒。\r\n\r\n## 微习惯没有截止时间\r\n“你能在 21 或 30 天之内养成一个习惯”是一种常见谬论，有些书的理论完全建立在这个错误概念上。真相更残酷一些，而且更难预测——习惯的形成需要 18 到 254 天，具体要视习惯和个体而定。\r\n\r\n微习惯策略没有具体的截止时间，因为我们并不知道形成一个习惯需要多长时间，但\r\n我们要寻找的是行为变成习惯的信号。如果你的经历和我类似，你很可能也会养成比原计划更“大”的习惯。每天写 50 字的计划能让我写更多字，比如每天写 2000 字（虽然不是每天都如此）。\r\n\r\n## 微习惯能提升自我效能感\r\n如果你阅读过关于行为科学的研究报告，应该对“自我效能感”一词并不陌生，它指对自己影响事件结果的能力的信念。一项进行了两年的随机试验显示，最低限度的自我效能感也对适应并维持锻炼活动有着关键的影响。这适用于想锻炼的人群，还有因为医疗目的需要而锻炼的人群（当然，为了保持健康，我们都应当锻炼）。研究人员在报告中记录道：\r\n\r\n“如果锻炼中的自我效能感得到评估和提升，那么按指定要求进行锻炼的病人更有能\r\n成功。”\r\n\r\n自我效能感有助于实现目标和建立习惯，但心理学家阿尔伯特·班杜拉（Albert Bandura）明确指出，“如果缺乏基本能力，期待值本身不会产生想要的结果”。只靠相信自己是不够的。在受抑郁、意志力薄弱和反复失败困扰的人群中，缺乏成功所需最基本的自我效能感的现象是很常见的。如果你认为自己会失败，那么就很难有好结果了。\r\n\r\n微习惯策略是一个产出自我效能感的机器，重点是，你不需要任何自我效能感就能成\r\n功地开始行动，而你每天的成功会帮助你提升自我效能感。你怎么可能觉得自己不具备每天做 1 个俯卧撑的能力？在读两行字的时间里你就能把它完成，而且这就等同于通过练习强化自我效能感。\r\n\r\n## 微习惯策略还可以训练你相信自己。\r\n记住，大脑会抓住你扔给它的任何一种重复行为，所以，许多人都会慢慢遇到一个问\r\n题——预计自己无法实现目标。长期下去，这会击溃他们的自我效能感，因为他们很难相信下次会有不同的结果（尤其在采用的还是上次无效的策略时）。如果你曾经有过绝望的感觉，这就是当时发生在你身上的情况。但你其实是能成功的，我可不是在激励你，我只是在讲逻辑。你确实可以在生活中取得进步，认为自己不行是缺乏逻辑的谬论，它之所以出现，正是因为你让自己相信你什么都做不了。\r\n\r\n微习惯正是重新开始的完美方法。你不会再被巨大的目标吓破胆，也不会再受目标未\r\n实现带来的内疚感和缺憾感的煎熬了。这一次你每天都能成功。这些胜利也许微不足道，但微小的胜利对一颗心灰意冷的心来说是巨大的。\r\n\r\n现在，你也许正在琢磨“一天做 1 个俯卧撑或写 50 字能对我们有什么帮助？这些进步太小，意义不大”。\r\n\r\n第一，你错了——任何一个能变成习惯的微小行为都有其重要性，而且相当重要。习\r\n惯在人类拥有的行为基础中是最强大的。养成每天做一个俯卧撑的习惯比隔很久才狂做 30 个俯卧撑更好。只有先养成习惯，才能将其培养得更强、目标更高。\r\n而且，你可以随意超越原定目标值，而且我鼓励你这么做——我现在每天能够完成的\r\n任务远远超出了原定目标。正是因为必须写出少得可怜的 50 字，我才有可能写出 2000 字。\r\n\r\n在此之前，有些时候我一个字都不会写。正是写很多的野心最终导致我写得很少。现在我的写作量至少是以前的 3 倍多，原因很简单：我不再害怕动笔了，我很喜欢完成我规定的最低字数。如果我花几分钟写出 50 字，我可以说今天成功了——多么鼓舞人心啊。\r\n\r\n有很多次，我原计划“只写 50 字”，结果却写出了 3000 字。像我之前说过的那样，我有一次在头疼且完全没有精力的情况下写出了 1000 字，完成后感觉自己像超人一样。回头看看健康、精力充沛的自己轻易浪费的时光，再看看自己在头疼、没精力的情况下做出的微小成绩，我就更急于与全世界分享这本书了。\r\n\r\n## 微习惯能给予你自主权\r\n2012 年有一项针对 411 人的工作满意度调查，其中 65% 的美国和加拿大调查对象表示他们对工作不满意或多少有些不满意。我认为部分原因在于传统管理哲学的目标是控制雇员，而不是发挥他们的能力。其他研究发现：自主权或对自己拥有控制权和决定权的感觉是工作满意度的一个首要因素。一家欧洲工作环境调查机构在丹麦进行的一项调查发现，“在对工作决定权较高的雇员中，将近 90% 的男性和将近 85% 的女性满意度较高，而在工作决定权较低的雇员中只有大约 56% 反馈了较高的工作满意度”。\r\n\r\n这是一个普遍真理的具体案例——人一旦感觉受到控制，就会消极怠工。人们厌恶这种情况。也许这正是因为自主权和自由度有着紧密的联系。\r\n\r\n这就是许多自助书籍中的理论站不住脚的原因。作者会说，你必须强迫自己埋头苦干\r\n才能达到人生目标，但强迫自己埋头苦干本身不就标志着你在某种程度上不喜欢这种方式吗？在提升自己的过程中，难道你不想好好对待自己吗？\r\n\r\n自助书籍的另一个极端包括一些空洞的、激励人心的废话，还有那些让你自我感觉良\r\n好、看起来人畜无害的鸡汤散文。你也许会在短时间内感觉充满动力，但正如我在前文证实的，长期来看，依赖情绪和动力并没有效果。\r\n\r\n在向目标前进的旅途中，你会爱上微习惯毫无压力的特点，但它并不是一种没有结构\r\n的颠覆性体系，也不是一种试图让你振作起来的无趣尝试。你会以天或星期为时间段给自己设定严格的目标，可是它们实践起来特别轻松，所以你在潜意识里不会感到自己被你的计划控制（这是重点！），在完成微目标后，你就可以自由选择做自己想做的事。\r\n\r\n你不会有内疚感，不会有重大目标带来的沉重负担，你可以轻松自由地探索这些健康行为，它也会让整个过程变得更有乐趣，从科学角度看，这是一个很重要的优点！\r\n一项研究发现，当人们认为任务和决定很有趣时（与沉闷、无聊或艰难对照），他们\r\n的毅力就会更强。研究人员还记录了自主权的强大作用，你会发现它正是微习惯策略的核\r\n\r\n心部件。完成微习惯后，你就可以自由选择做自己想做的事情。自主权似乎是通过激活我们的内在动力起作用的，其中涉及的案例显示，自主权越高，结果越好（每一项都有独立的研究支持），这些案例包括肥胖症患者减肥、吸烟者戒烟以及糖尿病患者控制血糖水平。\r\n\r\n## 抽象和具体目标与微习惯相结合\r\n目标分为两类——抽象目标和具体目标。一个抽象目标可能是“我想成为有钱人”，一\r\n个具体目标可能是“我打算今天下午 3 点靠卖柠檬汽水挣 15 美元”。大多数人会推荐你设定具体目标，可是清楚自己的抽象人生目标和价值同样重要（我在我的博客 Deep Existence  上写过相关内容）。抽象思维对抽象目标有利，但也会妨碍具体目标所需的自我调节。\r\n\r\n拉博卢（A. A. Labroo）和帕特里克（V. M. Patrick）进行的一项研究表明情绪能对我们的思维产生潜在影响。这些实验涉及各种各样情绪操控技巧（比如让人们“想起一生中最美好或最糟糕的一天”），然后通过测试来测量抽象思维能力或偏好。他们从这项研究的五项实验中得出如下结论：幸福感会促使人们进行抽象思考，这有助于看清全局，但会不利于实现目标，因为实现目标需要具体思维。\r\n\r\n我们能从阿耶莱·费斯巴赫（Ayelet Fishbach）和莱维·多尔（Ravi Dhar）进行的一项研究中看到另一个问题：它认为较早的满足感或对成功较高的期待值会使我们感觉自己似乎已经成功了 。在实验中，一群节食者被分为两组。研究人员只会告诉其中一组他们节食的成果如何，之后两组都会得到一次选择奖励的机会——一个苹果或一块巧克力。不知道自己节食成果的小组中只有 58% 的人选择了巧克力，而清楚自己成果的那一组中有 85 % 的人选择了巧克力，暗示了“我应该得到奖赏”的心理。\r\n\r\n微习惯策略的一个主要优势就是不管感受如何，你都能完成这样的一小步，连实现目\r\n标之前容易让你半途而废的满足感也不会影响到你。因为目标实在太小，你根本找不到正当的借口（幸福感或嗜睡症都不行）跳过它。\r\n\r\n幸福感会削弱你完成具体目标的能力，但因为微习惯的具体部分仅仅是 1 个俯卧撑（举个例子），即使思维处于抽象状态，这个目标还是很容易实现的。而且因为幸福感会提高执行力并把抽象目标看作重点，在实现具体目标之后，你可以利用“想获得健康”这个抽象目标让自己再多做一些锻炼。因为我已经运用微习惯策略获得了成功，所以我感到更加幸福，这的确会使具体的微习惯变得更难实现一些（但还是很简单）。可一旦我开始采用微习惯策略，多写些文章、\r\n\r\n多阅读或塑造好体形这些相关的抽象目标就会更容易完成。\r\n因为微习惯能促进抽象目标和具体目标的进展，所以不管总体上更擅长哪一种目标，\r\n你都能成功。在“挑战 1 个俯卧撑”中，我设定了多个目标才完成 15 个俯卧撑，还记得吗？我要依靠具体、微小的目标才能完成那次锻炼。因为我们每天都要经历心理上的变化，所以这种灵活度对坚持完成目标来说相当重要，它时刻做着应对各种可能情况和挫折的准备。几乎没有什么情况会让你连一个微步骤都做不到，你反而常常会发现自己超越了原定的微习惯。\r\n\r\n在我的三个微习惯中，只有一个有一次没有完成：有一天晚上我忘了读书就睡\r\n着了。微习惯完美适用于任何情绪或情况。你可能开心且动力十足，也可能疲惫而沮丧，甚至可能生病，但是仍然能完成微习惯，可能还会超额完成。\r\n\r\n## 远离恐惧、怀疑、胆怯或犹豫\r\n行动是征服这些消极情绪的最佳武器。迈出第一步会消灭恐惧，即使不是马上消灭，\r\n总有一天也会的。我不再害怕写作，不再因为阅读太少而内疚，现在健身也不再是一项艰巨的任务，而变成了乐趣。如果你经历过一件事而且发现它并不可怕，那么恐惧就会消失。\r\n\r\n微习惯会强迫你迈出第一步，因为这实在太简单了。即使你迈出第一步后马上就回到\r\n了舒适区，明天仍然会走出来，你最终会迈出第二步。微习惯用一种感觉安全、给你力量的方式让你直面怀疑和恐惧。你会发现锻炼并不难，自己也能做到。你会发现每天写作原来是件很轻松的事，而且写作障碍是一种能够促进自己的预期成真的自我实现预言。\r\n\r\n你会开始多读书，家里会变得更干净。你一直以来想做的任何事都可能实现。\r\n微习惯增强正念和意志力，给你超乎想象的惊喜正念是一个人能培养出的最重要的技能之一，它指的是对自己思维和行动有清醒的认识。正念是目标清晰地活着和敷衍地活着之间的区别。\r\n \r\n如果你的微习惯是每天喝一杯水，那么你就会对自己总共喝了多少水有所认识。如果\r\n你必须每天监控一件事，不管这件事有多微不足道，你的意识都会越来越多地关注它，甚至在完成目标之后还想着它。我的微习惯是整天留心哪里有写作的机会，所以我现在对写作特别警觉。你会同时自然地养成一个正念的习惯，它会对未来你修正习惯（包括坏习惯）有所帮助。\r\n\r\n另一个惊喜是意志力的增长。意志力需要原始力量，但更需要耐力，所以频繁重复小\r\n任务就是“锻炼”意志力的理想方法。你的意志力越强，对自己身体的控制就越好。\r\n许多人成了自己身体的奴隶，不断回应着自己的每一个情绪和心血来潮的念头。他们\r\n认为如果当时不想做一件事，自己就做不到这件事。增加微习惯是解决这个问题的好方法，与此同时还能提升意志力。\r\n\r\n说得够多了，开始说怎么行动吧。下一章会教你如何建立受益终生的微习惯。\r\n', '1', '1', '2019-01-15 07:48:54', '2019-01-15 08:18:19');
INSERT INTO `posts` VALUES ('38', '13', '0', '39', '周二打卡（0115）-1', '1-微习惯是什么\r\n2-大脑的工作原理\r\n3-动力 v.s. 意志力\r\n4-微习惯策略\r\n5-微习惯的独1-微习惯是什么\r\n2-大脑的工作原理\r\n3-动力 v.s. 意志力\r\n4-微习惯策略\r\n5-微习惯的独特之处特之处', '1-微习惯是什么\r\n2-大脑的工作原理\r\n3-动力 v.s. 意志力\r\n4-微习惯策略\r\n5-微习惯的独特之处', '1', '1', '2019-01-15 08:17:42', '2019-01-15 08:19:37');
INSERT INTO `posts` VALUES ('39', '4', '0', '39', '10分钟熟悉git的一些命令以及多人合作流程', '熟悉git的一些命令', '工作区->stage暂存区->master分支，开发新功能最好新建分支\r\n## 第一部分\r\n```\r\ngit init  初始化仓库\r\ngit add   添加文件到暂存区\r\ngit commit -m “xxx”提交文件并备注更改内容，这里只会提交git add的文件，如果add后又更改文件，需要再次add\r\ngit status 查看仓库状态\r\ngit diff比较文件的新老变更,工作区和暂存区的不同。加上–cached可以比较暂存区和分支的不同 。用git diff HEAD xx.txt可以比较工作区和分支的不同。\r\ngit log查看从最近到最老的提交日志，加入–pretty=oneline可以把每次合并成一行输出，加上–graph可以图形显示，加上–abbrev-commit仅显示sha1的前几个字符\r\n```\r\n\r\n## 第二部分\r\n```\r\ngit reset 还原版本–hard HEAD^。HEAD^上一个版本HEAD^^上上一个版本。HEAD也可以用版本号表示，不用写全，确保不会重复就行\r\ngit reflog查看自己的操作日志，从里面可以查到版本id\r\ngit checkout — xxx.txt让文件回到当前分支检出的状态，–后面有个空格，如果已经执行了add，要先执行git reset HEAD xxx.txt\r\ngit checkout -b dev 创建dev分支并切换到dev分支.相当于先执行git branch dev再执行git chekout dev\r\ngit rm test.txt 删除文件，删除后记得提交自己删除的动作，git commit -m ‘rm’ ，如果本地删错了，可以git checkout — xxx.txt回退回来\r\ngit remote add origin git@php-fixer/repo-name.git 将本地和远程相关联\r\n```\r\n## 第三部分\r\n```\r\ngit push -u origin 分支名 将本地内容push到master分支\r\ngit branch -d 分支名 删除某个分支，-D为强制删除\r\ngit branch -a 查看所有分支\r\ngit merge 分支名 合并某个分支到当前分支，执行时可能会有冲突，需要手动解决冲突，默认使用Fast forward模式,加上–no-ff可以禁用FF模式， git merge –no-ff -m ‘merge with –no-ff’ dev这时最好加上备注，因为这种提交是能从历史记录中看到的。\r\n```\r\n## 第四部分\r\n```\r\ngit stash 暂存已经add的文件，并使工作环境clean\r\ngit stash list 展现已经暂存的快照列表\r\ngit stash pop抛出所有的暂存快照\r\ngit stash apply stash@{0} 用于多次stash，只取出其中一个快照\r\ngit stash drop删除快照\r\n```\r\n## 第五部分\r\n```\r\ngit remote -v 查看远程库信息\r\ngit rebase 可以把本地未push的分叉提交历史整理成直线\r\ngit tag 查看当前tag列表，后面跟参数v.1.x是 打tag包，还可以加上coomit_id进行打包具体的提交点，使用-d参数进行删除指定标签\r\ngit push origin tag名字 可以将标签推送到远程服务器git push origin –tags可以推送所有未推送的本地标签\r\ngit push origin :refs/tags/<tagname> 远程删除一个标签\r\n```\r\n\r\n## 多人合作流程\r\n```\r\n1：git push origin/分支名 往git服务器推送自己的修改\r\n2：如果推送失败，使用git pull试图合并\r\n3：如果合并有冲突，在本地提交\r\n4：没有冲突或者解决掉冲突后，再用git push origin 分支名推送就能成功。\r\n5：如果远程拉取git pull报错，使用git branch –set-upstream-to origin/分支名与远程仓库建立关联。\r\n```', '1', '1', '2019-01-15 10:44:58', '2019-01-15 11:10:33');
INSERT INTO `posts` VALUES ('40', '14', '0', '2', '6-彻底改变只需要八步', '一个得不到执行的念头只会消亡。 ——罗杰·冯·欧克', '```\r\n一个得不到执行的念头只会消亡。   ——罗杰·冯·欧克\r\n```\r\n\r\n真正有趣的事现在才刚开始。这是个一步步教你选择和执行自己微习惯的应用指南。\r\n\r\n我建议你现在拿出一个便笺本和一支笔，看完以下内容后，写下自己的计划和策略。\r\n\r\n### 第 1 步：选择适合你的微习惯和计划\r\n把你想在某一时刻拥有的习惯列成一张简要的清单，重要的习惯会很快浮现在你脑海\r\n里。它将成为你在第一步的参考清单。我在 minihabits.com 上列举了一些备选习惯，不过它们已经是缩小版的，你现在可以把这些微习惯记下来，只要清楚它代表的完整习惯是什么就可以了。\r\n\r\n“1 个俯卧撑”代表的是广义上的健身，或者每天做 100 个俯卧撑这样更大的目标。\r\n\r\n你也可以一开始就写下完整的目标。\r\n\r\n如果你同时还有几个急于建立的习惯，那么你会很难努力养成一个习惯。为了稳固地\r\n养成一个习惯而在几个月里忽略其他所有事情，需要强大的自律才能做到。为了养成能受益终生的习惯，这样的牺牲倒也值得，但困难就是困难。\r\n\r\n好消息是，我之前已经提过，你可以一次建立多个微习惯！因为微习惯对意志力的消\r\n耗很少，而且非常灵活，只是在初始难度和超额完成量两方面有所不同。我超额完成的写作量比超额完成的阅读量更多。写作是我的首要工作，所以我投入的努力自然最多，即便如此，我现在的阅读量还是比之前多了不少，而且我的阅读量偶尔会比写作量还多。你一定会喜欢这种灵活度，因为它会让你有空参加聚会，旅行或做日程之外的一些其他的临时活动。\r\n\r\n最近，我在努力培养三个微习惯，而且很成功，如果算上锻炼就是四个了，但它已经\r\n成为一种习惯——我一周健身 3 次。每周，我都会按照计划健身，这个过程中已经不会出现意志力不足的问题了。现在，我的大脑更愿意鼓励锻炼，而不会抵触它了。\r\n我建议你同时追求的微习惯数量不要超过四个（四个可能太多了）。虽然这些习惯很\r\n容易单独完成，但是数量越多，你的精力就会越分散，就越有可能忽略或者忘记其中一个。\r\n\r\n不仅如此，设想一下每天必须实现 100 个微小的目标，天哪！每天都要做一定数量的事情，就会出现意志力损耗。对许多人来说，两到三个微习惯是最合适的量。\r\n\r\n下面有一些习惯计划供你选择。\r\n\r\n## 一周弹性计划（推荐）\r\n根据这个计划，你从一个习惯开始，使用微习惯策略一周时间，然后进行评估并选择\r\n一个长期计划。\r\n\r\n一周评估：你有没有感到筋疲力尽？是否发现自己每天都能轻松超额完成目标？完成\r\n这些目标是否不费吹灰之力，让你渴望培养更多好习惯呢？你可以继续专注于一个习惯或者增加更多习惯，这要看它对你来说有多大的挑战性。因为并不是所有习惯的难度都一样，所以确定一个适合所有人的固定时间长度显然不可能，这么做也不明智。同时，请记住：你的微习惯越多，超额完成的可能性就越低。\r\n\r\n最后，考虑一下你过得最艰难的一天会是什么样子的。也许你要开一整天车，或者在\r\n准备一个大型聚会——在这种情况下，你还能完成微习惯吗？不要设想最轻松的时候，要设想最困难的时候。如果你在疲惫、压力山大、极其忙碌的时候还能完成某件事，那么你每天都能完成它。\r\n\r\n现在，如果你感觉自己的意志力能再应付一个（或两个）微习惯，就把它加进来！请\r\n注意，我没有提到你的时间计划，因为所有微习惯加在一起也用不了 10 分钟就能完成。\r\n\r\n谁都能给重要的事情腾出 10 分钟来。\r\n\r\n我把一周弹性计划推荐给想尝试微习惯策略，但不确定什么最适合自己的人。该计划\r\n会自动成为其他计划中的一个。\r\n```\r\n警告：在日历上标出一周计划很重要，这能让你切实履行计划的那一天所需完成的任\r\n务。切记，不可中断！\r\n```\r\n\r\n##单一微计划\r\n能持续写作是你最想达到的目标吗？你想认真健身吗？你想每天投入地阅读吗？这个\r\n单一微计划把你所有的注意力都放在一个计划上，因此成功率相当高。我从“挑战 1 个俯卧撑”时就开始这么做了，当时我对自己的要求就是每天至少做一个俯卧撑。如果你的意志力和我当时一样弱，或者你情绪很低落，一个习惯也许是你能应付的最大量。你总得从某个地方开始。\r\n\r\n如果此刻对你来说，某一个目标的重要性远远超出了其他目标，我就会把这个计划推\r\n荐给你。对自控力很弱的人，这一计划也是个好选择，因为可以帮助他们改善自控力。记住，增加新的微习惯总是很轻松，但是必须放弃一个却很艰难。\r\n\r\n## 多项微计划\r\n\r\n这是我目前的策略，也是最高级的一个，但这并不代表初学者就难以通过它取得成功\r\n。我有三个微习惯，可是你会发现其中两个其实是一回事：\r\n```\r\n一，我每天至少要为各种杂七杂八的事写 50 字；\r\n二，我为了著书每天至少要写 50 字；\r\n三，每天至少阅读 2 页书。此外，每周健身 3 次已经成为常规习惯（从“挑战 1 个俯卧撑”发展而来的）。\r\n```\r\n即使面对三个各不相同的目标，如果有必要，我也能花不到 10 分钟轻松完成整个任务清单。\r\n\r\n如果你真的刚开始就想尝试四个甚至更多微习惯，请随意。也许你能成功，但是，如\r\n果数量多到你无法持续完成，我不希望这么好的策略毁在你面前。每一个微习惯都超级小，每天完成所有微习惯只需要少量的意志力和自律。而且微习惯的目标是 100% 成功，而不是  95%。如果你只在一个微习惯上失败，也不会有完全成功的感觉，而完全成功的感觉对维持较高的自我效能感很重要。\r\n\r\n你的微习惯的理想数量是多少，在很大程度上取决于每一个微习惯的难度。对大多数\r\n人来说，喝水比健身计划（即使经过缩小）更简单。那些需要开车去某个地方的计划是更加困难的选择，主要因为它受到了可行性、地点等因素的影响。因为我去哪里都带着笔记本电脑，所以我的习惯实现起来很简单。之前，我会认为“因为要出去度两天假，所以我没法写作了”，如今再也不是这样了！现在，我在度假的时候也能有所产出（我知道你在想什么，但是如果我想放松，可以只完成最小的目标）。\r\n\r\n如果你渴望养成好几个习惯，或者不满足于一次培养一个，那么多项微计划就很适合\r\n你。\r\n\r\n如果你不确定哪一种计划最适合你，那就选择弹性计划，然后暂时挑选一个你最想建\r\n立的习惯吧。在这一步，不用害怕写出自己目标的完整形式（例如坚持每周健身 5 次）。\r\n\r\n现在，你应该已经选好了一个习惯计划，你想养成的完整习惯可能包括健身、写作、\r\n阅读、喝水、感恩之心、冥想、编程等，接下来，我们就要缩小这些计划了。\r\n\r\n## 把你的习惯变成“小得不可思议的一小步”\r\n微步骤之小会让我们感到荒唐，这可能是社会标准、更高更大的思维习惯以及自尊心\r\n导致的。“我能轻松完成 20 个俯卧撑，”一个人可能会这样想，“所以没必要说只做 1 个。”但这种思维只考虑到了一种力量（身体力量），而每一个可能的行为——比如 20 个俯卧撑——同时还对意志力有要求。\r\n\r\n如果你动力满满、精力充沛而且体形良好，那么 20 个俯卧撑也许不会“消耗”太多意志力。可是如果你已经有点累了，而且并不太想这么做，那么不仅你的意志力水平较低，这个活动还会“消耗”更多意志力！人们在设定目标时经常犯的一个错误就是没有把动力和精力水平的剧烈波动考虑在内，而是假定到了实施行动的时候，他们能维持或重新激活当前的精神和精力状态。紧接着，他们和不愿（向理想状态）转\r\n变的大脑战斗，而且注定会输。可是这一次，我们要骗过大脑，赢得意志力的比赛。\r\n\r\n我的经验法则是把我想要的习惯缩小，直到小得不可思议为止。当某件事听起来“小\r\n得不可思议”时，大脑会认为它毫无威胁。对于大多数人来说，下面这些例子听起来就小得不可思议：\r\n```\r\n“一天 1 个俯卧撑？”你在开玩笑吧！\r\n“每天扔掉一件物品？”毫无价值！\r\n“一天写 50 个字？”你什么也发表不了！\r\n```\r\n你在实践微习惯的过程中会掌握一项技能——如果感到抵触，那就找到有创意的方法\r\n让行动变得越来越小吧。如果你今天抵触做 1 个俯卧撑的目标，那就摆好俯卧撑的姿势，或者更简单，趴在地板上；如果你的微习惯是每天喝一杯水，那么可以简化目标，向杯中倒满水，接下来再拿起杯子；如果你的微习惯是每天写 50 字但内心有抵触情绪，那就打开文档，写一个字。因为你的微习惯已经“小得不可思议”了，所以大部分时间你都不需要这么做，可是每当遇到极端抵触情绪时，记住，你可以用这个方法。\r\n\r\n微习惯没有“过小”一说。如果你不确定选哪个习惯来培养，就选择更小的那个吧。每天都要重复这种小到不会失败的行动就是微习惯策略的关键所在。想看看更多富有操作性的微习惯策略思路，可以访问 minihabits.com 网站。\r\n\r\n把想法变小和把微习惯变小一样重要。你必须像接受完整目标那样接受微目标。这就\r\n意味着如果你实现了微目标，今天你就成功了。如果能做到这一点，你就会得到你想要的“大”收获。\r\n\r\n## 如何培养每周微习惯\r\n我发现有些事情不适合每天做。许多人一个星期只会锻炼三到五次，如果现在每周只\r\n健身三次，谁会愿意一周七天都去健身房呢？\r\n\r\n以周为单位的习惯需要更长时间才能养成，但是它们耐久性强，最终被大脑认可为一\r\n种模式。所以，如果你真想设定每周微习惯，试一试吧，看看效果怎么样。然后，我们可以用有创意的方法将每周习惯转变为每日目标。比如，如果你想每周开车去健身，就设定一个混合微习惯吧。\r\n\r\n当你在两个选项（做 A 还是 B）之间选择时，可以使用混合微习惯策略。我不是特\r\n别喜欢混合微习惯，因为它们会增加意志力的消耗量（做决定也会消耗意志力），可在有些情况下它们是最佳选择，而且它们可以敦促你每天都能做成某件事，这点我很喜欢。\r\n\r\n混合微习惯的例子：\r\n```\r\n● 开车去健身房或花 1 首歌的时间跳舞\r\n● 开车去健身房或做 1 个俯卧撑\r\n● 开车去健身房或慢跑 1 分钟\r\n```\r\n有了这个例子，你不在状态的时候就有备选活动了。你可能会问：“我们不是每天都\r\n会选择更简单的事做吗？”首先，在没人对你提出任何额外要求时你会做什么？我觉得这个问题的答案会让你感到惊讶。用聪明的方式给自己适度自由，是增强自控力的好方法。\r\n\r\n而且你确实想变得更健康，对吧？其次，这里说的微习惯只是开车去健身房而已，如果你想，完全可以开车回家。虽然听起来有些不合理，但我必须强调从繁重的 45 分钟锻炼中给自己找到一条退路的重要性。你的潜意识很清楚，写在纸上的目标并不是你的真正目标，当我们强迫自己做出令人胆怯的承诺时，我们变化缓慢的大脑是会反抗的。\r\n\r\n对于混合微习惯，我建议在开始时不要设定任何限制。看看你决定多久去健身一次。\r\n如果你似乎根本不想选择健身，那在一开始，你可以规定每周必须健身一天，之后再慢慢升级到每周两天。但一定要慢慢来，别急于实现变化，因为大脑不能也不会很快改变。\r\n\r\n既然大脑会慢慢来，那么让自己舒服地适应变化是最符合逻辑的做法。\r\n好了，现在仔细核对你的清单：\r\n```\r\n● 你是否选出了适合自己的微习惯计划？你选择的是弹性的、单一的还是多项的？\r\n● 你的微计划是否小得不可思议？把它们大声念出来，如果你笑了，它们就合格了。\r\n● 是否把所有内容都写下来了？用废纸也可以。\r\n```\r\n\r\n如果这几个问题都解决了，那太好了！让我们进入第二步。\r\n\r\n## 第 2 步：挖掘每个微习惯的内在价值\r\n所有人都偏爱健康的身体，但并不是所有人都愿意为了达到最理想的健康水平而辛苦\r\n付出。整天吃快餐、看电视也有好处，如果你一直以来的问题是想做一些事，却为要不要做这些事而苦恼，那么你就选对书了。\r\n\r\n想知道习惯是否值得我们付出努力的最佳方法是先认清来源。最好的习惯直接源于你\r\n的生活观念。来自同龄人的压力和别人对你的期待并不是我们要寻找的想法来源。如果你是因为别人或者社会的观点才努力改变自己的，我猜你知道接下来会发生什么，但我还是要说出来：强烈的内心抵触。\r\n\r\n用“为什么钻头”找到来源钻头负责钻东西，这就是它们的使命。我之所以把下面的内容叫作“为什么钻头”，是因为“为什么”这个简单的问题是打入任何事物核心的最佳方法。\r\n\r\n列好习惯后，看看你为什么想要实现它们，但别在这一步就停止。再问问为什么，不\r\n断地问下去，直到形成循环和重复为止，因为这时候你已经找到了核心。想让这个方法奏效，就必须诚实地回答问题，所以请深入挖掘。有些问题的答案不止一个，所以尽量选择最相关的。下面我举的两个例子都是真实而诚恳的。一个是建立习惯的好选择，另一个则极不可靠。\r\n\r\n### 第一个例子：\r\n```\r\n我想每天写作。为什么？\r\n因为我热爱写作。为什么？\r\n```\r\n因为这种表达想法、讲故事的方式是我最喜欢的。我能通过写作和人们建立起联系并\r\n帮助他们，更何况我很享受这个过程。为什么这一点很重要呢？\r\n\r\n因为这些事情让我感觉特别有活力、特别幸福。为什么？\r\n\r\n因为写作是生活中我认为有价值并极为重视的事情。\r\n\r\n\r\n### 第二个例子：\r\n我想每天早上 6 点起床。为什么？\r\n因为成功人士好像都是这么做的，而且赖床很丢人。为什么？\r\n因为我感觉，熬夜并在 6 点后起床是不被社会主流观念认可的行为，我认识的一些人也会因此鄙视我。\r\n\r\n在第二个例子中，你能看出改变自己的主要原因是外部压力。即便如此，早上 6 点起床仍然能让我更开心。因为我对早起还是晚起有一些先入为主的观念，所以如果我更早起床，我会有更高的成就感，而且还会减轻内疚感，所以这可不是随口说说的话，但要与写作（我写这段话时正值深夜）一类事情相比时，我并不打算给它优先权。我熬夜写作到很晚的选择是我内在价值的真实体现，即使全世界都不同意，我也不会动摇。就算全世界都反对你的做法也没关系——别因为胆怯而选择不适合你的生活方式。\r\n\r\n### 第 3 步：明确习惯依据，将其纳入日程\r\n培养习惯的常见依据有两种，时间和行为方式。如果你打算根据时间来选择习惯，可\r\n能会说 “我打算周一、周三和周五下午 3 点锻炼”。如果你打算根据行为方式来选择习惯，可能会说 “我打算吃完最后一口午饭之后 30 分钟再去锻炼”。\r\n\r\n从事朝九晚五工作的人群的日程非常规律，所以对他们来说，根据时间来选择习惯通\r\n常效果很好。而对那些日程比较灵活的人群来说，根据行为方式来选择习惯也许更好，因为这可以帮助他们维持一种稳固而有弹性的日程安排。选择运用哪一种依据都取决于你（想要）的生活方式。\r\n\r\n根据时间制定的日程安排非常严格，不会出现含糊不清的情况（比如“下午 4 点准时开始”），这有助于你完成工作，同时培养自控力。不足的一面是缺乏灵活度——也许下午 4 点你正感到头疼，却被规定要完成一些运动量较大的任务。生活总是不按照你的日程安排走。你错过习惯依据，任务拖到后来才完成，就会陷入一种不知该感觉成功还是内疚的尴尬处境。\r\n\r\n根据行为方式制定的日程安排更灵活，同时也会更含糊。它们有助于你在缺乏规律的\r\n生活中培养出规律，而麻烦在于怎么精确判断一项活动什么时候结束，另一项什么时候开始。如果我打算在一家餐厅吃完午饭之后开始写作，那我要不要在开始写作前先进入状态，之后再查看邮件呢？我必须直接打开电脑吗？你可能会想“这又不重要”，但这其实很重要，因为正如微习惯的力量所示，小任务能轻易扩展成更大的任务。习惯可能会让你开始整理桌面，然后你会想起“哦，我是应该写作了”。微步骤能让我们开始，并能让我们积聚动量冲向一个有意义的目标，可是它也会帮倒忙。如果你允许自己退一小步，很快就会发现它会违背你的意愿，愈演愈烈。\r\n\r\n到底要根据时间还是行为方式进行选择？这个问题并没有那么重要，两种方法的效果\r\n都很好。重要的是你要选择，而且要选得坚决。如果这个时候不做出决定，你就错得离谱了，但在你做出最终选择之前，还有一个选择可能会让你吃惊，它是我偏爱的选择，适合我目前的全部微习惯。\r\n\r\n## 自由度高的非具体习惯\r\n\r\n传统的习惯类书籍会告诉你完成习惯的过程为“选择依据—采取行为—获得回报”，这\r\n是从众多研究中得出的习惯结构，然后会继续告诉你下一步显然应该是挑选你的习惯依据，接着采取行为和获得回报。但如果你的目标是希望自己的思想在总体上变得积极些该怎么办？如果你希望在弹性时间里完成任务该怎么办？这时，微习惯为你打开了一种可能的新领域。下面具有弹性的日程安排尤其适合养成感恩心态等非具体习惯。\r\n\r\n微习惯的根源在于自主、自由和灵活度，其目标是给予你能量，让你不断取得成功。\r\n通过设定一个不规定具体完成时间的 24 小时时段， 我们可以用这套方法来改善过于具体的习惯依据。\r\n\r\n所有人都认为好习惯应该只有一个依据，但你有没有注意到坏习惯有多个呢？难怪坏\r\n习惯会如此强大！它们蔓延出根须，和你生活中许多不同的刺激紧紧捆绑在一起。这是因为坏习惯会通过不同情况下的重复行为自然发展壮大，而我们的好习惯是通过“单个依据—行为—回报”的方法人为建立的。我承认，如果只选择一个依据，你会更有意识地进行这项行为，比如，你规定自己每天下午 2 点想出两个积极的念头，那么你可能全天都容易把事情往好处想，但每天下午 2 点完成这个习惯的规定会让你感到束手束脚、被人强迫（这要看你的性格了）；此外，如果你设定了做一件事的具体时间，在其他时间完成这件事可能会让你有哪里不对的感觉。习惯上午写作的人中有许多绝不会在一天中的其他时间写作。我能在一天中的任何时间写作，写上一整天也没问题——只要我的日程允许。\r\n\r\n选择具体依据的另一个问题是，它们会给你的意志力增加额外的负担。如果你打算在\r\n今天某个时间跑步，这就是个灵活的依据。如果你必须在下午 3 点跑步，这个依据就不灵活了。执行任务造成的额外压力会增加意志力消耗量。传统习惯策略建议你在为大型任务做计划时严格规定时间，结果让你更难成功。相反，对我们来说，因为行动是微小的，所以即使是根据依据采取的行动，需要的意志力总量还是很小。因此，微习惯比传统习惯更适用于当前流行的“选择依据—采取行为—获得回报”模型。\r\n\r\n提示：我并不是说不固定的时间一定是更好的选择，只是它们对某些人群和某些习惯\r\n来说更好而已。你应该根据每一个习惯来做选择。\r\n\r\n非具体习惯指的是有多个行动依据的习惯。大多数人已经有了一些非具体习惯，比如\r\n吃饭、娱乐、心不在焉地浏览网络等。由于我们每天要接收的刺激数量惊人，所以给一个好习惯选择多个刺激作为依据似乎很有吸引力。\r\n只凭借一个依据行事会让你难以获得社会机遇和发挥自主性，但在主流习惯理论中，\r\n只选择一个依据是把一件事变成习惯的唯一可行的方法。选择多个依据对意志力的要求太高，而每一个依据又需要单独培养，这样下去很难形成习惯。这就是微习惯有效的原因。\r\n\r\n非具体微习惯要求你每天完成一次小型目标，而且是在你有空的时候。我不推荐你把\r\n半夜作为截止时间，因为这样不够灵活。我建议把上床睡觉作为一天结束的标志。这样你就能抢在最后一刻完成微习惯，所以成功的概率就会达到最高。我也明白这听起来不太好，但在微习惯的初始阶段，这个方法能实现一个重要的目的——不断给你成就感，从而提升你的自我效能感。\r\n\r\n我花了好几个月时间“挑战 1 个俯卧撑”，早期，我选择的依据俗气得令人尴尬——在睡觉（截止时间）前。这说明我相当不自律，因为我没能在白天把这项习惯合理地安排进日程。可是，我还是会带着胜利感进入梦乡（通常还会超额完成），而不是失望地睡着。\r\n\r\n当你在睡觉时心中有成就感，尤其是连续很多天如此时，便会产生想要继续进步的欲望。\r\n\r\n你听说过成功会导致成功吧？事实的确如此。成功者比沮丧者更努力，是因为他们已经成功了。成功能点燃热情、激发行动。微习惯策略也会帮你做到这一点，你会很有成就感，而让自己有继续成功的愿望。我这么说不仅因为我是本书作者和这种策略的推广者，还因为它的确让我获得了成功。我之前试过很多其他体系，而对比之下，微习惯的成果取得了绝对的胜利。\r\n\r\n让我们重新审视我做俯卧撑的故事。以“在最后一刻获得成功”的方式完成任务一段时间后，我希望能做得更好。于是我开始提前完成俯卧撑。时间仍然在不断变化（依据不同），所以在睡觉前完成最小任务量也是可以接受的，这能鼓励你自己培养自律性。真正的自律不是找个人命令你做俯卧撑，而是你自己决定完成。\r\n\r\n虽然我在阅读、写作和持续锻炼方面实现了巨大成功，但还是很奇怪，因为我感觉自\r\n己像个骗子。我并没有选择任何“习惯依据”，可所有关于习惯的书中都出现了依据的概念，习惯的科学认为它们是必不可少的。我只有每天的目标和一周的锻炼任务。按照常理，这就是人们无法培养习惯的原因，而我却格外成功。这是为什么？\r\n\r\n我意识到的第一件事是，这些研究测试的都是疯狂消耗意志力的大型目标，像早上 6点出去跑步，每天做 100 个俯卧撑，或者坚持一个健身项目。而我发现微习惯完全不同，所以有些规则发生了变化。\r\n\r\n微习惯小到不可能失败，所以有没有依据无所谓。\r\n\r\n你永远都能在睡觉前完成习惯（总体来看，每个微习惯只需要大约一分钟就能完成）\r\n，而且这种每晚一次的习惯检查也会变成习惯，这多好啊，因为它能让你的大脑保持对生活的专注度。“今天我完成简单的目标了吗？完成了。太棒了！”睡觉。\r\n如果你有一个小到不可能失败而又没有依据的习惯，会怎样呢？你会发展出多个习惯\r\n依据。这真的很令人兴奋。虽然我特别喜欢早晨动笔，也许会选择培养一个早晨写作的习惯依据，但是拥有一个不指定具体时间的写作习惯也是一件很棒的事。对我来说，写作与坏习惯的结构很相似，我知道我有一些具体的依据（比如吃完东西以后），但是因为我有多个依据，所以看起来我只是想写就随手写了。\r\n\r\n等等，如果养成只带一个依据的习惯都需要一个月，那建立多个依据得花好几年吧！\r\n不用。微习惯极其微小，非常简单，还记得前文说的那个关于形成习惯所需时间的研究吗？结论是，一个行为转变成习惯所需时长的决定因素是其难度。这就意味着微习惯策略能比传统习惯策略帮助你更快地养成习惯。当然了，需要提醒你的是，当你的目标是 50 字，而你每天写 2000 字时，把 2000 字变成习惯需要的时间也许会更长。但是，如果你能下狠心把 50 字的目标拓展到 2000 字的程度，那有这样的“问题”也没什么大不了的。没错，如果你没有一个具体的依据，大脑就需要更长时间才会把行为当作习惯。所以，如果你想给生活添加 10 个习惯，而且想快速实现，给微习惯选择具体依据会更快一些。而另一方面，如果你想把一项行为灵活地融入你的个性和日程中（就像我养成写作习惯一样），那就把它变成非具体微习惯吧。\r\n一些可供选择的依据：\r\n```\r\n● 每天完成一次非具体微习惯行为。\r\n● 根据时间进行的微习惯行为可在下午 3:00 或晚上 9:45 等时间完成。\r\n● 根据行为方式进行的微习惯行为可在吃完午饭以后、开始工作之前、开车时、如厕\r\n```\r\n后等时间完成。\r\n\r\n我的非具体微习惯体验\r\n\r\n有些人会在上午写作，而我会选一天中的任何一个时间写作。对我来说，写作已经变\r\n成一种生活习惯了。你知道我现在遇到什么情况了吗？我正在看电视，突然产生了一种要写作的强烈冲动（一件很棒也很怪的事）。但我在和别人一起看电视的时候就不会有这种冲动，因为场景不同。我对各种情况的反应都很自然，同时也在不断变化。如果有一个朋友来我家住几天，我就写得相对少一些，而且这就是我想要的生活方式。如果这个问题不断复发，导致我的工作产量降低，我能调整好。\r\n\r\n你会发现，这对改正坏习惯也有一些积极的影响。坏习惯一旦缺乏约束就会随意发展\r\n，占据你生活的各个角落。你可能有 98 个抽烟的依据，53 个看 YouTube 视频的依据，还有 194 个在网上闲逛的依据。让你的好习惯像这样疯狂发展也是有可能的，就像植物为了营养竞争一样，你的好习惯能把坏习惯挤出你的生活。看，现在对我来说，写作在与看电视竞争。有具体依据的习惯实现的可能性会小一些，因为它们被一个依据固定了。别误解我的意思，它们能变得非常强大，但如果它们不能和坏习惯共用一个依据，就无法起到瓦解坏习惯的作用。\r\n\r\n需要提醒你一句，一定要谨慎决定让哪些习惯充分发展。比如，有些人现在无法放松\r\n，因为他们是工作狂，工作习惯已经深深根植于他们的性格中，因此退休会让他们百无聊赖，无所适从。他们想工作。我已经确定我想写作，而且后半辈子还要大量写作，所以我愿意让写作的习惯融入我的性格（阅读和锻炼也是如此），但是我不确定我要不要把洗澡（一天一次是可以接受的）变成同类习惯。对于这一点，我更喜欢根据依据进行，比如一起床就冲澡。睡眠时间和三餐最好能妥善安排好，这样身体就能分别形成适当的生理和饮食节奏。\r\n\r\n如果你想把某件事变成生活的一部分——这方面的积极例子包括凡事往好处想、写作\r\n、保持感恩心态、锻炼与保持活力、多向他人付出、极简的生活方式等——那我建议你不要给微习惯设定具体依据，只需把“必须在晚上睡觉前完成”作为每天的截止时间就够了。\r\n\r\n如果你希望一个行为能在生活中占据一个你特地为它留出的具体位置，那就给它设定\r\n一个具体依据吧，典型例子包括一周里固定某几天锻炼、睡前阅读和上午写作。有些人喜欢让自己的生活充满规律，所以我们可能只会选择具体依据。这完全取决于个人喜好，你甚至可以选择把“疯狂发展”的习惯和有依据的习惯结合起来。\r\n\r\n##决策时刻\r\n如果你想培养非具体微习惯，对决策过程的了解会帮助你在必要时做出选择。\r\n人们在做决策时有两种思维状态。一种是权衡各种选择的状态，叫慎重心态，另一种\r\n是决定行动的状态，叫执行心态。我们的目标是进入执行心态，而不是被困在慎重心态的层面。\r\n\r\n依据的好处之一就是它们能帮你跨越慎重心态，更快地进入执行心态层面，这可太有\r\n诱惑力了。“执行意向”指提前对自己将在何时和如何做某件事做出决定，而依据正是它的关键因素。众所周知，执行意向能提升目标的成功率。带有一项依据的微习惯成功率会更高，因为它不需要下什么决心，它太小了，根本无须动脑。\r\n\r\n但是，就算没有依据，微习惯照样有效，它们极其微小这一特点让它们越过了与行为\r\n竞争的阶段。所以，如果你没有选择好依据，又要经历慎重心态的过程，决定是否要做一个俯卧撑或者写 50 字不会让你感到迷茫，你很容易把事情想得太复杂。如果发现自己停滞不前，一定要提醒自己，其实你的任务是很微小的，不要想得太难。\r\n现在，把你给每一个微习惯挑选的依据写下来。我喜欢把我的全部依据都放在“一天\r\n一次，随时可做”的保护伞下，这会让事情变得简单。\r\n\r\n## 第 4 步：建立回报机制，以奖励提升成就感\r\n如果你是个申请假释的犯人，你认为你假释听证会的最佳时间是什么时候呢？我来告\r\n诉你，在假释官刚刚吃完东西、结束休息之后。有一项研究发现，法官们在吃饱睡好后做出的判决对被告更有利（大概他们更愿意倾听）。在反映 假释批准率的图表上，在假释官吃饱睡好后的数据有一个明显的峰值。做出像批准假释这样艰难的决定是一种自我损耗——和决定意志力的能量来源一样。而实践证明，食物能将其恢复。\r\n\r\n如果你想养成一个把脸贴在地上吃点土的新习惯，你认为结果会怎样？（假设你确实\r\n计划养成这个习惯。）你做不到，原因显然是“谁会愿意这么干”。但从人类大脑运作方式的角度来看，原因其实是“这么做有什么好处”。这个行为没有相关回报，因此更像是一种惩罚。你的大脑会非常坚决地反对。\r\n\r\n如果你最近没有锻炼，锻炼就像是一种麻烦事。大多数人不喜欢绕圈跑步或爬楼梯，\r\n不喜欢在健身馆里推、拉或举各种重物，因为这样做会带来一种不舒服的感觉。\r\n根据我的经验，我敢说健身这种活动令人感到不舒服的程度比身材走形多三倍。健身\r\n的时候，你的肌肉就好像在说，“嘿，我们在睡觉！”你努力锻炼之后回到家，看着镜子，你获得的回报是……汗水？在这一刻，可能你的大脑在质问你真正的回报在哪里。\r\n\r\n你锻炼的时候，大脑会收到一种天然回报。在做运动时，大脑会释放让人感觉良好的\r\n内啡肽，这种感觉也被称为“跑步者的愉悦感”。有意思的是，举重也会引起内啡肽的释放，可能仅仅因为它是一种繁重而剧烈的运动。因为轻量级或中量级举重不会促使身体转换至无氧状态，所以它们不会触发内啡肽释放。我喜欢作家汤姆·西弗（Tom Scheve）的阐述方式：\r\n\r\n\r\n当你的身体从有氧状态转变为无氧状态，虽然肌肉和细胞急需大量氧气，可\r\n身体却是在没有足够氧气满足肌肉和细胞的情况下运转的，这时候“跑步者的愉\r\n悦感”就出现了。把无氧运动想象成假日的零售商店。身体跟不上正常的运转，所以它必须进入另一种模式以满足更高的需求。\r\n\r\n对大脑来说，内啡肽是一种很好的天然奖品，可它对有些人来说还不足以成为回报，\r\n尤其是刚开始的时候。因为锻炼给人的感觉可能像一种惩罚，你可能需要更大的回报。在军队里，锻炼被当作一种惩罚方式是有原因的。\r\n\r\n锻炼能获得意义重大的重要回报，如发达的腹肌、良好的感觉和健康的体魄，但你的\r\n第一次锻炼距离这些还远着呢；而与此同时，你的大脑却现在就想吃蛋糕，因为糖会刺激味蕾并激活大脑内的回报中心，所以蛋糕是一种感官（或者说首要）回报，而锻炼带来的大多是抽象（或者说次要）回报，比如拥有好身材后在沙滩上漫步、对付出的努力感到满意以及其他高层次想法。你可能猜到了，次级回报需要更长时间才能在大脑里站稳脚跟。\r\n\r\n回报关联刚开始，如果锻炼中产生的内啡肽和你对最终成果的期待不能给大脑足够的回报，你就需要呼叫援军了。世界如此丰富多彩，我们可以在习惯的养成过程中另辟蹊径。我们能做的是将行为与完全不相关的回报建立关联，一段时间过后，大脑就会把这个行为和回报联系起来，这就是我们想要的！之后，大脑就不再需要这个（硬性建立起关联的）回报来促进行动了。\r\n\r\n你有没有想过，为什么这么多食物里都含糖？原因可能是人们会对糖上瘾，从轻度到\r\n中度不等。很多会给予大脑回报的东西都可能让人上瘾。高糖饮食不利于健康，但为了保持一个重要的习惯而摄入少量的糖是值得的，关键在于适度。\r\n\r\n我很喜欢一种给大脑的有创意的回报——大笑，大笑时会释放出让你心情变好的化学\r\n物质。我有时在完成写作任务后会在 YouTube 上看读错唇语的滑稽视频。下次有人看到你在看一段搞笑视频时，告诉他们你在训练大脑吧，这可是科学！\r\n\r\n建立习惯的诀窍就是把它想象成教孩子骑自行车。刚开始，你一边让孩子蹬自行车一\r\n边向他保证你在稳稳地扶着他。可是在某个时候你把手松开后，孩子没有你的扶持也能继续骑车了。与此类似，刚开始我会在锻炼后给大脑额外提供一个回报，但是最终满足感和内啡肽就足以让大脑自己维持这个行为了。它渐渐认识到了这些次级回报的价值，而且它们在许多方面都比高糖分的回报更令人愉快、更牢固，只是需要时间而已。\r\n\r\n对回报的体验终止后，物理方面的感觉会消失，但是拥有好身材或连续 98 天坚持做一件积极的事情带给你的心理感受会一直留存。此刻，我正在看一个巨型墙面日历，上面满是打好的勾，它们会提醒我我已经取得了哪些进步。对着一堆勾感觉良好听起来有些差劲，可是我的大脑清清楚楚地知道每一个标记代表的是什么。事实上，一项研究显示，如果你想更加幸福，享受成就感是让自己对生活满意的最有效的策略。\r\n\r\n这可是对微习惯的鼎力支持，因为微习惯正建立在享受和巧用微小成就感的基础上。\r\n回报策略可是，并不是所有的工作都需要换取回报。好好生活能带来很多乐趣，培养一个好习惯会带给你满足感。这就是说，如果你正在锻炼，可以在几周以后看着镜子，提醒自己这些进步是怎么来的。如果你在写作，为写得满满的文档庆祝一下吧。即使你只是达到了这些任务的最低要求，展望一下你即将养成的好习惯，它能给更多事情打好基础。\r\n\r\n但是策略的确很重要。如果你在使用无依据的策略，可以在实施行动之后再寻求回报\r\n，或关注自己的感受，在你认为需要时奖励自己。微习惯策略提供的满足感比传统习惯更强烈（更强的次级回报），这是它带来的额外惊喜。获得一项重大成就会让你感觉很棒，但你要知道，如果其中的 95% 都是你在计划外完成的，这种感觉会更棒。你在超额完成很多工作后，可能会想奖励自己，以鼓励该行为。\r\n\r\n满足感等抽象回报在很大程度上和你的思维方式密不可分，这就是我强调要庆祝一点\r\n一滴的成功的原因。成功会带来更多成功，因为我们喜欢这种结果和成就感。我们还要学会爱上延迟满足的感觉，对之后更大回报的期待是回报的一种形式，它能对你进行抑制，让你不至于现在就去兑现小回报。你练习和体验延迟满足感的次数越多，就会对它越敏感。\r\n\r\n我的经验法则是在此过程中要让自己感到快乐。快坚持不下去时，我就会给自己一点\r\n奖励，休息一下。\r\n\r\n## 回报对意志力的重建作用\r\n\r\n回报会激励我们重复某种行为，可是你知道它们也能让意志力恢复吗？认知科学家阿\r\n特·马尔科曼（Art Markman）说：“当你站在摆满甜点的自助餐桌前，去找一个朋友，愉快地聊天吧。”\r\n\r\n你可以通过各种类型的回报来恢复意志力，可能你会觉得这个建议匪夷所思。\r\n根据鲍迈斯特的“自我损耗”概念，已有多项研究总结，人们可以通过恢复血糖水平来克服自我损耗。有些科学家想证明另一种因素——回报——对意志力的恢复作用，他们的理论是，也许正是摄入糖分带来的回报让我们得以重建意志力。糖分已被证明能激活大脑中控制回报的部分。\r\n\r\n他们先通过常规锻炼来损耗意志力，然后，一组被试用加入人工甜味剂的溶液漱口并\r\n吐出（人工甜味剂不会激活大脑中控制回报的部分），另一组被试用含糖的溶液漱口并吐出（通过与味蕾接触激活了该部分）。结果显示，用含人工甜味剂的溶液漱口的人群在自我损耗后没有得到改善，而用含糖溶液漱口的人群得到了改善（也就是说，他们的意志力恢复到了正常水平）。后者的血糖水平没有恢复，而意志力水平恢复了，由此可见，他们意志力恢复至少有一部分原因是大脑得到了回报，这对计划减肥的人来说是个好消息，因为这意味着非食物类的回报也许能有效重建意志力。\r\n\r\n当马尔科曼说“去找一个朋友，愉快地聊天吧”，他是在教你通过给大脑回报来重建意志力，然后你战胜巧克力奶酪蛋糕的可能性就会更大（对，我说的是“可能性”）。我们常常借助意志力来避免此类坏习惯，但我们也会用意志力来强迫自己做出积极的举动，所以回报能通过激励我们继续行动、帮我们恢复意志力来让我们坚持良好的微习惯。\r\n\r\n## 第 5 步：记录与追踪完成情况\r\n\r\n当你想到某件事时，立刻把它写下来，就意味着把它提升到了比其他想法更重要的位\r\n置上。一项研究显示，把想法（无论积极还是消极）写在纸上时，会让其在大脑中更加突出，而打字就不具备同样的效应。一定要手写，才能将其重要性放大。\r\n\r\n接下来我将介绍一些追踪进度的策略。不管你选择什么策略，我建议你到睡前再检查\r\n自己是否成功。如果你在白天就早早地检查完毕，完成任务的感觉会降低你继续进行额外工作的动力。另外，养成睡前检查的好习惯，不容易忘记。\r\n\r\n## 大日历（推荐）\r\n我就是用这个策略来追踪自己的微习惯进展的，用的是我房间墙上的一个巨大的日历\r\n。我把微习惯写在旁边的一个白板上，然后每天在日历上核对是否完成（除健身是一周 3次以外，其他一定要每天检查）。在每日表格的左下角，我会记录我是什么时候去健身的，然后在周六（一周最后一天）表格的右上角，我会画一个小的对勾标记。这样，我看到这个角就能立刻知道我这周（或前几周）健身了几次。这样做很简单，但效果非常好。\r\n\r\n保持微习惯几个月以后，给成功完成任务的一天打钩的感觉依然很棒！\r\n\r\n如果你有一个混合微习惯，比如开车去健身或做 1 个俯卧撑，可以这样记录：写字母G 代表健身房，字母 P 代表俯卧撑，这样，你就可以回顾之前的记录，看看你各选择了几次。\r\n\r\n如果你只打算核对天数，另一种可选方式是全年日历。一个好方法是从网上找许多免\r\n费日历，选一个打印出来（比如你的谷歌邮箱日历）。与在电脑上记录相比，用纸笔打钩能让你的成就感更真实。此外，如果你把它放在你经常看到的显眼位置上，会让你对自己微习惯、进度和成功与否更敏感。可别低估了这个方法的效果！\r\n\r\n脱口秀主持人杰瑞·宋飞（Jerry Seinfeld）称得上微习惯领域的先驱，他有一种很有名的做法——他每天都会写一些笑话，这个任务完成后，他会在日历上打一个×。他知道，记录每天的进度是养成习惯、提高自己抖包袱水平的关键。\r\n\r\n一次演出之前，他把自己高产的秘诀告诉了年轻喜剧演员布拉德·艾萨克（Brad Isaac）。布拉德在给“生活黑客”博客写的一篇文章中引用了宋飞的话：\r\n几天后你就会拥有一个行为链。你只需维持住它，随着时间过去，这个行为\r\n链会越来越长。在有了几周的体验以后，你看到它就会很高兴。接下来你唯一要\r\n做的事就是不破坏它。\r\n\r\n这是对微习惯的一次精彩总结。我们不希望破坏这个链条，而破坏它的唯一借口就是\r\n遗忘，因为微习惯简单到不会失败。但遗忘也是个蹩脚的借口，因为你的日历上都写得清清楚楚，而且你每天晚上睡前都要问自己“今天我完成微习惯了吗”。而且我要强调的是，我并不认为微习惯是那种你会在几个月后放弃的心血来潮的行为，而是可以坚持一生的追求。它效果太好、太灵活了，所以你是不会放弃它的！\r\n\r\n一开始就写下你的微习惯，然后随着计划进展检查进度，这两件事对你的成功而言极\r\n其重要。不要跳过任何一步。无论你如何确认自己微习惯的完成情况，我建议你至少要亲自把习惯手写在一个你能看到的地方。\r\n\r\n## 数字化追踪\r\n有些人愿意使用智能手机，虽然我现在更喜欢老式的方法，但智能手机的一些优点不\r\n容忽视。第一是随时可以检查——人们去哪儿都带着智能手机，去国外度假也不例外；第二是随时可见和提醒功能——有些应用能提醒你完成微习惯，可以充当完成任务的具体依据。\r\n\r\nIOS 系统和安卓系统上追踪微习惯最方便的应用有：\r\n\r\n### Lift（IOS 系统，免费）\r\n\r\n如果你想采取数字化方法并有一部苹果手机，那么我高度推荐 Lift 应用。不管你设定什么样的习惯，它都能追踪你每天或每周的进度。它能完美地配合微习惯体系，并能让你看到自己已经连续多少天完成微习惯任务了。它甚至还能把你和其他 Lift 用户连接起来，给你一种找到伙伴的感觉。\r\n\r\n警告：该应用可能会建议你设定一个含糊的目标，像“多喝点儿水”，我就见它推荐过这个目标。千万别这么做。一个人要怎么才能“多喝点儿水”呢？你在洗澡时喝了几滴水能算数吗？含糊的目标无法衡量，而且不能给你像“我成功了”或者“我失败了”这样具体的反馈。具体反馈对加强行为来说非常关键。一定要让你的微习惯非常具体和微小，比如，你可以设定一个喝一杯水的微习惯（可以采取任何依据）。\r\n\r\n### Habit Streak Plan（安卓系统，免费）\r\nLift 也有安卓版本，不过是测试版，而且目前评分是 3.1（总分是 5 分，这个得分不算高）。在安卓系统上人气最高且评分最好的习惯追踪应用是 Habit Streak Plan，你能用该程序设置提醒，每天提示你该完成微习惯了，并（或）提示你在睡前检查微习惯。\r\n\r\n该程序还能追踪你已经完成的天数。如果你在过去 53 天里有一天没完成，它就会显示 52/53。不要找借口，把目标成功率定为 100% 吧，如果有什么出人意料的事情发生了——考虑到目标如此之小，这件事最好确实夸张到让你完不成目标——你有一天没完成，没什么大问题。如果你连续两天都没完成，肯定是哪里出了什么问题。微习惯太简单了，不会连续两天都完成不了的。意外会有，但不会如此频繁。\r\n\r\n再强调一次，不要设定任何含糊的目标。含糊的目标或习惯缺乏明确导向，毫无意义\r\n，是很糟糕的想法。\r\n\r\n### 台式电脑/笔记本电脑的解决方案\r\n对台式电脑用户来说，我认为简单的习惯追踪方案里最好的就是 Joe’ s Goals（joesgoals.com）。它确实很简单。\r\n\r\nLift.do 是 Lift 应用的电脑版网站。上面还有很多在线日历，你可以选用。\r\n我的朋友哈利·切还有一个目标/习惯解决网站，叫作 Goals On Track （goalsontrack.com）。在我用过的所有应用或网站中，我最喜欢这个。我刚开始用时取得了不少进步。切的系统中有一个特别专栏，如果你在为追踪目标和习惯寻找一个一键式的辅助工具，我会推荐这个网站。我能为培养习惯而投入全部精力，但并不是所有人都有这样的愿望或条件。\r\n\r\n总体来说，因为台式电脑和笔记本不具备手机的全天候可访问性，所以我认为用手机\r\n比用电脑追踪更好。\r\n\r\n关于所有数字应用的最后一点说明在这些应用和网站上，你会看到很多小技巧，教你添加应用制作者为你设定好的健康习惯。你需要抑制住马上开始尝试这些习惯的冲动，除非它们已经被缩小过了（这不太可能）。如果你确实很喜欢其中某一个，一定要先把它缩小，然后再添加到自己的任务列表里！尝试每天做 100 个俯卧撑看起来有趣，可当你做不到而放弃的时候就不好玩了。把目标定为每天 1 个俯卧撑，然后连续 200 多天超额完成目标才更有趣。你可以在 http://minih\r\nabits.com/mini- habit- ideas 上找到微习惯的更多点子。该网页会定期更新，增加新的习惯和“组合计划”，即一些你可以尝试的习惯的集合，它们在一起完成时效果很好。组合计划主要是为了增加趣味性，所以你还可以给自己起一些外号，比如“肌肉作家”就包括以下这些日常习惯：\r\n```\r\n● 做 1 个俯卧撑（或另一个关于锻炼的微习惯）\r\n● 写 50 字\r\n● 阅读 2 页书\r\n```\r\n\r\n## 第 6 步：微量开始，超额完成\r\n我们明明可以设定更高的目标，为什么还要制定这么小的习惯呢？而且如果你在完成\r\n小目标之后就停了怎么办，它还有用吗？答案是有用，而且和意志力关系很大。\r\n意志力的优点是它可以得到强化。非常自律的人是指那些已经强化了自己意志力的人\r\n。可是，这只能帮他们开始行动而已。你在健身房里看到的那些壮汉已经不再需要强迫自己锻炼了。事实上，因为锻炼已经变成他们大脑的第一偏好，所以他们不再需要意志力了。在培养一个习惯时，你会说“大脑，我们需要锻炼了”，然后你的大脑会回答“我已经在往跑步机那儿走了，快跟上”。\r\n\r\n在建立习惯的道路上，我们想做三件事：\r\n```\r\n● 强化我们的意志力\r\n● 当下就取得进步\r\n● 不耗尽意志力\r\n```\r\n这三件事里有任何一个出错都会带来问题：谁希望看到自己总是缺乏自控力呢？谁愿\r\n意先“训练”上 3 个月然后才能在生活中取得一点进步呢？谁会希望自己意志力耗尽呢？呃……没有人。\r\n\r\n看到这三个苛刻的要求，你可能没有信心找到一个可行方案，但是微步骤策略可以满\r\n足以上三点。后面我会一个一个说到。\r\n\r\n## 强化意志力的微习惯\r\n\r\n如果你拥有强大的意志力，却只能每天持续 2 个小时，那它又有什么好处呢？我们希望意志力能维持一整天。健身房里的耐力训练要求你多次反复举起较轻的重量，这是在训练肌肉的持久性。微习惯的原理是一样的：我们给自己制定意志力要求较低但是频率很高的任务。完成 1 个俯卧撑需要非常少量的意志力，但可能会比预想中多一点——万事开头难，尤其是与意志力有关的事情。\r\n\r\n久而久之，像这样反复不断地强迫自己执行可实现的任务，我们的意志力就会变得更\r\n强大。这就叫练习。\r\n\r\n### 带来进步的微习惯\r\n微习惯策略最大的问题当然是一天只做 1 个俯卧撑或每天只想 1 个积极念头的意义有多大。有一种答案是，你自己试一试，看看实际情况怎么样，但该问题仍然需要一个有逻辑的说明。如果一个行为从数量上看过于渺小，那它如何能给你实打实的成效呢？有两种方式。\r\n\r\nA. 微习惯超额环节： 看到自己采取行动比任何其他事都更激励人心，更能激发动力。事实上，这正是微习惯的一个关键策略——一旦你有了做某件事的充分动力，就不需要意志力了。虽然我们完成这些微习惯时依赖的完全是意志力，但我们选择在达到目标后继续努力时，动力就会起作用了。我发现，我常常在开始建立某个习惯后变得动力十足，而相比之下，在开始行动之前就有充足动力的情况并不多见。微习惯和动力并不冲突，它们能增加意志力。此前，整整十年里，我都没能激发动力，所以我对它相当熟悉，而且还有些不满。\r\n\r\n开始任何一个微习惯时，我几乎总是超额完成。“总是”指的是超过 90% 的情况，“超额”是指超出很多。乐事薯片有句很有名的广告语“停不了的乐事”。好吧，我敢担保你肯定不会只做 1 个俯卧撑或只写几个字，你一旦开始，就会希望多完成一些。到那个时候，继续做就和停下来一样容易了。可是，如果你没有继续该怎么办？如果你只是每天刚好完成最小目标该怎么办？一切都完了吗？不，完全不。\r\n\r\nB. 微习惯安全网（培养实实在在的微习惯）： 你采用微习惯策略的目标是争取一天写 50 字，然后养成每天写 2000 字的习惯，可这也许不能立刻做到。如果你仅仅完成微目标，但依然坚持微习惯，它最终会形成习惯，因此更容易超额完成任务。我知道，对一些人来说，最大的障碍是耐心。你不想成为那个每天写 50 字的人——你想让自己迅速变成每天能写出 4000 字的人，尽快实现梦想。我有个好消息要告诉你。如果你能一天写 4000字，那就写吧，对微习惯来说，不存在上限。你可以把自己累垮，让自己疯狂工作。只要你能保证第二天仍能达到最低要求，就没有问题。\r\n总结一下，如果你只能达到最低目标，它还是会成为习惯（而且相对很快，因为量很\r\n小）。一旦它成为习惯，你会处于在它基础之上进一步发展的完美位置。我说的就是字面意思——超额完成一件事情的完美基础是，这个行为习惯已经存在。\r\n记住这点：微习惯绝不会阻碍你进步，就好像火花绝不可能阻碍一场大火的蔓延一样\r\n。微习惯就是拥有无限潜力的火花。“常规习惯”可能是每天写 2000 字，但这既可能是上限又可能是底线。写到 2000 字时你会感觉很满足，然后告诉自己，“这就够了”。制定 50字目标策略后，我曾经在一天里写了 5000 多字。理解这一点相当重要，因为思维模式错误的人会认为过小的目标会阻碍他们进步。在某一时刻，那个火花会变成一小团火焰，不久后，我们就会一边在一堆巨大的篝火上烤棉花糖，一边讲述多年以前的故事了。\r\n\r\n你现在只要想得到进步，就能得到。如果你愿意，就让自己累得筋疲力尽吧。我之所\r\n以这么说，是因为应用微习惯策略后，很多人都能从一开始就获得强大的动力。\r\n\r\n### 减轻意志力损耗的微习惯\r\n我在之前的章节中就提到了这一点，而真正让微习惯策略脱颖而出的是，你绝不会有\r\n失败的借口，绝不会害怕失败，而且绝不会感到内疚。即使你的意志力已经耗尽，微习惯的任务要求是如此之低，你总能找到方法完成。在我的记忆里，没有哪一次我的意志力会弱到让我无法完成一个俯卧撑、 读几页书或写 50 字。一次都没有。\r\n\r\n因为以上这些原因，微步骤不会阻碍你进步——它们反而是取得成功的关键。\r\n\r\n## 第 7 步：服从计划安排，摆脱高期待值\r\n\r\n期待值是生活中一种复杂的东西。经常对自己有较高的期待值是很有价值的，因为这\r\n能提高你的目标上限。换句话说，如果你自己都不相信你能拥有好体形，你永远都不会拥有（正如自我效能感研究显示的一样）。并不是信念提升了你完成任务的能力——而是它提升了你不断努力的意愿。如果你从来没有为了拥有好体形而努力过，那么这个愿望就不可能成真。\r\n\r\n然后，最好避免对某种具体行为规律产生较高的期待值，比如一天跑 10 千米或一天写 3000 字。你会遇到的一个问题是，你的目标会“暗中膨胀”。即使你把微目标写在显眼的位置，你的大脑也许会注意到你是如何在过去的 20 天里每天写了大约 1500 字而不是 50 字的（我此前的个人案例），大脑不断“登记”的是行为，而不是意愿。\r\n\r\n从潜意识层面看，超额完成目标后，大脑会设定一个新的期待值，它承载了你以前设\r\n定过的典型目标（你懂的，那些无效目标）带来的负担和压力。所以，一定要提醒自己，你每天的目标并没有改变，这一点极为重要。还是每天 50 字。如果继续提高目标，你可能会让自己失望，因为你不愿打破每天 1500 字的连胜战绩。想解决这个问题，你要提醒自己你是怎么提高到这个水平的（用低目标），还要提醒自己只要愿意，你完全可以继续写这么多字，但如果只写了 50 字，不要感到内疚或者失败。50 字就是成功，句号！这一点极其重要，因为如果把这句话理解错了，那读这本书就是在浪费你的时间。\r\n\r\n该策略的全部益处、力量和优势都取决于你在纸面上和心里始终将目标保持在微小状态的能力。\r\n\r\n一旦你开始为要不要完成目标而感到犹豫，仔细检查一下你内心有没有隐藏目标。你\r\n是真的在为你的微目标而努力，还是说你的目标提高了？拒绝更大的目标——你可以通过设定小目标做更多事。\r\n\r\n我们要把期待值和精力放到坚持目标上，而不要对任务量抱有较高的期待。生活中最\r\n强大的武器就是坚持，因为这是让行为转变成习惯的唯一途径，而且当非习惯变成习惯，也就意味着你确实从与大脑对抗变成与其合作了。\r\n\r\n## 第 8 步：留意习惯养成的标志\r\n这一步又是在提醒你要耐心。微习惯策略效果很好，可是如果你在一个行为真正成为\r\n习惯之前就停止，继续添加下一组习惯，那么你可能会像个手法拙劣的杂耍艺人一样冒着手里的橘子全部落地的风险（我现在玩杂耍的手法就很拙劣，但如果我定一个微习惯，每天花一分钟练习，我敢打赌我肯定能抛得很好）。\r\n\r\n代表行为已成为习惯的信号有：\r\n```\r\n● 没有抵触情绪：该行为似乎做起来容易，不做反而更难。\r\n● 身份：现在你认同该行为，而且可以信心十足地说“我常看书”或“我是个作家”。\r\n● 行动时无须考虑：你不需要做出执行的决定就能开始该行为。\r\n```\r\n你不会想：“好吧，我决定去健身。”你会自然地收拾好东西并出发，这是因为到周二了，或者好像到该运动的时间了。\r\n```\r\n● 你不再担心了：刚开始时，你也许会担心自己漏掉一天或者早早放弃，可当行为变成习惯后，你知道你会一直做这件事，除非出现紧急情况。\r\n● 常态化：习惯是非情绪化的。一旦一件事成为习惯，你不会因为“你真的在做这件事”而激动不已。当一个行为变为一种常态，它就是习惯了。\r\n● 它很无聊：好的习惯并不会让人兴奋，它们只是对你有好处而已。你会因为它们而对生活更有激情，但别指望行为本身也是如此。\r\n```\r\n警告：对超额完成任务的态度超额完成任务是我爱上这个体系的理由之一。此前，我们探讨过在你的意志力变得能够支撑那么多工作量之前，反复超额完成目标的行为是如何帮你塑造期待值，让你能一直进行这种活动的。这点有好处，也有几分坏处，好处是大脑开始把这种活动当作习惯，坏处是因为它过早提高了标准，会导致拥有微习惯的很多好处消失。从小事开始和消除期待值带来的压力是我们取得成功的秘诀，而且效果很好，所以我们要尽可能长久保持。\r\n\r\n再强调一遍，我并不是说你不能超过目标。如果你今天真的想跑 3 千米，但是你的目标是只跑到大门口，那就太好了！去吧，跑 3 千米，但是别把目标变成 3 千米。不管什么时候，你都要做好开开心心地完成微目标然后回到屋里的准备，不过即使完全可以这么做，你一般也不会选择就此回屋，而是会继续跑一段。\r\n\r\n如果你没能在最开始就超额完成目标，别担心。我的写作微习惯从一开始就势不可当\r\n，但在阅读微习惯方面，我直到第 57 天才看到明显而持续的超额完成现象。有些微习惯的火花能迅速燎原，而另一些则需要更长时间，这主要取决于你对这个习惯有多大兴趣，以及你对超越原始目标后继续行动的感知难度。\r\n\r\n我几乎每天都能超额完成写作目标，但仍能随意把控自由度。我可以写满 50 字就停。如果我有其他安排，可以花几分钟完成最低目标，然后充分享受这一天。\r\n如果你超额完成了目标，你很了不起，但如果没有呢？你还是很了不起。不只是“好”，而是“了不起”。大脑很难改变，所以我们要庆祝每一次进步。但是问题又来了，这么做是不是会更轻松？有些人全无意志力，却要跟大型目标较劲，相比之下，用我们的方法更轻松，而且收获更大。\r\n', '1', '1', '2019-01-16 00:42:11', '2019-01-16 01:16:41');
INSERT INTO `posts` VALUES ('41', '3', '0', '39', 'MySQL练习-主外键多表查询 练习', 'MySQL练习-主外键多表查询 练习', '练习:\r\n\r\n## 1.建立表关系:\r\n\r\n请创建如下表，并创建相关约束\r\n![avatar](/public/img/posts/mysqllx.png)\r\n \r\n\r\n创建表并建立表关系\r\n```\r\nUSE db1;\r\nCREATE TABLE class(\r\n    cid INT AUTO_INCREMENT PRIMARY KEY,\r\n    caption VARCHAR(10)\r\n);\r\nCREATE TABLE teacher(\r\n    tid INT AUTO_INCREMENT PRIMARY KEY,\r\n    tname VARCHAR(10)\r\n);\r\nCREATE TABLE course(\r\n    cid INT AUTO_INCREMENT PRIMARY KEY,\r\n    cname VARCHAR(10),\r\n    teach_id INT,\r\n    CONSTRAINT fk_course_teacher FOREIGN KEY(teach_id) REFERENCES teacher(tid)\r\n);\r\nCREATE TABLE student(\r\n    sid INT AUTO_INCREMENT PRIMARY KEY,\r\n    sname VARCHAR(10),\r\n    gender VARCHAR(10),\r\n    class_id INT,\r\n    CONSTRAINT fk_student_class FOREIGN KEY(class_id) REFERENCES class(cid)\r\n);\r\nCREATE TABLE score(\r\n    sid INT AUTO_INCREMENT PRIMARY KEY,\r\n    student_id INT,\r\n    course_id INT,\r\n    number INT,\r\n    CONSTRAINT fk_score_student FOREIGN KEY(student_id) REFERENCES student(sid),\r\n    CONSTRAINT fk_score_course FOREIGN KEY(course_id) REFERENCES course(cid)\r\n);\r\n```\r\n\r\n表数据\r\n```\r\nINSERT INTO class(caption) VALUES(\"三年二班\");\r\nINSERT INTO class(caption) VALUES(\"一年三班\");\r\nINSERT INTO class(caption) VALUES(\"三年一班\");\r\n\r\nINSERT INTO teacher(tname) VALUES(\"波多\");\r\nINSERT INTO teacher(tname) VALUES(\"苍空\");\r\nINSERT INTO teacher(tname) VALUES(\"饭岛\");\r\n\r\nINSERT INTO student(sname,gender,class_id) VALUES(\"钢蛋\",\"女\",1);\r\nINSERT INTO student(sname,gender,class_id) VALUES(\"铁锤\",\"女\",1);\r\nINSERT INTO student(sname,gender,class_id) VALUES(\"山炮\",\"男\",2);\r\n\r\nINSERT INTO course(cname,teach_id) VALUES(\"生物\",1);\r\nINSERT INTO course(cname,teach_id) VALUES(\"体育\",1);\r\nINSERT INTO course(cname,teach_id) VALUES(\"物理\",2);\r\n\r\nINSERT INTO score(student_id,course_id,number) VALUES(1,1,60);\r\nINSERT INTO score(student_id,course_id,number) VALUES(1,2,59);\r\nINSERT INTO score(student_id,course_id,number) VALUES(2,2,100);\r\n\r\n```\r\n\r\n\r\n补充联合唯一\r\n```\r\nALTER TABLE score ADD UNIQUE sco_que(student_id,course_id);\r\n```\r\n\r\n## 2.操作练习:\r\n\r\n#### 1、自行创建测试数据\r\n\r\n#### 测试失败数据\r\n```\r\nINSERT INTO student(sname,gender,class_id) VALUES(\"钢铁侠\",\"男\",4);\r\n-- Cannot add or update a child row: a foreign key constraint fails (`db1`.`student`, CONSTRAINT `fk_student_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`))\r\n```\r\n#### 2、查询“生物”课程比“物理”课程成绩高的所有学生的学号；\r\n\r\n#### 多表嵌套查询\r\n````\r\nSELECT s1.student_id FROM \r\n(SELECT a.student_id,a.`number` FROM score a,course b \r\nWHERE a.`course_id` = b.`cid` AND b.`cname` =\"生物\") s1 , \r\n(SELECT a.student_id,a.`number` FROM score a,course b \r\nWHERE a.`course_id` = b.`cid` AND b.`cname`=\"体育\") s2 \r\nWHERE s1.`student_id` = s2.student_id \r\nAND s1.number >s2.number\r\n```\r\n\r\n#### 3、查询平均成绩大于60分的同学的学号和平均成绩；\r\n\r\n#### HAVING用法\r\n```\r\nSELECT student_id,AVG(number) FROM score \r\nGROUP BY student_id\r\nHAVING AVG(number) > 60\r\n````\r\n\r\n#### 4、查询所有同学的学号、姓名、选课数、总成绩；\r\n\r\n#### 多表查询\r\n```\r\nSELECT a.`sid`,a.`sname`,b.`cname`,c.`number`,c.`course_id`,a.`class_id` \r\nFROM student a,course b,score c\r\nWHERE a.`sid` = c.`student_id` AND c.`course_id` = b.`cid`\r\n````\r\n\r\n#### 5、查询姓“李”的老师的个数；\r\n\r\n####\r\n```\r\nSELECT count(*) as a from teacher where tname LIKE \'李%\'\r\n```\r\n\r\n#### 6、查询没学过“叶平”老师课的同学的学号、姓名；\r\n\r\n####\r\n```\r\nSELECT a.sid,a.sname FROM student a,teacher b,course c\r\nWHERE a.class_id = c.cid and b.tid = c.teach_id \r\nAND b.tname != \'叶平\'\r\n```\r\n#### 7、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；\r\n\r\n#### \r\n```\r\nSELECT a.`student_id`,c.`sname` FROM score a , score b ,student c\r\nWHERE a.`student_id`=b.`student_id` AND a.`course_id` =\'1\' \r\nAND b.`course_id`=\'2\' AND c.`sid` = a.`student_id`\r\n```\r\n\r\n#### 8、查询学过“叶平”老师所教的所有课的同学的学号、姓名；\r\n\r\n####\r\n \r\n```\r\nSELECT c.`sid`,c.`sname` FROM student c \r\nLEFT JOIN score d ON c.`sid` = d.`student_id`\r\nLEFT JOIN course b ON d.`course_id` = b.`cid`\r\nLEFT JOIN teacher a ON a.`tid` = b.`teach_id`\r\nWHERE a.`tname`=\'波多\'\r\nGROUP BY c.`sname`\r\nHAVING COUNT(c.sname)\r\n<(SELECT COUNT(*) FROM teacher a \r\nLEFT JOIN course b ON a.`tid` = b.`teach_id`\r\nWHERE a.`tname`=\'波多\')\r\n```\r\n\r\n#### 9、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；\r\n\r\n#### \r\n```\r\nSELECT s1.student_id FROM (SELECT a.student_id,a.`number` FROM score a,course b \r\nWHERE a.`course_id` = b.`cid` AND b.`cid` =\'2\') s1 , (SELECT a.student_id,a.`number` FROM score a,course b \r\nWHERE a.`course_id` = b.`cid` AND b.`cid`=\'1\') s2\r\nWHERE s1.`student_id` = s2.student_id AND s1.number >s2.number\r\n```\r\n\r\n#### 10、查询有课程成绩小于60分的同学的学号、姓名；\r\n\r\n#### \r\n```\r\nSELECT a.`sid`,a.`sname` FROM student a , score    b\r\nWHERE a.sid = b.student_id AND number < 60\r\n```\r\n\r\n#### 11、查询没有学全所有课的同学的学号、姓名；\r\n\r\n```\r\nSELECT a.`sid`,a.`sname` FROM student a \r\nLEFT JOIN score b ON  a.`sid` = b.`student_id`\r\nGROUP BY a.`sid`\r\nHAVING COUNT(b.`student_id`) < (SELECT COUNT(*) FROM course)\r\n```\r\n\r\n#### 12、查询至少有一门课与学号为“001”的同学所学相同的同学的学号和姓名；\r\n\r\n```\r\nSELECT a.`sid`,a.`sname` FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON c.`cid` = b.`course_id`\r\nWHERE c.`cid` IN (\r\nSELECT cc.`cid` FROM student aa LEFT JOIN score bb ON aa.`sid` = bb.`student_id`\r\nLEFT JOIN course cc ON cc.`cid` = bb.`course_id` WHERE aa.`sid`=\'1\'\r\n) AND a.`sid` !=\'1\'\r\n```\r\n\r\n#### 13、查询至少学过学号为“001”同学所选课程中任意一门课的其他同学学号和姓名；\r\n\r\n```\r\nSELECT a.`sid`,a.`sname` FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON c.`cid` = b.`course_id`\r\nWHERE c.`cid` IN (\r\nSELECT cc.`cid` FROM student aa LEFT JOIN score bb ON aa.`sid` = bb.`student_id`\r\nLEFT JOIN course cc ON cc.`cid` = bb.`course_id` WHERE aa.`sid`=\'1\'\r\n) AND a.`sid` !=\'1\'\r\n```\r\n\r\n#### 14、查询和“002”号的同学学习的课程完全相同的其他同学学号和姓名；\r\n\r\n```\r\nSELECT a.`sid`,a.`sname` FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course ac ON b.`course_id`=ac.`cid`\r\nWHERE\r\nac.`cid` IN (SELECT c.`cid` FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON b.`course_id`=c.`cid` WHERE a.`sid`=\'2\') \r\nAND a.`sid` != \'2\' \r\nGROUP BY a.`sid`,a.`sname`\r\nHAVING\r\n(SELECT COUNT(ac.`cid`) AS countCid FROM student aa LEFT JOIN score b ON aa.`sid` = b.`student_id`\r\nLEFT JOIN course ac ON b.`course_id`=ac.`cid` WHERE aa.`sid`=a.`sid`) = (SELECT COUNT(c.`cid`) AS cc FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON b.`course_id`=c.`cid` WHERE a.`sid`=\'2\')\r\n```\r\n\r\n#### 15、删除学习“叶平”老师课的SC表记录；\r\n\r\n```\r\nDELETE FROM score WHERE course_id IN (\r\nSELECT a.`cid` FROM course a LEFT JOIN teacher b ON a.`teach_id`=b.`tid`\r\nWHERE b.`tname`=\'叶平\'\r\n)\r\n```\r\n\r\n#### 16、向SC表中插入一些记录，这些记录要求符合以下条件：①没有上过编号“002”课程的同学学号；②插入“002”号课程的平均成绩； \r\n\r\n#### 17、按平均成绩从低到高显示所有学生的“语文”、“数学”、“英语”三门的课程成绩，按如下形式显示： 学生ID,语文,数学,英语,有效课程数,有效平均分；\r\n\r\n#### 18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；\r\n\r\n#### 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序；\r\n\r\n#### 20、课程平均分从高到低显示（现实任课老师）；\r\n\r\n#### 21、查询各科成绩前三名的记录:(不考虑成绩并列情况) \r\n\r\n#### 22、查询每门课程被选修的学生数；\r\n\r\n#### 23、查询出只选修了一门课程的全部学生的学号和姓名；\r\n\r\n#### 24、查询男生、女生的人数；\r\n\r\n#### 25、查询姓“张”的学生名单；\r\n\r\n#### 26、查询同名同姓学生名单，并统计同名人数；\r\n\r\n#### 27、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列；\r\n\r\n#### 28、查询平均成绩大于85的所有学生的学号、姓名和平均成绩；\r\n\r\n#### 29、查询课程名称为“数学”，且分数低于60的学生姓名和分数；\r\n\r\n#### 30、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名； \r\n\r\n#### 31、求选了课程的学生人数\r\n\r\n#### 32、查询选修“杨艳”老师所授课程的学生中，成绩最高的学生姓名及其成绩；\r\n\r\n#### 33、查询各个课程及相应的选修人数；\r\n\r\n#### 34、查询不同课程但成绩相同的学生的学号、课程号、学生成绩；\r\n\r\n#### 35、查询每门课程成绩最好的前两名；\r\n\r\n```\r\n1 SELECT student_id FROM score \r\n2 ORDER BY number DESC LIMIT 2\r\n```\r\n\r\n#### 36、检索至少选修两门课程的学生学号；\r\n\r\n```\r\nSELECT a.`sid` FROM student a LEFT JOIN score b ON a.`sid` = b.`student_id`\r\nGROUP BY a.`sid`\r\nHAVING COUNT(a.`sid`)>=2\r\n```\r\n\r\n#### 37、查询全部学生都选修的课程的课程号和课程名；\r\n\r\n```\r\nSELECT DISTINCT c.`cid`,c.`cname` FROM student a \r\nLEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON b.`course_id`=c.`cid`\r\n```\r\n\r\n#### 38、查询没学过“叶平”老师讲授的任一门课程的学生姓名；\r\n\r\n```\r\nSELECT a.`sname` FROM student a \r\nLEFT JOIN score b ON a.`sid` = b.`student_id`\r\nLEFT JOIN course c ON c.`cid` = b.`course_id`\r\nWHERE c.`cid` NOT IN (\r\nSELECT cour.`cid` FROM teacher teac \r\nLEFT JOIN course cour ON teac.`tid`=cour.`teach_id`\r\nWHERE teac.`tname` = \'波多\' \r\n)\r\n```\r\n\r\n#### 39、查询两门以上不及格课程的同学的学号及其平均成绩；\r\n\r\n```\r\nSELECT student_id,COUNT(sid) AS co,AVG(number)AS avgg  FROM score \r\nWHERE number < 60 \r\nGROUP BY student_id\r\nHAVING co >=2\r\n```\r\n\r\n#### 40、检索“004”课程分数小于60，按分数降序排列的同学学号；\r\n\r\n```\r\nSELECT b.`sid`,b.`sname`,a.`number` FROM score a LEFT JOIN student b ON a.`student_id` = b.`sid`\r\nWHERE a.`course_id` = \'4\' AND a.`number` < \'60\'\r\nORDER BY a.`number` DESC\r\n```\r\n\r\n#### 41、删除“002”同学的“001”课程的成绩；\r\n```\r\nDELETE FROM score WHERE student_id =\'2\' AND course_id = \'1\'\r\n```', '1', '1', '2019-01-15 17:45:35', '2019-01-15 18:40:51');
INSERT INTO `posts` VALUES ('42', '13', '0', '2', '周三打卡（01146）', '人临走前，说的最多的后悔的是，把给工作的时间太多，给家人陪伴的时间太少。\r\n我们究竟想要什么', '人临走前，说的最多的后悔的是，把给工作的时间太多，给家人陪伴的时间太少。\r\n我们究竟想要什么', '1', '1', '2019-01-16 12:13:47', '2019-01-16 22:33:22');
INSERT INTO `posts` VALUES ('43', '3', '0', '2', 'http请求方法（GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE、CO', 'http请求方法（GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE、CONNECT）', '根据HTTP标准，HTTP请求可以使用多种请求方法。 \r\n\r\nHTTP的1.0版本中只有三种请求方法： GET, POST 和 HEAD方法。\r\n\r\n到了1.1版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\r\n\r\n## GET \r\n请求指定的页面信息，并返回实体主体。\r\n\r\nGET请求请提交的数据放置在HTTP请求协议头中，GET方法通过URL请求来传递用户的输入，GET方式的提交你需要用Request.QueryString来取得变量的值。\r\n\r\nGET方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。\r\n\r\nGET请求有长度限制。\r\n```\r\n// 发起请求\r\nhttp://localhost/general/form/getpost.asp?Text=Hello+World\r\n// 解析请求参数（asp语法）\r\n<% If Request.QueryString(“Text”) <> ““ Then %> \r\n通过get方法传递来的字符串是： “<B><%= Request.QueryString(“Text”) %></B>“<BR> \r\n<% End If %> \r\n```\r\n\r\n## HEAD\r\n\r\n类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。\r\n\r\n## POST\r\n\r\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。\r\n\r\nPOST请求可能会导致新的资源的建立和/或已有资源的修改。\r\n\r\nPOST方式提交时，你必须通过Request.Form来访问提交的内容\r\n```\r\n// 发起请求\r\nhttp://localhost/general/form/getpost.asp\r\n// 解析请求参数（asp语法）\r\n<% If Request.Form(“Text”) <> ““ Then %> \r\n通过Post方法传递来的字符串是： “<B><%= Request.Form(“Text”) %></B>“<BR> \r\n<% End If %> \r\n```\r\n\r\n## PUT\r\n\r\n从客户端向服务器传送的数据取代指定的文档的内容。\r\n\r\n## DELETE\r\n\r\n请求服务器删除指定的页面。\r\nDELETE请求一般返回3种码\r\n```\r\n200（OK）——删除成功，同时返回已经删除的资源。\r\n202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。\r\n204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。\r\n```\r\n\r\n## CONNECT\r\n\r\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\r\n\r\n## OPTIONS\r\n\r\n允许客户端查看服务器的性能。\r\n\r\n## TRACE\r\n\r\n回显服务器收到的请求，主要用于测试或诊断。\r\n', '1', '1', '2019-01-16 17:17:18', '2019-01-16 17:19:54');
INSERT INTO `posts` VALUES ('44', '3', '0', '2', '浅谈HTTP中Get、Post、Put与Delete的区别', '', '1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。**无论进行多少次操作，结果都是一样的。**\r\n\r\n2、与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，**其结果并没有不同。**\r\n\r\n3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。**几乎目前所有的提交操作都是用POST请求的。**\r\n\r\n4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。\r\n\r\n就像前面所讲的一样，既然**PUT和POST操作都是向服务器端发送数据的**，那么两者有什么区别呢。。。\r\n\r\nPOST主要作用在一个集合资源之上的（url）\r\n\r\n而PUT主要作用在一个具体资源之上的（url/xxx）\r\n\r\n通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。\r\n\r\n综上所述，我们可理解为以下：\r\n```\r\n1、POST /url 创建  \r\n2、DELETE /url/xxx 删除 \r\n3、PUT /url/xxx 更新\r\n4、GET /url/xxx 查看\r\n```\r\n Http定义了与服务器交互的不同方法，最基本的方法有**4种**，分别是\r\n```\r\nGET，POST，PUT，DELETE\r\n```\r\nURL全称是**统一资源定位符**，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\r\n\r\n到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。\r\n\r\n## 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。\r\n\r\n(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。\r\n\r\n* 注意：这里安全的含义仅仅是指是非修改信息。\r\n\r\n(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：\r\n\r\n幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。　　\r\n\r\n幂等有一下几种定义：\r\n```\r\n　　对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。\r\n　　对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。\r\n```\r\n看完上述解释后，应该可以理解GET幂等的含义了。\r\n\r\n但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。\r\n\r\n### 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\r\n继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。\r\n\r\n上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：\r\n```\r\n1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。\r\n\r\n2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。\r\n\r\n3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。\r\n```\r\n 　　* 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。\r\n\r\n　　以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。\r\n\r\n说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：\r\n```\r\n1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。\r\n```\r\nPOST把提交的数据则放置在是HTTP包的包体中。\r\n\r\n## 2.GET,POST方式提交的数据都有上限\r\n\r\n\"GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB\"？？！\r\n\r\n以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：\r\n \r\n(1).首先是\"GET方式提交的数据最多只能是1024字节\"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。\r\n \r\n　　注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5]\r\n\r\n(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。\r\n\r\n　　对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。\r\n\r\n　　由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：\r\n```\r\n1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。\r\n2).IIS 6.0默认上传文件的最大大小是4MB。\r\n3).IIS 6.0默认最大请求头是16KB。\r\n```\r\nIIS 6.0之前没有这些限制。 \r\n\r\n　　所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。\r\n\r\n## 3.GET，POST请求参数用的方式不一样\r\n\r\n在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。\r\n\r\n在JSP中，用request.getParameter(\\\"XXXX\\\")来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&password=hyddd，用request.getQueryString()得到的是：name=hyddd&password=hyddd。\r\n\r\n在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个需要在做深入的研究。\r\n\r\n## 4.POST的安全性要比GET的安全性高。\r\n\r\n注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成**Cross-site request forgery攻击。**\r\n\r\n　　总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为\"GET\"，实质上，GET和POST只是发送机制不同，并不是一个取一个发！', '1', '1', '2019-01-16 17:21:18', '2019-01-16 17:35:54');
INSERT INTO `posts` VALUES ('45', '4', '0-4', '2', 'Vue+Webpack打造todo应用   ', '慕课网学习vue笔记 1.搭建前端工程 2.网络优化 3.api定制 4.node.js', '简介：本课程基于一个TODO示例应用讲解VUE2的基本使用以及如何搭建一个vue的工程。\r\n\r\n首先通过webpack我们搭建了一个完善的vue的workflow，然后围绕功能实现讲解vue的使用，并介绍了vue的.vue文件以及jsx的开发模式。 \r\n\r\n## [这是我搭建的todo应用](/public/tool/todoo/)\r\n\r\n[todo应用实列](/public/tool/todoo/)\r\n\r\n\r\n[Vue+Webpack打造todo应用学习网址](https://www.imooc.com/learn/935)\r\n\r\n## 准备\r\n - vue是什么\r\n - webpack是什么 \r\n\r\n```\r\n工欲善其事必先利其器    --论语\r\n```\r\n## vue 部分\r\n\r\n#### 实例生命周期钩子理解\r\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置**数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等**。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码[这是我搭建的todo应用](/public/tool/todoo/)\r\n的机会。\r\n\r\n比如 created 钩子可以用来在一个实例被创建之后执行代码：\r\n```\r\nnew Vue({\r\n  data: {\r\n    a: 1\r\n  },\r\n  created: function () {\r\n    // `this` 指向 vm 实例\r\n    console.log(\'a is: \' + this.a)\r\n  }\r\n})\r\n// => \"a is: 1\"\r\n```\r\n也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。\r\n\r\n```\r\n不要在选项属性或回调上使用箭头函数，比如 \r\ncreated: () => console.log(this.a) \r\n或 vm.$watch(\'a\', newValue => this.myMethod())。\r\n因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误\r\n```\r\n\r\n#### 生命周期图示\r\n下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。\r\n![avatar](/public/img/posts/vuelifecycle.png)\r\n\r\n## WebPack是什么?\r\n```\r\n一个打包工具\r\n一个模块加载工具\r\n各种资源都可以当成模块来处理\r\n```\r\n### [WebPack官网](https://www.webpackjs.com/)\r\n\r\n如今，越来越多的JavaScript代码被使用在页面上，我们添加很多的内容在浏览器里。如何去很好的组织这些代码，成为了一个必须要解决的难题。\r\n\r\n对于模块的组织，通常有如下几种方法：\r\n```\r\n通过书写在不同文件中，使用script标签进行加载\r\nCommonJS进行加载（NodeJS就使用这种方式）\r\nAMD进行加载（require.js使用这种方式）\r\nES6模块\r\n```\r\n思考：为什么只有JS需要被模块化管理，前台的很多预编译内容，不需要管理吗？\r\n\r\n基于以上的思考，WebPack项目有如下几个目标：\r\n```\r\n将依赖树拆分，保证按需加载\r\n保证初始加载的速度\r\n所有静态资源可以被模块化\r\n可以整合第三方的库和模块\r\n可以构造大系统\r\n```\r\n从下图可以比较清晰的看出WebPack的功能\r\n![webpack](/public/img/posts/webpack_views.png)\r\n这是一个示意图\r\n\r\n## WebPack的特点\r\n```\r\n丰富的插件，方便进行开发工作\r\n大量的加载器，包括加载各种静态资源\r\n代码分割，提供按需加载的能力\r\n```\r\n\r\n## 发布工具\r\nWebPack的优势\r\n\r\nwebpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。\r\n\r\n能被模块化的不仅仅是 JS 了。\r\n\r\n开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。\r\n\r\n扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。\r\n\r\nWebPack的安装\r\n\r\n安装命令\r\n```\r\n$ npm install webpack -g\r\n```\r\n\r\n使用webpack\r\n```\r\n$ npm init  # 会自动生成一个package.json文件\r\n$ npm install webpack --save-dev #将webpack增加到package.json文件中\r\n```\r\n可以使用不同的版本\r\n```\r\n$ npm install webpack@1.2.x --save-dev\r\n```\r\n如果想要安装开发工具\r\n```\r\n$ npm install webpack-dev-server --save-dev\r\nWebPack的配置\r\n```\r\n每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。\r\n\r\n下面是一个例子\r\n```\r\nvar webpack = require(\'webpack\');\r\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin(\'common.js\');\r\nmodule.exports = {\r\n    //插件项\r\n    plugins: [commonsPlugin],\r\n    //页面入口文件配置\r\n    entry: {\r\n        index : \'./src/js/page/index.js\'\r\n    },\r\n    //入口文件输出配置\r\n    output: {\r\n        path: \'dist/js/page\',\r\n        filename: \'[name].js\'\r\n    },\r\n    module: {\r\n        //加载器配置\r\n        loaders: [\r\n            { test: /\\.css$/, loader: \'style-loader!css-loader\' },\r\n            { test: /\\.js$/, loader: \'jsx-loader?harmony\' },\r\n            { test: /\\.scss$/, loader: \'style!css!sass?sourceMap\'},\r\n            { test: /\\.(png|jpg)$/, loader: \'url-loader?limit=8192\'}\r\n        ]\r\n    },\r\n    //其它解决方案配置\r\n    resolve: {\r\n        root: \'E:/github/flux-example/src\', //绝对路径\r\n        extensions: [\'\', \'.js\', \'.json\', \'.scss\'],\r\n        alias: {\r\n            AppStore : \'js/stores/AppStores.js\',\r\n            ActionType : \'js/actions/ActionType.js\',\r\n            AppAction : \'js/actions/AppAction.js\'\r\n        }\r\n    }\r\n};\r\n```\r\nplugins 是插件项，这里我们使用了一个 CommonsChunkPlugin的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。\r\n\r\nentry 是页面入口文件配置，output 是对应输出项配置 （即入口文件最终要生成什么名字的文件、存放到哪里）module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。 所有加载器需要使用npm来加载最后是 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写）\r\nWebPack开始使用\r\n\r\n这里有最基本的使用方法，给大家一个感性的认识\r\n\r\n正确安装了WebPack，方法可以参考上面\r\n\r\n书写entry.js文件\r\n\r\ndocument.write(\"看看如何让它工作！\");\r\n\r\n书写index.html文件\r\n```\r\n<html>\r\n<head>\r\n<meta charset=\"utf-8\">\r\n</head>\r\n<body>\r\n<script type=\"text/javascript\" src=\"bundle.js\" charset=\"utf-8\"></script>\r\n</body>\r\n</html>\r\n```\r\n执行命令，生成bundle.js文件\r\n```\r\n$ webpack ./entry.js bundle.js\r\n```\r\n在浏览器中打开index.html文件，可以正常显示出预期\r\n\r\n增加一个content.js文件\r\n```\r\nmodule.exports = \"现在的内容是来自于content.js文件！\";\r\n```\r\n修改entry.js文件\r\n```\r\ndocument.write(require(\"./content.js\"));\r\n```\r\n执行第四步的命令\r\n\r\n进行加载器试验\r\n\r\n增加style.css文件\r\n```\r\nbody {\r\nbackground: yellow;\r\n}\r\n```\r\n修改entry.js文件\r\n```\r\nrequire(\"!style!css!./style.css\");\r\ndocument.write(require(\"./content.js\"));\r\n```\r\n执行命令，安装加载器\r\n```\r\n$ npm install css-loader style-loader   # 安装的时候不使用 -g\r\n```\r\n执行webpack命令，运行看效果\r\n\r\n可以在命令行中使用loader\r\n```\r\n$ webpack ./entry.js bundle.js --module-bind \"css=style!css\"\r\n```\r\n\r\n使用配置文件\r\n\r\n默认的配置文件为webpack.config.js\r\n\r\n增加webpack.config.js文件\r\n```\r\nmodule.exports = {\r\n entry: \"./entry.js\",\r\n output: {\r\n     path: __dirname,\r\n     filename: \"bundle.js\"\r\n },\r\n module: {\r\n     loaders: [\r\n         { test: /\\.css$/, loader: \"style!css\" }\r\n     ]\r\n }\r\n};\r\n```\r\n执行程序\r\n```\r\n$ webpack\r\n```\r\n发布服务器\r\n\r\n安装服务器\r\n```\r\n$ npm install webpack-dev-server -g\r\n$ webpack-dev-server --progress --colors\r\n```\r\n服务器可以自动生成和刷新，修改代码保存后自动更新画面\r\n```\r\nhttp://localhost:8080/webpack-dev-server/bundle\r\n```', '1', '1', '2019-01-16 18:57:15', '2019-01-17 20:46:41');
INSERT INTO `posts` VALUES ('46', '13', '0', '2', '人生总要有第一次的尝试，好的坏的都要尝试，微笑面对生活', '失败的面试，不代表失败的人生\r\n加油，相信自己！', '失败的面试不代表，失败的人生\r\n加油，相信自己！\r\n有些路不合适，可以换一条', '1', '1', '2019-01-16 22:30:04', '2019-01-16 22:49:13');
INSERT INTO `posts` VALUES ('47', '13', '0', '2', '有趣的小工具Boxes', '这么有趣，以后打卡就靠他了', '## boxes\r\n```\r\nBoxes is a command line program that draws a box around its input text. It can remove and repair those boxes, too. You can easily make your own box designs if you wish, but many designs are already provided.\r\n```\r\nboxex 是 linux 下的一款命令行工具，可以用字符组成盒子把你的文字包围在里面。\r\n\r\n就像下面这样：\r\n```\r\n    Hello World!  ==>\r\n\r\n     __________________\r\n    /\\                 \\  \r\n    \\_|                |  \r\n      |  Hello World!  |  \r\n      |                |  \r\n      |  ______________|_ \r\n      \\_/_______________/\r\n    \r\n    \r\n    /******************/\r\n    /*                */\r\n    /*  Hello World!  */\r\n    /*                */\r\n    /******************/\r\n     \r\n             \\\\\\///\r\n            / _  _ \\\r\n          (| (.)(.) |)\r\n    .---.OOOo--()--oOOO.---.\r\n    |                      |\r\n    |     Hello World!     |\r\n    |                      |\r\n    \'---.oooO--------------\'\r\n         (   )   Oooo.\r\n          \\ (    (   )\r\n           \\_)    ) /\r\n                 (_/\r\n```\r\n\r\n安装\r\n``\r\nDebian 和 debian-based, 如 Ubuntu, 还有 Windows 10 Ubuntu Subsystem，安装都很简单，\r\n\r\n只需要命令行执行：\r\n```\r\napt-get install boxes\r\n```\r\n使用\r\n\r\nboxes --help  查看帮助。linux工具使用大法，先看帮助。\r\n\r\nboxes -l  查看有多少可以使用的盒子格式。 已知有个叫dog的盒子模型。\r\n\r\n输入echo \"I am testing\" | boxes -d dog -a c 将生成：\r\n```\r\n          __   _,--=\"=--,_   __\r\n         /  \\.\"    .-.    \"./  \\\r\n        /  ,/  _   : :   _  \\/` \\\r\n        \\  `| /o\\  :_:  /o\\ |\\__/\r\n         `-\'| :=\"~` _ `~\"=: |\r\n            \\`     (_)     `/\r\n     .-\"-.   \\      |      /   .-\"-.\r\n.---{     }--|  /,.-\'-.,\\  |--{     }---.\r\n )  (_)_)_)  \\_/`~-===-~`\\_/  (_(_(_)  (\r\n(             I am testing              )\r\n )                                     (\r\n\'---------------------------------------\'\r\n```\r\n-d 参数表示选择哪一个盒子模型，\r\n\r\n-a 参数表示对齐方式。\r\n\r\n自定义盒子模型\r\n\r\n这个工具还支持自定义盒子模型。\r\n\r\n我的使用方法\r\n\r\n我配合boxes 写了个vim插件，每次写代码的时候，就把这个狗头放在我代码的开头\r\n\r\n```\r\n/* * \r\n * @file \r\n * @Brief  \r\n * @author                                                                                                                       \r\n * @version v1.0\r\n * @date 2016-10-31\r\n *\r\n *           __   _,--=\"=--,_   __\r\n *          /  \\.\"    .-.    \"./  \\\r\n *         /  ,/  _   : :   _  \\/` \\\r\n *         \\  `| /o\\  :_:  /o\\ |\\__/\r\n *          `-\'| :=\"~` _ `~\"=: |\r\n *             \\`     (_)     `/\r\n *      .-\"-.   \\      |      /   .-\"-.\r\n * .---{     }--|  /,.-\'-.,\\  |--{     }---.\r\n *  )  (_)_)_)  \\_/`~-===-~`\\_/  (_(_(_)  (\r\n * (        0 Error(s) 0 Warning(s)        )\r\n *  )       phpms wuxiumu@163.com          (\r\n * \'---------------------------------------\'            \r\n *                     \r\n */\r\n```\r\n\r\n是不是也挺有意思的。', '1', '1', '2019-01-16 22:43:32', '2019-01-16 22:46:58');
INSERT INTO `posts` VALUES ('48', '14', '0', '2', '7-微习惯策略的八大规则', '', '有些规则就是要被打破的。一旦你掌握了一项技能，不用借助规则也可以应用自如。\r\n关键在于理解规则背后的原理。\r\n\r\n既然这些规则能帮助你，而且有积极作用，你就不需要考虑是否要打破它们了。事实\r\n上，如果你发现自己用微习惯很难取得进步，很可能是因为你违背了其中一条规则。\r\n## 1. 绝不要自欺欺人\r\n微习惯体系中有几种作弊方式。第一个也是最常见的一种是给自己制定一个微习惯，\r\n比如每天做 1 个俯卧撑，却偷偷要求自己完成不止 1 个俯卧撑。你需要特别注意避免这么做，因为你每对自己提高一点要求，就需要更多意志力才能达到要求，而且就算你应付得了额外的意志力负担，也许还有同时培养多个习惯的目标。我们想要确保成功，而不是听成功和失败发号施令。你随时可以超越目标，所以要让这额外奖励来自于你自己，而不是你定下的目标。如果你在某个时候想超越目标但内心存在抵触，那就在完成微习惯后额外设定一些微目标吧。\r\n\r\n和其他习惯体系与自助策略不同，采用微习惯策略后，你很少会体验失望。如果你只\r\n需要做 1 个俯卧撑或仰卧起坐，有什么能阻止你成功呢？目标很小并不是问题，你在为了成功而训练大脑，并在建立你希望某天能实现的目标的缩小版，而且因为你很渴望达到目标，“某天”可能很快就会到来。如果你的结果与我的一样，你会比预想中更早达到更大的目标。但是，请一定不要调高期待值。期待值低一些，你就会渴望多完成一些。一旦你意识到开始的力量有多强大，就会有充足的动力（此前你的力量一直在休眠）一直做下去，那么生活会变得非常有趣。\r\n\r\n## 2. 满意每一个进步\r\n对小小的进步感到满意和标准低不是一回事。李小龙有一句名言能很好地总结这一点\r\n：“要满意，但别满足。”李小龙在他 32 年有限生命里的成就比两个普通人在 80 年里的成就之和还要多，所以听他的没错。\r\n\r\n企业家、音乐家德里克·西弗斯（Derek Sivers）在其 TED 演讲中展示了一段视频，视频里，一个男人在一个露天场所跳舞。他自己一个人跟着音乐狂乱地跳舞的样子显得有些傻气，但过了几秒钟，另一个男人加入了。于是就有两个人了。又过了几秒钟，又有一个人加入进来，之后又来了一个人。当人数达到大约 10 个时，一大群人冲进来加入了他们。几十个人投入地跳着舞，场面相当壮观！\r\n\r\n这个场面是怎么开始的呢？从一个人跳舞开始。\r\n\r\n这个事例清晰地展示了微习惯对你的作用。后来加入的这群人就像是你心底的梦想，\r\n而你因为害羞、害怕而不敢行动。它们信心不足，不敢在聚光灯下舞蹈。第一个跳舞的人就像你迈出第一步的决定。然后你发现“嘿，我竟然真开始做这件事了”，这时，你心底的梦想和激情会冲上舞台来鼓励你。你内心早已拥有你需要的全部勇气，只不过处于休眠状态。用微习惯唤醒它吧。\r\n\r\n微习惯策略的核心是一个很简单的大脑错觉，但同时也是一种重视开始的生活哲理，\r\n一种认为行动优于动力的生活哲理，一种相信将每一小步积累起来便能让量变转为质变的生活哲理。完成一个微习惯后，你心中的小人仿佛在跳舞——给他加油打气吧，因为他正在举办你的个人成长聚会！庆祝所有的进步吧。\r\n\r\n## 3. 经常回报自己，尤其在完成微习惯之后\r\n如果回报本身就能带来回报会怎样？也就是说，不是回报本身有好处，而是收到回报\r\n对你有好处会怎样？通常我们会把回报看作因为做了一件好事而得到的报偿，但回报也能给你回报。当你在完成一个微习惯后回报自己的时候——不管是用食物、出去痛快玩一夜还是对着镜子告诉自己你有多了不起——这种回报会激励你再次执行微习惯，它会通过这种方式奖励你。\r\n\r\n最终，你会建立一个正反馈循环。你会“痴迷”于美好的生活，如果这都不算完美，我就不知道到底什么算了。一个完美的行为会在现在给你回报，也会在今后持续给你回报。\r\n\r\n既然大部分健康习惯（像啃生的西蓝花）现在能给你的回报有限，而长远回报更多，那么在早期阶段，在完成任务后给自己一些奖励，可能会帮助你坚持下去。之后，当你发现自己的外表和内心感觉非常好时，就会笑着认为这都是西蓝花的功劳。\r\n\r\n开始时是最艰难的，在当时是，在习惯养成的早期阶段也是。刚开始，你能看到的成\r\n果十分有限。一次辛苦的锻炼之后，你会感觉浑身酸痛，可是看着镜子却没发现什么变化；吃完西蓝花后，你也会有同样的感觉。第一天完成写作任务后，你不会拥有一本完整的书。可是在长期坚持做这些事情后，最终你会拥有强壮、健康的身体和几部完整的小说。\r\n\r\n我不认为我们会忘记回报自己，但我要把这条“规则”写在这里，以防万一。\r\n\r\n## 4. 保持头脑清醒\r\n\r\n你要力求维持冷静的思维模式并信任你选择的策略。我在过去的几个月里看到了如此\r\n多的进步，却没有过度兴奋。在完成目标的过程中，有时你会感到很无聊。胜利者和失败者的区别就在于当事情变得单调而无聊时，失败者会放弃。这一点和动力无关，它体现了为形成终生的好习惯，你能否利用和保存意志力。\r\n\r\n冷静的头脑是建立习惯的最佳思维模式，因为它很稳定，而且可以预见。在不断取得\r\n进步的过程中，你可能会兴奋起来，但别让这种兴奋变成你实施行动的原动力。变得依赖动力或情绪正是许多个人成长计划最终失败的原因。\r\n\r\n## 5. 感到强烈抵触时，后退并缩小目标\r\n常识告诉我们，一定要突破强烈抵触情绪的阻碍，但我得说，这种做法很愚蠢。我们\r\n已经明确，意志力是有限的，如果强行突破自己的能力范围，可能会导致崩溃和受伤的结局。如果你认为过段时间再做也可以，那么你没有考虑到也许到时候你就没有足够的意愿或意志力了。\r\n\r\n我们来想象一下。你正打算坐下，但希望锻炼，可是你在内心里却不想这么做，抵触\r\n情绪很强，那该怎么办呢？在这种场景下，如果能引诱大脑用你想要的方式做成事情，你肯定不愿和大脑较量。建议把任务逐渐变得越来越小，直到你的抵触感最小为止。\r\n\r\n如果你的目标是“去健身房锻炼”，可以将要求缩小到“自己开车去健身房”。如果这招还不行，那你能做的就是打开衣橱。完成这个任务后，拿出健身时的服装穿好。如果你觉得这么做很傻，那就太棒了，因为如果这个任务听起来很傻，就意味着你的大脑已经同意这么做了。这些“小得不可思议”的步骤从大脑的雷达下方偷偷溜过，就像专业珠宝大盗躲开监控摄像头和运动传感器一样。等你的大脑明白过来时，你已经在健身房的跑步机上了。步骤可以无限缩小。\r\n\r\n即使你精力枯竭了，在这种情况下仍然能让你实施行动的办法就是这些“小得不可思\r\n议”的微步骤，这是个好消息。精力枯竭意味着意志力耗尽，人们强迫自己太长时间做太多事情时就会发生这种情况。当你坐在地板上、感到精疲力竭时，可以向大脑发出请求说：“嘿，我们能不能现在做 1 个俯卧撑？”做完之后，你也许就有动力多做几个了，你也可以多设定几个这样“小得不可思议”的微步骤。\r\n\r\n如果你认为这个策略听起来实在太荒唐和愚蠢，那是因为你认为你能做的事比这多得\r\n多，你的自尊心告诉你“你根本用不着把任务分解成微步骤”。但每一个重大成就都是由非常微小的步骤组成的，而且一次完成一个步骤并不是弱小，而是精确的表现。在我完成“挑战 1 个俯卧撑”的第一个俯卧撑之前，我感觉“自己的能力远远不止这点儿”，我当时认为 1 个俯卧撑毫无价值可言（因为这就好像把拍手当作锻炼一样）。可是，它在真的帮助我锻炼了 30 分钟后改变了我的看法。所以，试用该策略，亲眼看看你在用了它以后是多么势不可当。\r\n\r\n只要遇到抵触，我就会把任务缩小，问题就解决了。\r\n\r\n## 6. 提醒自己这件事很轻松\r\n当你面对自己的微任务并感到抵触时，你可能没有在想，它有多么轻松。\r\n开始微习惯策略一个月后，有一天深夜，我内心对“阅读 2 页书”的任务产生了强烈的抵触。我当时想起前一天自己阅读了多少页，觉得有必要达到同样的目标，于是我不得不提醒自己，我的目标仍然只是 2 页而已。\r\n\r\n一件有趣而鼓舞人心的轶事体现了微习惯的好处，这件事的主角是亚伦·卡尔（AllenCarr）的著作《这书能让你戒烟》（The Easy Way to Quit Smoking ），这本书帮助人们戒烟的效果大大超出预期。你知道其中的基本技巧是什么吗？你知道卡尔的书和其他大多数戒烟策略书籍的区别在哪里吗？\r\n\r\n瑞克·保拉斯（Rick Paulas）在其文章中探讨了这本书惊人的成功：\r\n这本书内容中最令人震惊的地方也许是它根本没提某些内容。里面没有关于\r\n肺癌、心脏病和中风的数据，也没有像 TheTruth.com 网站上那些恶作剧者的危\r\n言耸听，也没有强调口臭和牙渍对性生活质量的潜在威胁。“健康方面的恐吓会\r\n让戒烟变得更难。”卡尔写道，而且显然没有效果。\r\n\r\n保拉斯表示，该书一直在重复表示：“戒烟很容易。戒烟很容易。戒烟很容易。”\r\n“这句话重复了好多遍，”汤普金斯（一位烟民）说，“我在看书的时候意识\r\n到这一点了。你看，这是不是一种催眠术？”在卡尔基于这本书开发的五小时研讨班里，学员成功戒烟率高达 53.3%，绝对能把其他策略打得落花流水（其他策略的成功率为 10%~20%）。这个效果很惊人，因为研讨班提供的只是一些信息而已，没有手把手教你怎么做，也没有使用将尼古丁输入血液的贴片。\r\n\r\n那成功秘诀是什么呢？关键是什么？有什么神奇之处？\r\n\r\n他让烟民们在意识和潜意识层面都相信，戒烟是一件容易的事。当你像许多人一样相\r\n信戒烟无比艰难的时候，你有没有觉得也许是你自己的想法把这件事变困难了？\r\n\r\n微习惯策略会让你相信，健康的习惯是很容易养成的。即使你现在仍然怀疑，一旦它\r\n开始起作用，你就只能选择相信了。\r\n\r\n忘记那些无法激发动力的经历吧，忘记轰轰烈烈的意志力大战吧。微习惯的门槛特别\r\n低，所以你可能再也不用体验失败了。而你永远不会失败时，就会很容易赢得胜利。久而久之，你的潜意识思维会发生变化，然后再从潜意识思维出发改变行为会更轻松。\r\n\r\n这些习惯（和其他的健康习惯）原本为什么很难养成呢？打字有什么挑战性呢？动一\r\n动身体有什么难的呢？安静地坐一个小时读书有什么做不到的呢？这些行为在我们生活中变成了如此巨大的挑战，原因是我们被灌输了以动力为基础的社会理论，它说，你必须振奋起来才能实现梦想或者洗衣服。我们用社会规范、有限的信念和不切实际的目标锻炼头脑的方式是错误的。\r\n\r\n这类普通人的潜意识完全未经训练，主导了前额皮层，因为他们试图一劳永逸地改变\r\n不易调整的大脑，从而耗尽了精力。有了微习惯这个方法，你就能说：“不，你知道吗？\r\n\r\n锻炼并不难，非常容易。我现在就能趴下，做 1 个俯卧撑，这真的特别特别容易，太容易了。每天我都能做到。而且我会去做。”随后，你会摆出俯卧撑的姿势，开始行动，而且意识到再做 1 个俯卧撑也很容易，之后再多做几个也相对容易。到了那个时候，因为你已有的锻炼意愿会和“你真能做到”的领悟联系起来，所以你会备受鼓舞，继续下去。\r\n\r\n我为你感到激动。你会意识到容易和困难是相对而言的，否则为什么有人会参加 150千米长跑，而有人要挣扎着起床才能去大街上跑步呢？差异在于思维。如果想运用目前你能找到的大部分策略改变大脑，你会经历激烈的斗争。它们的理论基础是激发你的动力或告诉你遇到困难时不能退缩，可是这种廉价的激励坚持不了几天。\r\n微习惯策略就是为彻底改变你的大脑和生活而设计的。你的微目标成了你内心永恒的\r\n火花，它永不熄灭，这才激励人心。到了第三周，你会发现，“哇，我还在坚持”，到了第六周，你会看到收获（字数统计、肌肉增长、体重减少等），对自己能力的旧有认识会在你眼前粉碎。只要往小处想，你就会成为自己生活的主宰。你积累的能量和思维模式的转变会让你惊艳不已，我已经有了切身体会。\r\n\r\n你即将读完的这本书就是微习惯策略成功的证据。一个长期不自律的家伙在给自己的\r\n博客写出 4000 字文章的同时是怎么写出这本书的呢？我给自己提出了一个小小的要求——每天只写 50 字。第一周，我平均每天能写大约 1000 字。第二周，1500 字。第三周，2000 字。我并没有比以前更加努力，只是任务比以前更容易完成了。\r\n我希望你能看到在运用微习惯策略后未来将出现的变化。兴奋是很好的，但兴奋不会\r\n帮你维持状态，能帮助你的，是你为了给自己的生活带来最大改变而每天专心做的最小的事。\r\n\r\n如果你还在怀疑也没问题，只要试一试，你就会明白。\r\n\r\n##7. 绝不要小看微步骤\r\n如果你认为一步太渺小，那是因为你没有找到看待它的正确角度。每一个大工程都是\r\n由无数小步骤组成的，就像每一个有机体都是由微小的细胞组成的一样。采取微步骤能让你持续控制大脑。如果你意志力较弱，微步骤有时是你前进的唯一途径，学会爱上它们，你就会看到不可思议的结果！\r\n\r\n## 8. 用多余精力超额完成任务，而不是制定更大目标\r\n如果你急于取得巨大进步，那就把精力投入超额完成任务中。大目标在纸面上看着漂\r\n亮，但只有行动才算数。目标渺小、结果丰硕的状态比反过来好多了。\r\n\r\n', '1', '1', '2019-01-17 00:17:51', '2019-01-17 00:24:25');
INSERT INTO `posts` VALUES ('49', '4', '0', '2', 'vscode设置中文，设置中文不成功问题', '设置中文不成功,因为缺少拓展', '## 刚安装好的vscode界面显示英文，如何设置中文呢？\r\n\r\n在locale.json界面设置\r\n```\r\n\"locale\":\"zh-cn\"\r\n```\r\n也未能实现界面为中文，在网上找了参考了，以下教程真实测试有效！\r\n\r\n## 首先：\r\n\r\n下载插件：\r\n```\r\nChinese (Simplified) Language Pack for Visual Studio Code\r\n```\r\n\r\n在Chinese (Simplified) Language Pack for Visual Studio Code界面中点击Reload（重新加载）\r\n\r\n## 其次：\r\n\r\n使用快捷键在Ctrl+Shift+p 打开命令面板  输入“config”  进入locale.json（配置显示语言）\r\n\r\n将\"locale\"设置为\r\n\r\n```\r\n\"locale\":\"zh-cn\"\r\n```\r\n\r\n最后：\r\n```\r\n保存  \r\n关闭vscode编辑器  \r\n等待几秒重新配置好后  \r\n重新启动便是中文界面\r\n```', '1', '1', '2019-01-17 12:17:38', '2019-01-17 12:20:52');
INSERT INTO `posts` VALUES ('50', '4', '0', '2', 'Vue+webpack从零搭建工程项目', '一步一步构建自己的vuex项目', '## 基础项目搭建\r\n准备工作\r\n\r\n确认是否安装cnpm（淘宝镜像）\r\n```\r\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\r\n````\r\n\r\n# vscode 打开命令行\r\nctrl + `(esc下面的键)\r\n# 在目录下面,初始化一个 npm项目\r\n```\r\ncnpm init\r\n```\r\n# 安装库\r\n```\r\ncnpm i webpack@3.10.0 vue@2.5.13 vue-loader@13.6.0 \r\ncnpm i css-loader@0.28.7 vue-template-compiler@2.5.13\r\n```\r\n项目目录介绍\r\n```\r\ndist //将打包的资源输出目录\r\nnode_modules // 安装的库目录\r\nsrc // 源码目录\r\n    app.vue // vue初始组件\r\n    index.js //入口文件\r\npackage.json //项目配置信息文件,在用 npm init命令后生成\r\nwebpack-config.js //webpack打包配置文件\r\n````\r\napp.vue\r\n```\r\n// html代码\r\n<template>\r\n    <div class=\"title\"> {{text}}</div>\r\n</template>\r\n\r\n// js代码\r\n<script>\r\nexport default {\r\n    data(){\r\n        return{\r\n            text :\"hello world\"\r\n        }\r\n    }\r\n}\r\n</script>\r\n// css代码\r\n<style>\r\n.title{\r\n    color: red;\r\n}\r\n\r\n</style>\r\n```\r\nindex.js\r\n```\r\n// 将组件挂载到vue当中\r\nimport Vue from \'vue\'\r\n\r\nimport App from \'./app.vue\'\r\n// 将 vue组件挂载到一个 root节点中\r\nconst root = document.createElement(\'div\')\r\ndocument.body.appendChild(root)\r\n\r\nnew Vue({\r\n    render:(h)=>h(App)\r\n}).$mount(root)\r\n```\r\n\r\nwebpack.config.js 打包配置\r\n```\r\n// webpack打包资源的配置 图片,js,html等\r\n// node.js基础包\r\nconst path = require(\'path\')\r\nmodule.exports={\r\n    //程序入口文件,将当前的目录与后面的地址拼接\r\n    entry:path.join(__dirname,\'src/index.js\'),\r\n    //输出路径,webpack将 vue等信息打包为一个可以在浏览器运行的js文件\r\n    output:{\r\n        filename:\'bundle.js\',\r\n        path:path.join(__dirname,\'dist\')\r\n    },   \r\n    // 指定用什么处理 vue文件, webpack不能处理 vue文件\r\n    module:{\r\n      rules:[\r\n        {\r\n            test:/.vue$/,\r\n            loader:\'vue-loader\'\r\n        }\r\n      ]\r\n   }\r\n}\r\n```\r\npackage.json\r\n```\r\n{\r\n  \"name\": \"todolist\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"build\":\"webpack --config webpack.config.js\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"css-loader\": \"^0.28.7\",\r\n    \"vue\": \"^2.5.13\",\r\n    \"vue-loader\": \"^13.6.0\",\r\n    \"vue-template-compiler\": \"^2.5.13\",\r\n    \"webpack\": \"^3.10.0\"\r\n  }\r\n}  \r\n``` \r\ntips: 需要在此处配置,使用项目中的webpack ,在命令行中执行用的是全局的 webpack \"build\":\"webpack --config webapck.config.js\"\r\n\r\n编译\r\n```\r\ncnpm run build\r\n```\r\n>ok\r\n\r\n# 编译时可能提示需要安装库安装即可\r\n# npm install -D webpack-cli\r\n编译问题\r\n\r\nYou may need an appropriate loader to handle this file type.?\r\nwebpack只能处理js es5的文件,对 vue类型的文件,不能处理,我们需要手动指定处理规则\r\n\r\n查看 bunde.js代码,在这个其实有 vue代码, webpack 做的就是把 静态资源打包成 js文件,便于浏览器处理\r\n\r\nwebpack静态资源的处理\r\n\r\n安装库\r\n```\r\n npm i style-loader url-loader file-loader\r\n npm i stylus stylus-loader\r\n```\r\n配置信息\r\n```\r\n// webpack打包资源的配置 图片,js,html等\r\n\r\n// node.js基础包\r\nconst path = require(\'path\')\r\n\r\nconst VueLoaderPlugin = require(\'vue-loader/lib/plugin\');\r\nmodule.exports={\r\n    //程序入口文件,将当前的目录与后面的地址拼接\r\n    entry:path.join(__dirname,\'src/index.js\'),\r\n    //输出路径,webpack将 vue等信息打包为一个可以在浏览器运行的js文件\r\n    output:{\r\n        filename:\'bundle.js\',\r\n        path:path.join(__dirname,\'dist\')\r\n    },\r\n    plugins: [\r\n        // make sure to include the plugin for the magic\r\n        new VueLoaderPlugin()\r\n    ],\r\n    module:{\r\n        rules:[\r\n            {\r\n                // 指定vue-loader处理 vue文件, 处理 vue文件\r\n                test:/\\.vue$/,\r\n                loader:\'vue-loader\'\r\n            },\r\n            {\r\n                //处理 css \r\n                test:/\\.css$/,\r\n                // 使用css-loader读取内容,用 style-loader处理css写入到html代码中去\r\n                use:[\r\n                    \'style-loader\',\r\n                    \'css-loader\'\r\n                ]\r\n            },\r\n            {\r\n                // css 预处理文件\r\n                test:/\\.styl/,\r\n                use:[\r\n                    \'style-loader\',\r\n                    \'css-loader\',\r\n                    \'stylus-loader\'\r\n                ]\r\n            },\r\n            {   \r\n                // 图片处理的 loader\r\n                test:/\\.(gif|jpg|jpeg|png|svg)$/,\r\n                use:[\r\n                    {\r\n                        // 使用 url-loader(依赖于file-loader)处理 图片资源,options是要给url-loader传递的参数\r\n                        loader:\'url-loader\',\r\n                        options:{\r\n                            // 如果文件的大小小于1024kb,将将其转换为base64代码,存入html中\r\n                            limit:1024,\r\n                            // 输出图片原先的名字\r\n                            name:\'[name]-rao.[ext]\'\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n那么配置之后,就可以在js代码中 import 非js内容. index.js文件\r\n```\r\n// 引入非js.代码\r\nimport Vue from \'vue\'\r\nimport App from \'./app.vue\'\r\nimport \'./assets/styles/todo.css\'\r\nimport \'./assets/images/todo.png\'\r\nimport \'./assets/styles/todo-stylus.styl\'\r\n// 将 vue组件挂载到一个 root节点中\r\nconst root = document.createElement(\'div\')\r\ndocument.body.appendChild(root)\r\n\r\nnew Vue({\r\n    render:(h)=>h(App)\r\n}).$mount(root)\r\n````\r\nwebpack-dev-server的配置和使用\r\n\r\n安装库\r\n```\r\n// 开发服务器\r\nnpm i webpack-dev-server\r\n// 环境的切换 适应不同的平台\r\nnpm i cross-env\r\n// html插件\r\nnpm i html-webpack-plugin\r\n在 package.json配置 dev-server\r\n\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\",\r\n    \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"\r\n  },\r\n``` \r\nwebpack.cofig.js配置\r\n```\r\n// webpack打包资源的配置 图片,js,html等\r\n\r\n// node.js基础包\r\nconst path = require(\'path\')\r\n\r\nconst VueLoaderPlugin = require(\'vue-loader/lib/plugin\');\r\n\r\nconst HTMLPlugin = require(\'html-webpack-plugin\')\r\n\r\nconst webpack = require(\'webpack\')\r\n// 设置的环境变量存储在 process.env中\r\nconst isDev = process.env.NODE_ENV===\'development\'\r\n\r\nconst config ={\r\n    // 指定webpack的编译目标是web平台\r\n    target:\'web\',\r\n    //程序入口文件,将当前的目录与后面的地址拼接\r\n    entry:path.join(__dirname,\'src/index.js\'),\r\n    //输出路径,webpack将 vue等信息打包为一个可以在浏览器运行的js文件\r\n    output:{\r\n        filename:\'bundle.js\',\r\n        path:path.join(__dirname,\'dist\')\r\n    },\r\n    plugins: [\r\n        // make sure to include the plugin for the magic\r\n        new VueLoaderPlugin(),\r\n\r\n        new HTMLPlugin(),\r\n\r\n        // 定义一个环境变量 在这里定义了,在js代码中可以直接使用\r\n        new webpack.DefinePlugin({\r\n            \'process.env\':{\r\n                NODE_ENV:isDev ?\'\"development\"\':\'\"production\"\'\r\n            }\r\n        })\r\n    ],\r\n    module:{\r\n        rules:[\r\n            {\r\n                // 指定vue-loader处理 vue文件, 处理 vue文件\r\n                test:/\\.vue$/,\r\n                loader:\'vue-loader\'\r\n            },\r\n            {\r\n                //处理 css \r\n                test:/\\.css$/,\r\n                // 使用css-loader读取内容,用 style-loader处理css写入到html代码中去\r\n                use:[\r\n                    \'style-loader\',\r\n                    \'css-loader\'\r\n                ]\r\n            },\r\n            {\r\n                // css 预处理文件\r\n                test:/\\.styl/,\r\n                use:[\r\n                    \'style-loader\',\r\n                    \'css-loader\',\r\n                    \'stylus-loader\'\r\n                ]\r\n            },\r\n            {   \r\n                // 图片处理的 loader\r\n                test:/\\.(gif|jpg|jpeg|png|svg)$/,\r\n                use:[\r\n                    {\r\n                        // 使用 url-loader(依赖于file-loader)处理 图片资源,options是要给url-loader传递的参数\r\n                        loader:\'url-loader\',\r\n                        options:{\r\n                            // 如果文件的大小小于1024kb,将将其转换为base64代码,存入html中\r\n                            limit:1024,\r\n                            // 输出图片原先的名字\r\n                            name:\'[name]-rao.[ext]\'\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n// 环境切换的判断\r\nif (isDev){\r\n    // webpack打包后的js是转移的(如es6转程es5),在出错后不好定位,需要把转换后的js代码映射,这样我门\r\n    // 查看错误的时候,还是我们编写代码样式,便于定位\r\n    config.devtool =\"#cheap-module-eval-source-map\"\r\n    // 开发环境配置\r\n    config.devServer= {\r\n        port:\'8001\',\r\n        // 设置成 0.0.0.0可以通过 localhost,127.0.0.1,本机ip进行访问\r\n        host:\'0.0.0.0\',\r\n        //如果有错直接显示在网页上面\r\n        overlay:{\r\n            errors:true\r\n        },\r\n        // // 将server不理解的地址,映射首页\r\n        // historyFallback:{\r\n\r\n        // },\r\n        //在启动的时候自动打开浏览器\r\n        open:true,\r\n        // 只渲染当前组件的效果,不会整个项目重新渲染\r\n        hot:true\r\n    }\r\n    config.plugins.push(\r\n        // 热加载需要的插件\r\n        new webpack.HotModuleReplacementPlugin(),\r\n        // 过滤一些不需要的信息\r\n        new webpack.NoEmitOnErrorsPlugin()\r\n    )\r\n}\r\n\r\nmodule.exports =config\r\n```\r\n\r\n\r\n配置vue的jsx写法和 postcss\r\n\r\n安装库,在安装过程中可能提示缺少库,根据提示安装即可\r\n```\r\n    npm i postcss-loader autoprefixer babel-loader babel-core \r\n    npm i babel-preset-env babel-plugin-transform-vue-jsx\r\n```    \r\ntps:jsx就是把html代码写在js中,相比vue可能更加的灵活\r\n项目目录下新建文件\r\n```\r\n// babe使用\r\n.babelrc\r\n// postcss使用\r\npostcss.config.js\r\n.babelrc文件\r\n\r\n{\r\n    \"presets\": [\r\n        \"env\"\r\n    ],\r\n    \"plugins\": [\r\n        \"transform-vue-jsx\" // 处理 vue中的jsx\r\n    ]\r\n}\r\n```\r\nwebpack.congif.js配置处理 jsx\r\n```\r\n{\r\n       // 处理 jsx 文件\r\n       test:/\\.jsx/,\r\n       loader:\'babel-loader\'\r\n}, \r\n{\r\n                // css 预处理文件\r\n                test:/\\.styl/,\r\n                use:[\r\n                    \'style-loader\',\r\n                    \'css-loader\',\r\n                    \'stylus-loader\',\r\n                    {\r\n                        loader:\'postcss-loader\',\r\n                        // stylus-loader会生成sourcemap ,而postcss-loader也会生成sourcemanp,该项配置直接使用前面的sourcemap\r\n                        options:{\r\n                            sourceMap:true,\r\n                        }\r\n                    }\r\n                ]\r\n     },\r\n```\r\n打包的配置\r\ncss单独分离打包和 vue等类库单独打包\r\n```\r\n// 安装插件\r\nnpm i extract-text-webpack-plugin\r\n```\r\nwebpack.config.js配置\r\n```\r\n// 环境切换的判断\r\nif (isDev) {\r\n    // 开发环境使用的 styl样式\r\n    config.module.rules.push({\r\n        // css 预处理文件\r\n        test: /\\.styl/,\r\n        use: [\r\n            \"style-loader\",\r\n            \"css-loader\",\r\n            \"stylus-loader\",\r\n            {\r\n                loader: \"postcss-loader\",\r\n                // stylus-loader会生成sourcemap ,而postcss-loader也会生成sourcemanp,该项配置直接使用前面的sourcemap\r\n                options: {\r\n                    sourceMap: true\r\n                }\r\n            }\r\n        ]\r\n    });\r\n\r\n    // webpack打包后的js是转移的(如es6转程es5),在出错后不好定位,需要把转换后的js代码映射,这样我门\r\n    // 查看错误的时候,还是我们编写代码样式,便于定位\r\n    config.devtool = \"#cheap-module-eval-source-map\";\r\n    // 开发环境配置\r\n    config.devServer = {\r\n        port: \"8002\",\r\n        // 设置成 0.0.0.0可以通过 localhost,127.0.0.1,本机ip进行访问\r\n        host: \"0.0.0.0\",\r\n        //如果有错直接显示在网页上面\r\n        overlay: {\r\n            errors: true\r\n        },\r\n        // // 将server不理解的地址,映射首页\r\n        // historyFallback:{\r\n\r\n        // },\r\n        //在启动的时候自动打开浏览器\r\n        open: true,\r\n        // 只渲染当前组件的效果,不会整个项目重新渲染\r\n        hot: true\r\n    };\r\n    config.plugins.push(\r\n        // 热加载需要的插件\r\n        new webpack.HotModuleReplacementPlugin(),\r\n        // 过滤一些不需要的信息\r\n        new webpack.NoEmitOnErrorsPlugin()\r\n    );\r\n} else {\r\n    //配置入口文件 ,将类库单独打包\r\n    config.entry = {\r\n        app: path.join(__dirname, \"src/index.js\"),\r\n        // 要单独打包的库文件\r\n        vendor: [\'vue\']\r\n    }\r\n\r\n    //正式环境必须为 chunkhash\r\n    config.output.filename = \'[name].[chunkhash:8].js\'\r\n\r\n    // 正式环境处理 css样式,单独打包为一个静态文件\r\n    config.module.rules.push({\r\n        // css 预处理文件\r\n        test: /\\.styl/,\r\n        use: ExtractPlugin.extract({\r\n            fallback: \"style-loader\",\r\n            use: [\r\n                \"css-loader\",\r\n                \"stylus-loader\",\r\n                {\r\n                    loader: \"postcss-loader\",\r\n                    // stylus-loader会生成sourcemap ,而postcss-loader也会生成sourcemanp,该项配置直接使用前面的sourcemap\r\n                    options: {\r\n                        sourceMap: true\r\n                    }\r\n                }\r\n            ]\r\n        })\r\n    });\r\n\r\n    config.plugins.push(\r\n\r\n        //输出 css文件的名称\r\n        //new ExtractPlugin(\'styles.[contentHash:8].css\')\r\n\r\n        // 这个插件与 webpack存在兼容问题,这个是临时解决方案\r\n        new ExtractPlugin(\'styles.[chunkhash:8].css\'),\r\n\r\n        //单独打包类库文件 webpack存在兼容问题,需要注意版本 ,使用下面optimization方式进行配置\r\n        // new webpack.optimize.CommonsChunkPlugin({\r\n        //     //注意与上面配置name 一致\r\n        //     name :\'vendor\'\r\n        // })\r\n        //将 webpack配置的代码单独打包为一个文件,注意必须在单独打包库文件后面\r\n       // new webpack.optimize.commonsChunkPlugin({\r\n         //   name:\"runtime\"\r\n       // })\r\n    )\r\n\r\n    // https://webpack.js.org/plugins/split-chunks-plugin/\r\n    config.optimization={\r\n        runtimeChunk: {\r\n            name: \"manifest\"\r\n        },\r\n        splitChunks: {\r\n            cacheGroups: {\r\n                commons: {\r\n                    test: /[\\\\/]node_modules[\\\\/]/,\r\n                    name: \"vendor\",\r\n                    chunks: \"all\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n \r\nmodule.exports = config;\r\n```\r\nwebpack区分打包类库代码及hash优化\r\n类库的代码一般比较稳定,希望可以长时缓存在浏览器,避免跟业务代码合并在一起\r\n\r\ntips:hash和chunkhash的区别, hash方法打包出来的是项目的hash名称是一样的, chunkhash是单独模块的hash,是不一样的', '1', '1', '2019-01-17 14:36:48', '2019-01-17 22:06:32');
INSERT INTO `posts` VALUES ('51', '14', '0', '2', '8-微习惯结语', '作者斯蒂芬·盖斯的总结', '## 备选方案：递增式提高微目标策略（慎用！）\r\n\r\n有一个修改版的微习惯体系，你可以用它来逐渐提高自己的目标。\r\n\r\n我更希望你不这么做，因为目标提高之后，做事的自由度、灵活度和自发性会受到损失。\r\n\r\n我在完成自己的微习惯时从未发现有这么做的需要，因为只有在我刚好达到最低目标时（而且有时候我很庆幸目标很低），目标才会影响我。\r\n\r\n只有在发现每天只能达到最低目标时，你才应该提高目标。\r\n\r\n我建议你至少等一个月再尝试这么做。如果你很长时间都无法超越简单的目标，那么这些微习惯对你来说可能不如对别人那样有效。\r\n\r\n但别忘了习惯的安全网——它还是会变成习惯，而且微小的习惯相对容易逐步提高。\r\n\r\n如果你更适合刻板的计划，那么可以考虑使用这种方式。但在行为变成习惯之前，提\r\n高目标还是有风险的。如果你真要做，我建议你以非常缓慢的速度提高。\r\n\r\n一旦你拥有了一个习惯，就可以尝试更高的目标（比如 6 个月后，我把“每天做 1 个俯卧撑”变成了常规数量的健身目标）。\r\n\r\n既然到那时你是在强大的基础上增强，而且已经强化了意志力，更大目标会更容易实现。但再强调一次，如果你用微目标取得的效果不错，我建议不要急着用这个方法。\r\n\r\n也许你在达到最低目标 60 天后才能巧妙利用这个习惯。对我来说阅读就是这样（前文写过，我在第 57 天看到了巨大进步）。\r\n\r\n我刚开始每天只做 1 个俯卧撑，在大约 6 个月里每天只做 1 到 20 个。\r\n\r\n我偶尔也去健身房锻炼，但在刚开始只做这些。\r\n\r\n7 月下旬，我把目标调整为每周 3 次开车去健身。我不确定如果最开始就这么做我能不能成功（也许能），但我知道，挑战 1 个俯卧撑帮我增强了自律和锻炼的意愿，从而让这次跨越变得很轻松。\r\n\r\n## 在其他领域运用该策略\r\n微习惯可不只是一个教你如何培养健康新习惯的策略——它是一本自控力指导手册。\r\n\r\n现在你已经了解自己的大脑如何工作、动力策略无效的原因和如何管理自己的意志力才能使其持久。\r\n\r\n你可以把这些技巧用在任何你想展开行动的地方。你越精通微习惯策略，在生活方方面面收获的成功就会越多。\r\n\r\n这本书到这里就结束了。\r\n\r\n我希望你的阅读过程很愉快。\r\n\r\n我也希望这本书的结束标志着微习惯主导、充满刺激的全新旅程的开端。祝你在今后能取得每一个微小的成功！\r\n\r\n>斯蒂芬·盖斯', '1', '1', '2019-01-17 16:07:08', '2019-01-17 16:11:20');
INSERT INTO `posts` VALUES ('52', '14', '0', '2', '1-程序员职业路径该如何抉择？Career Path of a Programmer', '程序员职业路径该如何抉择？\r\n许多编程的职位都会到达最高峰，并开始衰落——这是很多程序员不想面对的，但却是一个不争的事实。这之后再找一份程序员的工作会变得越来越难，很多人发现这个事实时束手无策。本文会提供一些重要的职业信息，值得思考一下，以便有所准备。', '许多编程的职位都会到达最高峰，并开始衰落——这是很多程序员不想面对的，但却是一个不争的事实。这之后再找一份程序员的工作会变得越来越难，很多人发现这个事实时束手无策。本文会提供一些重要的职业信息，值得思考一下，以便有所准备。\r\n\r\n## 程序员职业之路的选择\r\n\r\nTechCrunch 发布了一篇文章「硅谷黑幕：技术人员年龄歧视」，文中引用的研究发现：对一个程序员来说，能从事高效的开发的年龄段是有限的。这个问题确实存在，而且非常严峻。\r\n```\r\n程序员的未来是什么样的？\r\n\r\n程序员的职业之路是什么样的？\r\n\r\n对于这些路应有什么样的选择和期望？\r\n```\r\n\r\n人人都知道程序员可以向经理或团队领导发展。但很多程序员不明白经理这个职位的期望和工作要求。当然，我们都有经理，但怎样才能成为经理呢？要具备什么素质？中层管理者和一个高级程序员之间有什么区别？\r\n\r\n在这篇文章中，我会拉开帷幕，介绍从一个从初级程序员到顶级 CTO 的潜在职业之路。\r\n\r\n注意：很多伟大的职业生涯停留在了不同的职位上，直到退休。一些职业生涯却连连升级。但是管理和领导角色并不适合每一个人，几年以后你可能会发 现你在管理上的兴趣改变了。二十几岁的时候你可能不喜欢做经理，但是四十岁时你可能不再喜欢写代码了。未来什么样，谁都很难说。然而，多了解一下你的选择 和情况总是好的。\r\n\r\n下面一张图表示的是程序员的各个职位的平均工资。注意在垂直水平上，一些人可能拿着两倍或者三倍于别人的工资（像是银行，贸易等行业）。所以这些数字仅代表了一个平均水平，并不全面。\r\n![phper_power](/public/img/posts/phper_power.png)\r\n\r\n程序员职业之路的选择\r\n\r\n### 初级程序员\r\n\r\n- 0-3 年工作经验（一般是刚从大学毕业）\r\n- 会写简单的脚本\r\n- 初步了解整个应用程序的生命周期\r\n- 初步了解数据库和应用程序的服务（队列，缓存等）\r\n- 不需了解复杂的应用中的每一个部分\r\n\r\n当你刚刚踏入程序员的行列中来的时候，可能会感到畏缩和烦恼。会时常感觉到自己资历尚浅，惊讶为什么会有人写出这么大而复杂的程序。不久之后，你就会想为什么自己还没有升级到高级程序员。看看其他的高级程序员，你觉得自己做着跟他们相同的工作。\r\n\r\n\r\n但是区别就在于初级程序员缺乏经验。即使是学习最快、最聪明的初级程序员，也没有接触到足够多的代码和边界情况，以胜任高级程序员的工作。\r\n\r\n在软 件开发方面，软件设计模式也是一种智慧。虽然在这方面可以阅读相关的书籍，但还是需要写足够多的代码，将错误尽可能地暴漏出来，真正理解软件设计模式的价 值。\r\n\r\n相关链接：\r\n\r\n- 《设计模式》 Gamma 著\r\n- “初级”程序员的真正含义\r\n- 初级开发者如何提高自己\r\n\r\n### 高级程序员\r\n \r\n- 至少四年工作经验\r\n- 能写较复杂的程序\r\n- 深入理解整个应用程序的生命周期\r\n- 掌握数据库和应用服务（队列，缓存等）\r\n- 要了解应用程序的每一个方面\r\n\r\n称职的高级程序员非常擅长构建大型程序。担任高级程序员占了程序员生涯的大部分。事实上，如果你不喜欢管理的工作而仅仅喜欢写代码，可以一直做一个高级程序员，我就雇佣了一些终生做程序员的人，但是，当老了以后，这项工作也会变得困难。\r\n\r\n这个职位也可以作为一个过渡。一旦你掌握了足够的技术，那么很可能就有能力担任一家技术创业公司的创始人或者 CTO 了。作为一个创始人或者 CTO，写代码的就会就少了，更多的是需要处理事务的技巧。但是深入理解技术非常有必要，是做好这份工作必不可少的部分。\r\n\r\n### 团队领导或架构师\r\n\r\n- 七年以上开发经验\r\n- 掌握高级程序员必备的技术\r\n- 团队领导：向架构师过渡\r\n- 架构师：没有更高的技术方面的职位\r\n\r\n做了七年程序员之后，如果你觉得不喜欢管理方面的工作，那么可以考虑一下做架构师，这是技术方面最顶峰的职位。架构师有时候也写代码，但大多数 时间他们在设计复杂的系统，然后交给由初级和高级程序员们组成团队来实现。\r\n\r\n架构师的工作就是，利用他技术方面的智慧以及多年的经验（学习程序的模式和反模 式），来为软件项目创建合适的架构。有新的需求的时候，软件架构师需要对项目选择正确的方向，并估算应用程序的规模。\r\n\r\n首席开发人员的工作是给其他初级的和高级的程序员指导和方向。虽然首席开发者通常不会做雇佣、解雇程序员的事情，但是他们的许多工作和经理无异。他们需做开发方面的协调，并在写代码的时候做出实现方面的决定。\r\n\r\n### 中层领导\r\n\r\n- 通常包含经理和负责人等职位（开发经理，项目经理，产品经理）\r\n- 做发人员的老板（例如人事工作）\r\n- 向高级主管汇报工作\r\n\r\n管理人员通常向工程师发展。他们的方向很多：如果你喜欢接触开发团队，并对细节感兴趣，那么可以选择产品经理，做你的伙伴们的盟友；如果你对产品特性和增强其性能着迷，那么做一个产品经理是最好的选择。\r\n\r\n然而大多数人的选择是开发经理。这是个经理中经典的职位，要求平衡项目经理和产品经理的需求和开发团队的性格之间的矛盾。\r\n\r\n这个职位对人事处理和 化解矛盾的技能要求较高，要经常做出退让。开发经理的工作不仅仅是雇佣新人，在必要时也要解聘一些人。这就意味着很难和他们成为朋友。因为一旦和他们成了 朋友，就处在了一个尴尬的位置。如果你认识的一个人从开发人员的职位升到了开发经理，你会发现这个人几乎在一夜之间变了。这就是为什么，这通常是一份费力 不讨好的工作。\r\n\r\n但如果领导一个团队胜利了，也是非常有收获的。如果你想提高领导才能，准备做一个管理角色，可以读读 Phil Jackson 的书 《Eleven Rings: The Soul of Success》 。\r\n\r\n### 高层领导\r\n\r\n- VP,CTO 或 CEO\r\n- 是中层领导的老板（例如负责人事）\r\n- 向另一个高层领导或者董事会报告\r\n\r\n和中层领导显而易见的不同是，高层领导负责管理中层领导。然而经理通常是不需要管理的，他们需要的是指导。中层领导需要知道高层领导的方向并跟进，不会得到非常具体的指示。\r\n\r\n高层领导的工作是，做重要的决定，并激励工作人员紧跟决策，增加对工作目标的信心。\r\n\r\n你在这条路上走得越远，写代码的机会就越少。\r\n\r\n到达顶峰的时候，做的都是人事方面的工作了。中层领导依然能在核心技术方方面体验到乐趣，但是对于 高层领导，就必须把所有的时间花在人事上：**激励员工，领导，指定策略**。如果你写代码，也只能是不重要的项目（除非你是比尔盖茨，但大多数人不是比尔，他是 个极端的特例）。Phil Jackson 的书要求，在这个职位上必须经常阅读，不能安于现状。\r\n\r\n高层领导的工作要求确保公司的每一个人都朝着相同的方向努力，确保方向的正确，确保每一个人知道他们朝这个方向努力的原因。这个工作难度非常大，而且充满着危险，心酸和陷阱。如果你想要一个高层领导，读一读 Ben Horowitz 的《The Hard Thing About Hard Things》.\r\n\r\n高层领导从来都不是天生的，而是经过不断地努力达到的。Ben Horowitz 的博客里有有关成为 CEO 的例子。\r\n\r\n## 结论\r\n\r\n今天，程序员的选择是丰富多彩的。而且对于程序员的职业要求比历史上任何时候都要高。对程序猿来说这是一个好的时代。但是任何时候规划你的职业都不算晚。希望本文能排得上用场，给你一些指导和精神食粮。', '1', '1', '2019-01-17 16:13:59', '2019-01-17 16:27:55');
INSERT INTO `posts` VALUES ('53', '4', '0', '2', 'npm老是报错，重新在windows环境搭建Vue开发环境', 'npm老是报错，我觉的命令行应该是没有问题。问题是早期的版本跟现在的版本有些地方不一样，冲突了。不是专业的前端，也不太懂，软件报错老是找不到合适的办法，那就重新装一下吧。', '## 一、安装node.js（https://nodejs.org/en/）\r\n\r\n[最新node.js版本](https://nodejs.org/en/)\r\n\r\n\r\n下载完毕后，可以安装node\r\n\r\n强调不要安装在系统盘系统目录里面，放在**自己定义的软件安装目录**里面。\r\n\r\n我是这么放的\r\n```\r\nC:\\soft\\nodejs\r\n```\r\n\r\n## 二、设置nodejs prefix（全局）和cache（缓存）路径\r\n\r\n1、在nodejs安装路径下，新建node_global和node_cache两个文件夹\r\n```\r\nC:\\soft\\nodejs\\node_global\r\nC:\\soft\\nodejs\\node_cache\r\n```\r\n\r\n2、设置缓存文件夹\r\n```\r\nnpm config set cache \"C:\\soft\\nodejs\\node_global\"\r\n```\r\n设置全局模块存放路径\r\n```\r\nnpm config set prefix \"D:\\vueProject\\nodejs\\node_cache\"\r\n```\r\n\r\n设置成功后，之后用命令npm install XXX -g安装以后模块就在D:\\vueProject\\nodejs\\node_global里 \r\n\r\n## 三、基于 Node.js 安装cnpm（淘宝镜像）\r\n```\r\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\r\n``` \r\n\r\n## 四、设置环境变量（非常重要）\r\n\r\n说明：设置环境变量可以使得住任意目录下都可以使用cnpm、vue等命令，而不需要输入全路径\r\n\r\n1、鼠标右键\"此电脑\"，选择“属性”菜单，在弹出的“系统”对话框中左侧选择“高级系统设置”，弹出“系统属性”对话框。\r\n\r\n2、修改系统变量PATH\r\n```\r\nPATH C:\\soft\\nodejs\\node_global \r\n```\r\n3、新增系统变量NODE_PATH \r\n```\r\nNODE_PATH C:\\soft\\nodejs\\node_modules\r\n```\r\n五、安装Vue\r\n```\r\ncnpm install vue -g\r\n```\r\n\r\n## 六、安装vue命令行工具，即vue-cli 脚手架\r\n```\r\ncnpm install vue-cli -g\r\n```\r\n##七、新项目的创建\r\n\r\n1.打开存放新建项目的文件夹\r\n\r\n打开开始菜单，输入 CMD，或使用快捷键 win+R，输入 CMD，敲回车，弹出命令提示符。打开你将要新建的项目目录\r\n\r\n2.根据模版创建新项目\r\n\r\n在当前目录下输入“vue init webpack-simple 项目名称（使用英文）”。\r\n```\r\nvue init webpack-simple mytest\r\n```\r\n\r\n3、安装工程依赖模块\r\n\r\n定位到mytest的工程目录下，安装该工程依赖的模块，这些模块将被安装在：mytest\\node_module目录下，node_module文件夹会被新建，而且根据package.json的配置下载该项目的modules\r\n```\r\ncd mytest\r\ncnpm install\r\n```\r\n4、运行该项目，测试一下该项目是否能够正常工作，这种方式是用nodejs来启动。\r\n```\r\ncnpm run dev\r\n```\r\n>挨踢小子，祝你好运 ', '1', '1', '2019-01-17 21:27:04', '2019-01-17 21:39:50');
INSERT INTO `posts` VALUES ('54', '4', '0', '2', 'vue+webpack项目工程配置(部分命令超详细)', '主要是深一点的了解他们，并去掌握他', '### 慕课地址:https://www.imooc.com/learn/935\r\n\r\n## 1.vue+webpack项目工程配置\r\n由于本代码是采用webpack3.10.0. 与webpack4.x有很多差异性,伙伴们不要因为版本问题而停滞不前\r\n\r\n具体版本可以在package.json中查看,具体细节都有超详细注释\r\n\r\n## 1.1 项目基本配置\r\n我用的是淘宝镜像，直接npm，会出现莫名其妙的bug。学习的过程中本人已经放弃\r\n用 **npm ** 初始化一个项目。\r\n\r\n学习的过程中，稳定，快速吸收才是最重要的。\r\n\r\n直接上代码\r\n```\r\ncnpm init \r\n```\r\n\r\n安装webpack和vue,使用vue要安装vue-loader\r\n```\r\ncnpm i webpack@3.10.0 vue@2.5.13 vue-loader@13.6.0 \r\n```\r\n\r\n根据终端WARN提示安装css-loader,因为vue-loader依赖css-loader \r\n\r\n针对各版本做了详细指定,由于更新过快,避免版本差异性问题,故指定了版本\r\n```\r\ncnpm i css-loader@0.28.7 vue-template-compiler@2.5.13\r\n```\r\n在app.vue中书写基本的vue结构\r\n\r\n首先在webpack.config.js设置入口entry\r\n\r\n声明我们的入口文件index.js\r\n\r\n示例中app.vue实际是一个组件,组件是不能直接挂载到我们的html中去,需要在index.js中挂载\r\n\r\nwebpack.config.js同样设置出口文件bundle.js及存放路径\r\n\r\n配置完后,在webpack.config.js中配置build脚本, --config 指定我们的config文件 因为在这里面写,当你调用时才会调用这个项目里面的webpack,否则将会调用全局的webpack,全局webpack和项目中的版本可能存在差异,建议使用这种方式会好一点\r\n\r\n## 1.2 各种静态资源的加载\r\nwebpack对其他类型的文件处理,可在配置文件中配置rules规则.\r\n\r\n同样根据配置中的处理的loader都要安装.\r\n\r\nstylus的css预处理器 \r\n```\r\ncnpm i stylus-loader@3.0.1 stylus@0.54.5\r\n```\r\n\r\n同理其他的像sass,less等其他的预处理器都可以类似的方法去使用\r\n```\r\ncnpm i style-loader@0.19.1 url-loader@0.6.2 file-loader@1.1.6\r\n```\r\n\r\n## 1.3 webpack-dev-server的配置\r\n```\r\ncnpm i webpack-dev-server@2.9.1\r\n```\r\nwebpack-dev-server在开发环境中会给我们带来与webpack不一样的效果,用的都是同一个配置文件\r\n```\r\n    \"build\": \"webpack --config webpack.config.js\",\r\n    \"dev\": \"webpack-dev-server --config webpack.config.js\"\r\n```\r\n同一个配置文件,那么其中必然会根据一个环境变量判断,来判断是开发环境还是正式环境\r\n\r\nNODE_ENV就是这个环境变量,在linux下 直接NODE_ENV=production,在windows环境下 需要set NODE_ENV=production,解决这种跨平台设置的差异性,我们可以安装cross-env@5.1.3\r\n```\r\ncnpm i cross-env@5.1.3\r\n```\r\n```\r\n    \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\",\r\n    \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"\r\n```\r\n在webpack.config.js配置好我们的测试环境后,我们还需要引入一个html-webpack-plugin,用于将我们打包好后的js融入到我们的HTml中去\r\n```\r\ncnpm i html-webpack-plugin@2.30.1\r\n```\r\n完成webpack.config.js中后,你便可以使用npm run dev见证奇迹的时刻了\r\n\r\n## 项目实战\r\n```\r\ncnpm i post i postcss-loader@2.0.9 autoprefixer@7.2.3 babel-loader@7.1.2 babel-core@6.26.0\r\n```\r\n新建postcss和babel的配置文件 并配置这两个文件\r\n\r\n项目业务\r\n\r\n详见源码\r\n\r\n配置css单独分离打包及其他一些测试和生产环境的区别\r\n\r\n安装extract-text-webpack-plugin\r\n```\r\ncnpm i extract-text-webpack-plugin@3.0.2\r\n```\r\n\r\n打包类库代码及hash优化\r\n\r\n有些未cnmp 的 请看 package.json下的dependencies参数和版本\r\n\r\n.babelrc\r\n```\r\n{\r\n    \"presets\": [\r\n        \"env\"\r\n    ],\r\n    \"plugins\": [\r\n        \"transform-vue-jsx\"    \r\n    ]\r\n}\r\n\r\n//转换vue中的jsx代码\r\n//npm i babel-preset-env@1.6.1 babel-plugin-transform-vue-jsx@3.5.0\r\n//npm i babel-helper-vue-jsx-merge-props@^2.0.0 babel-plugin-syntax-jsx@^6.8.0\r\n```\r\npackage.json\r\n```\r\n{\r\n  \"name\": \"vue-webpack-todo\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\",\r\n    \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"\r\n  },\r\n  \"author\": \"Jasonccj\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"autoprefixer\": \"^7.2.3\",\r\n    \"babel-core\": \"^6.26.0\",\r\n    \"babel-helper-vue-jsx-merge-props\": \"^2.0.0\",\r\n    \"babel-loader\": \"^7.1.2\",\r\n    \"babel-plugin-syntax-jsx\": \"^6.8.0\",\r\n    \"babel-plugin-transform-vue-jsx\": \"^3.5.0\",\r\n    \"babel-preset-env\": \"^1.6.1\",\r\n    \"cross-env\": \"^5.1.3\",\r\n    \"css-loader\": \"^0.28.7\",\r\n    \"extract-text-webpack-plugin\": \"^3.0.2\",\r\n    \"file-loader\": \"^1.1.6\",\r\n    \"html-webpack-plugin\": \"^2.30.1\",\r\n    \"i\": \"^0.3.6\",\r\n    \"post\": \"0.0.1\",\r\n    \"postcss-loader\": \"^2.0.9\",\r\n    \"style-loader\": \"^0.19.1\",\r\n    \"stylus\": \"^0.54.5\",\r\n    \"stylus-loader\": \"^3.0.1\",\r\n    \"url-loader\": \"^0.6.2\",\r\n    \"vue\": \"^2.5.13\",\r\n    \"vue-loader\": \"^13.6.0\",\r\n    \"vue-template-compiler\": \"^2.5.13\",\r\n    \"webpack\": \"^3.10.0\",\r\n    \"webpack-dev-server\": \"^2.9.1\"\r\n  },\r\n  \"devDependencies\": {}\r\n}\r\n```\r\n\r\npostcss.config.js\r\n```\r\nconst autoprefixer = require(\'autoprefixer\')\r\n\r\nmodule.exports = {\r\n    plugins: [\r\n        autoprefixer()      //优化的过程通过一系列的组件进行优化,此次采用的是autoprefixer\r\n    ]\r\n}\r\n\r\n//PostCss会对CSS代码进行优化,主要是解决不同浏览器识别码的问题,具体作用自行查阅\r\n//PostCss官网: https://www.postcss.com.cn/\r\n//-ms代表【ie】内核识别码\r\n//-moz代表火狐【firefox】内核识别码\r\n//-webkit代表谷歌【chrome】/苹果【safari】内核识别码\r\n//-o代表欧朋【opera】内核识别码\r\n```\r\n\r\nwebpack.config.js\r\n```\r\nconst path = require(\'path\')                            //path是Nodejs中的基本包,用来处理路径\r\nconst HTMLPlugin = require(\'html-webpack-plugin\')       //引入html-webpack-plugin\r\nconst webpack = require(\"webpack\")                      //引入webpack\r\nconst ExtractPlugin = require(\"extract-text-webpack-plugin\")\r\n\r\nconst isDev = process.env.NODE_ENV === \"development\"    //判断是否为测试环境,在启动脚本时设置的环境变量都是存在于process.env这个对象里面的\r\n\r\nconst config = {\r\n    target: \"web\",                                      //设置webpack的编译目标是web平台\r\n    entry: path.join(__dirname,\'src/index.js\'),         //声明js文件入口,__dirname就是我们文件的根目录,用join拼接\r\n    output:{                                            //声明出口文件\r\n        filename: \'bundle.js\',                          //将挂载的App全部打包成一个bundle.js,在浏览器中可以直接运行的代码  \r\n        path: path.join(__dirname,\'dist\')               //bundle.js保存的位置\r\n    },\r\n    module:{                                            //因为webpack只能处理js文件,且只识别ES5的语法\r\n        rules:[                                         //所以针对不同类型的文件,我们定义不同的识别规则,最终目的都是打包成js文件\r\n            {\r\n                test: /\\.vue$/,\r\n                loader: \'vue-loader\'                    //处理.vue文件\r\n            },\r\n            {\r\n                test: /\\.jsx$/,\r\n                loader: \'babel-loader\'                  //处理jsx文件\r\n            },\r\n            // {\r\n            //     test: /\\.css$/,\r\n            //     use: [\r\n            //         \'style-loader\',                     //将css的样式写入到html里面去\r\n            //         \'css-loader\'                        //处理css文件  \r\n            //     ]\r\n            // },\r\n            {\r\n                test: /\\.(gif|jpg|jpeg|png|svg)$/,      //处理图片\r\n                use: [\r\n                    {                                   //loader是可以配置选项的,如下options\r\n                        loader: \'url-loader\',           //url-loader实际上依赖于file-loader,file-loader处理完文件可以保存为一个文件供处理\r\n                        options: { \r\n                            limit: 1024,                //url-loader的好处是可以加一个限制的大小,对于小图片,在范围内可直接将图片转换成base64码直接存放在js中,以减少http请求.\r\n                            name: \'[name].[ext]\'        //输出文件的名字,[name] 文件原名,[ext]文件扩展名.\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n    plugins:[\r\n        new webpack.DefinePlugin({                      //主要作用是在此处可以根据isdev配置process.env,一是可以在js代码中可以获取到process.env,\r\n            \'process.env\':{                             //二是webpack或则vue等根据process.env如果是development,会给一些特殊的错误提醒等,而这些特殊项在正式环境是不需要的\r\n                NODE_ENV: isDev ? \'\"development\"\' : \'\"production\"\'\r\n            }\r\n        }),\r\n        new HTMLPlugin()                                //引入HTMLPlugin    \r\n    ]\r\n}\r\n\r\nif(isDev){\r\n    config.module.rules.push(\r\n        {\r\n            test: /\\.styl/,\r\n            use: [\r\n                \'style-loader\',                     //将css写入到html中去\r\n                \'css-loader\',                       //css-loader处理css\r\n                {\r\n                    loader: \'postcss-loader\',\r\n                    options: {\r\n                        sourceMap: true,            //stylus-loader和postcss-loader自己都会生成sourceMap,如果前面stylus-loader已生成了sourceMap\r\n                    }                               //那么postcss-loader可以直接引用前面的sourceMap\r\n                },\r\n                \'stylus-loader\'                     //处理stylus的css预处理器的问题件,转换成css后,抛给上一层的css-loader\r\n            ]\r\n        }\r\n    )                                             //如果是测试环境下的一些配置\r\n    config.devtool = \'#cheap-module-eval-source-map\'    //官方推荐使用这个配置,作用是在浏览器中调试时,显示的代码和我们的项目中的代码会基本相似,而不会显示编译后的代码,以致于我们调试连自己都看不懂                                      \r\n    config.devServer = {                                //这个devServer的配置是在webpack2.x以后引入的,1.x是没有的\r\n        port: 8000,                                     //访问的端口号\r\n        host: \'127.0.0.1\',                              //可以设置0.0.0.0 ,这样设置你可以通过127.0.0.1或则localhost去访问\r\n        overlay: {\r\n            errors: true,                               //编译中遇到的错误都会显示到网页中去\r\n        },\r\n        // open: true ,                                 //项目启动时,会默认帮你打开浏览器\r\n        hot: true                                       //在单页面应用开发中,我们修改了代码后是整个页面都刷新,开启hot后,将只刷新对应的组件\r\n    },\r\n    config.plugins.push(                                //添加两个插件用于hot:true的配置\r\n        new webpack.HotModuleReplacementPlugin(),\r\n        new webpack.NoEmitOnErrorsPlugin()\r\n    )\r\n} else{\r\n    config.entry = {\r\n        app: path.join(__dirname,\'src/index.js\'),\r\n        vendor: [\'vue\']   \r\n    }\r\n    config.output.filename = \'[name].[chunkhash:8].js\'  //此处一定是chunkhash,因为用hash时app和vendor的hash码是一样的了,这样每次业务代码更新,vendor也会更新,也就没有了意义.\r\n    config.module.rules.push(\r\n        {\r\n            test: /\\.styl/,\r\n            use: ExtractPlugin.extract({\r\n                fallback: \'style-loader\',\r\n                use: [\r\n                    \'css-loader\',                       //css-loader处理css\r\n                    {\r\n                        loader: \'postcss-loader\',\r\n                        options: {\r\n                            sourceMap: true,            //stylus-loader和postcss-loader自己都会生成sourceMap,如果前面stylus-loader已生成了sourceMap\r\n                        }                               //那么postcss-loader可以直接引用前面的sourceMap\r\n                    },\r\n                    \'stylus-loader\'                     //处理stylus的css预处理器的问题件,转换成css后,抛给上一层的css-loader\r\n                ]\r\n            })\r\n        },\r\n    ),\r\n    config.plugins.push(\r\n        new ExtractPlugin(\'styles.[contentHash:8].css\'),   //定义打包分离出的css文件名\r\n        new webpack.optimize.CommonsChunkPlugin({          //定义静态文件打包\r\n            name: \'vendor\'\r\n        }),\r\n        new webpack.optimize.CommonsChunkPlugin({         //将app.js文件中一些关于webpack文件的配置单独打包出为一个文件,用于解决部分浏览器长缓存问题   \r\n            name: \'runtime\'\r\n        })\r\n    )\r\n} \r\n\r\nmodule.exports = config                                 //声明一个config的配置,用于对外暴露\r\n```\r\n', '1', '1', '2019-01-18 03:03:16', '2019-01-18 03:32:08');
INSERT INTO `posts` VALUES ('55', '13', '0-13', '2', '周四打卡（011720）', 'vue+webpack 学习', 'vue+webpack 学习', '1', '1', '2019-01-16 20:30:00', '2019-01-17 20:35:32');
INSERT INTO `posts` VALUES ('56', '15', '0-15', '2', '0-我是如何自学Go语言的 ', '我就是那一小部分的人。', '我是入门go的新手，以下是大神的一些建议和帮助。\r\n\r\n书籍：go程序设计语言 \r\n\r\n网站：https://github.com/gopl-zh/gopl-zh.github.com\r\n\r\n论坛：go语言中文社区论坛，CSDN\r\n\r\n网站：https://cloud.tencent.com/developer/doc/1101\r\n\r\n这个网站上面直接有中文教程了，学起来不费力，极力推荐刚入门的时候主要会用到的资源就是以上这些。\r\n\r\n建议新手们可以跟着教程把基础打牢了，然后多看你一些相关的书籍。\r\n\r\n不懂的可以上论坛问，上面有很多大神。\r\n\r\n最重要的是有空还是要自己写写，练习比较重要。', '1', '1', '2019-01-18 18:45:48', '2019-01-18 18:54:20');
INSERT INTO `posts` VALUES ('57', '15', '0-15', '2', '1-Go 教程', 'Go 是一种编译型语言，它结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型的安全性。它也打算成为现代的，支持网络与多核计算的语言。要满足这些目标，需要解决一些语言上的问题：一个富有表达能力但轻量级的类型系统，并发与垃圾回收机制，严格的依赖规范等等。这些无法通过库或工具解决好，因此Go也就应运而生了。', 'Go 是一种编译型语言，它结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型的安全性。它也打算成为现代的，支持网络与多核计算的语言。要满足这些目标，需要解决一些语言上的问题：一个富有表达能力但轻量级的类型系统，并发与垃圾回收机制，严格的依赖规范等等。这些无法通过库或工具解决好，因此Go也就应运而生了。\r\n\r\n菜鸟工具\r\n网站：http://www.runoob.com/go/go-tutorial.html\r\n\r\n手册目录\r\n档案 | archive\r\n\r\n缓冲区 | bufio\r\n\r\n内置 | builtin\r\n\r\n字节 | bytes\r\n\r\n压缩 | compress\r\n\r\n容器 | container\r\n```\r\n上下文 | context\r\n加密 | crypto\r\n数据库 | database\r\n调试 | debug\r\n编码 | encoding\r\n错误 | errors\r\nexpvar\r\nflag\r\nfmt\r\ngo\r\n散列 | hash\r\nhtml\r\n图像 | image\r\n索引 | index\r\nio\r\n日志 | log\r\n数学 | math\r\nmath/big\r\nmath/bits\r\nmath/cmplx\r\nmath/rand\r\n拟态 | mime\r\nnet\r\nnet/http\r\nnet/mail\r\nnet/rpc\r\nnet/smtp\r\nnet/textproto\r\nnet/url\r\nos\r\n路径 | path\r\n插件 | plugin\r\n反射 | reflect\r\n正则表达式 | regexp\r\n运行时 | runtime\r\n排序算法 | sort\r\n转换 | strconv\r\n字符串 | strings\r\n同步 | sync\r\n系统调用 | syscall\r\n测试 | testing\r\n文本 | text\r\n时间戳 | time\r\nunicode\r\n不安全性 | unsafe\r\n```', '1', '1', '2019-01-18 18:55:11', '2019-01-18 20:54:57');
INSERT INTO `posts` VALUES ('58', '13', '0-13', '2', '周五打卡（011820）', '准备学习go', '## 准备学习go\r\n## 巩固数据库基础\r\n## 熟悉算法的优化', '1', '1', '2019-01-18 15:00:50', '2019-01-18 15:02:18');
INSERT INTO `posts` VALUES ('59', '13', '0-13', '2', '周日打卡', 'es学习\r\n关联模型', 'elasticsearch\r\n\r\n多态多对的\r\n\r\n多态关联\r\n\r\n远程一对多\r\n\r\n多对多\r\n\r\n一对多反向\r\n\r\n一对多\r\n\r\n一对一', '1', '1', '2019-01-19 11:08:12', '2019-01-19 11:11:08');
INSERT INTO `posts` VALUES ('60', '13', '0-13', '2', '我要学习git 创建与合并分支学习', '创建与合并分支\r\n解决冲突\r\n分支管理策略\r\nBug分支\r\nFeature分支\r\n多人协作\r\nRebase', '## 解决冲突\r\n-[git-解决冲突](/index.php/index/postinfo/id/62)\r\n\r\n## 分支管理策略\r\n- [分支管理策略](/index.php/index/postinfo/id/63)\r\n\r\n## Bug分支\r\n- [错误分支](/index.php/index/postinfo/id/64)\r\n\r\n## Feature分支\r\n- [Feature分支](/index.php/index/postinfo/id/65)\r\n\r\n## 多人协作\r\n- [多人协作](/index.php/index/postinfo/id/66)\r\n\r\n## Rebase\r\n- [xxx]()', '1', '1', '2019-01-19 05:37:26', '2019-01-20 07:42:22');
INSERT INTO `posts` VALUES ('61', '4', '0-4', '2', 'git-创建与合并分支', '学习git命令\r\n\r\n查看分支：git branch\r\n\r\n创建分支：git branch <name>\r\n\r\n切换分支：git checkout <name>\r\n\r\n创建+切换分支：git checkout -b <name>\r\n\r\n合并某分支到当前分支：git merge <name>\r\n\r\n删除分支：git branch -d <name>', '在[版本回退里](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000)，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。\r\n\r\n截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\r\n\r\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\r\n\r\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\r\n\r\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\r\n\r\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\r\n\r\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\r\n\r\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\r\n\r\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\r\n\r\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\r\n\r\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\r\n\r\n下面开始实战。\r\n\r\n首先，我们创建dev分支，然后切换到dev分支：\r\n```\r\n$ git checkout -b dev\r\nSwitched to a new branch \'dev\'\r\n```\r\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\r\n```\r\n$ git branch dev\r\n$ git checkout dev\r\nSwitched to branch \'dev\'\r\n```\r\n然后，用git branch命令查看当前分支：\r\n```\r\n$ git branch\r\n* dev\r\n  master\r\n```\r\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\r\n\r\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\r\n```\r\nCreating a new branch is quick.\r\n```\r\n然后提交：\r\n```\r\n$ git add readme.txt \r\n$ git commit -m \"branch test\"\r\n[dev b17d20e] branch test\r\n 1 file changed, 1 insertion(+)\r\n```\r\n现在，dev分支的工作完成，我们就可以切换回master分支：\r\n```\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\n```\r\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\r\n```\r\ngit-br-on-master\r\n```\r\n现在，我们把dev分支的工作成果合并到master分支上：\r\n```\r\n$ git merge dev\r\nUpdating d46f35e..b17d20e\r\nFast-forward\r\n readme.txt | 1 +\r\n 1 file changed, 1 insertion(+)\r\n```\r\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\r\n\r\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\r\n\r\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\r\n\r\n合并完成后，就可以放心地删除dev分支了：\r\n```\r\n$ git branch -d dev\r\nDeleted branch dev (was b17d20e).\r\n```\r\n删除后，查看branch，就只剩下master分支了：\r\n```\r\n$ git branch\r\n* master\r\n```\r\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\r\n\r\n小结\r\n\r\nGit鼓励大量使用分支：\r\n\r\n查看分支：git branch\r\n\r\n创建分支：git branch <name>\r\n\r\n切换分支：git checkout <name>\r\n\r\n创建+切换分支：git checkout -b <name>\r\n\r\n合并某分支到当前分支：git merge <name>\r\n\r\n删除分支：git branch -d <name>', '1', '1', '2019-01-19 05:40:57', '2019-01-19 05:47:02');
INSERT INTO `posts` VALUES ('62', '4', '0-4', '2', 'git-解决冲突', '解决冲突就是把Git的合并失败的文件手动编辑为我们希望的内容，再提交。', '>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\r\n\r\n新准备的feature1分支，继续我们的新分支开发：\r\n```\r\n$ git checkout -b feature1\r\nSwitched to a new branch \'feature1\'\r\n```\r\n修改readme.txt求最后一行，改为：\r\n```\r\nCreating a new branch is quick AND simple.\r\n```\r\n在feature1分支上提交：\r\n```\r\n$ git add readme.txt\r\n\r\n$ git commit -m \"AND simple\"\r\n[feature1 14096d0] AND simple\r\n 1 file changed, 1 insertion(+), 1 deletion(-)\r\n```\r\n到e月刊master分支：\r\n```\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\nYour branch is ahead of \'origin/master\' by 1 commit.\r\n  (use \"git push\" to publish your local commits)\r\n```\r\nGIT中自动还会提示我们当前master分支比远程的master分支要超前1个提交。\r\n\r\n在master分支上把readme.txt文件的求最后一行对划线：\r\n```\r\nCreating a new branch is quick & simple.\r\n```\r\n提交：\r\n```\r\n$ git add readme.txt \r\n$ git commit -m \"& simple\"\r\n[master 5dc6824] & simple\r\n 1 file changed, 1 insertion(+), 1 deletion(-)\r\n```\r\n现在，master分支状语从句：feature1分支各自都分别有新的提交，变成了这样：\r\n\r\n### GIT-BR-优点1\r\n\r\n这种情况下，Git会无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\r\n```\r\n$ git merge feature1\r\nAuto-merging readme.txt\r\nCONFLICT (content): Merge conflict in readme.txt\r\nAutomatic merge failed; fix conflicts and then commit the result.\r\n```\r\n果然冲突了Git的告诉我们，！readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：\r\n```\r\n$ git status\r\nOn branch master\r\nYour branch is ahead of \'origin/master\' by 2 commits.\r\n  (use \"git push\" to publish your local commits)\r\n\r\nYou have unmerged paths.\r\n  (fix conflicts and run \"git commit\")\r\n  (use \"git merge --abort\" to abort the merge)\r\n\r\nUnmerged paths:\r\n  (use \"git add <file>...\" to mark resolution)\r\n\r\n    both modified:   readme.txt\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\r\n```\r\n我们可以直接查看readme.txt文件的内容：\r\n```\r\nGit is a distributed version control system.\r\nGit is free software distributed under the GPL.\r\nGit has a mutable index called stage.\r\nGit tracks changes of files.\r\n<<<<<<< HEAD\r\nCreating a new branch is quick & simple.\r\n=======\r\nCreating a new branch is quick AND simple.\r\n>>>>>>> feature1\r\n```\r\nGit的用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：\r\n```\r\nCreating a new branch is quick and simple.\r\n```\r\n再提交：\r\n```\r\n$ git add readme.txt \r\n$ git commit -m \"conflict fixed\"\r\n[master cf810e4] conflict fixed\r\n```\r\n现在，master分支状语从句：feature1分支变成了下图产品所示：\r\n\r\n### GIT-BR-冲突合并\r\n\r\n带用的参数git log也。可以看到分支的合并情况：\r\n```\r\n$ git log --graph --pretty=oneline --abbrev-commit\r\n*   cf810e4 (HEAD -> master) conflict fixed\r\n|\\  \r\n| * 14096d0 (feature1) AND simple\r\n* | 5dc6824 & simple\r\n|/  \r\n* b17d20e branch test\r\n* d46f35e (origin/master) remove test.txt\r\n* b84166e add test.txt\r\n* 519219b git tracks changes\r\n* e43a48b understand how stage works\r\n* 1094adb append GPL\r\n* e475afc add distributed\r\n* eaadf4e wrote a readme file\r\n```\r\n最后，删除feature1分支：\r\n```\r\n$ git branch -d feature1\r\nDeleted branch feature1 (was 14096d0).\r\n```\r\n工作完成。\r\n\r\n## 小结\r\n当混帐无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\r\n\r\n解决冲突就是把Git的合并失败的文件手动编辑为我们希望的内容，再提交。\r\n\r\n用git log --graph命令可以看到分支合并图产品。', '1', '1', '2019-01-19 05:49:46', '2019-01-19 05:53:01');
INSERT INTO `posts` VALUES ('63', '4', '0-4', '2', 'git -分支管理策略', 'Fast forward模式', '通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\r\n\r\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\r\n\r\n下面我们实战一下--no-ff方式的git merge：\r\n\r\n首先，仍然创建并切换dev分支：\r\n```\r\n$ git checkout -b dev\r\nSwitched to a new branch \'dev\'\r\n```\r\n修改readme.txt文件，并提交一个新的commit：\r\n```\r\n$ git add readme.txt \r\n$ git commit -m \"add merge\"\r\n[dev f52c633] add merge\r\n 1 file changed, 1 insertion(+)\r\n```\r\n现在，我们切换回master：\r\n```\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\n```\r\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\r\n```\r\n$ git merge --no-ff -m \"merge with no-ff\" dev\r\nMerge made by the \'recursive\' strategy.\r\n readme.txt | 1 +\r\n 1 file changed, 1 insertion(+)\r\n```\r\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\r\n\r\n合并后，我们用git log看看分支历史：\r\n```\r\n$ git log --graph --pretty=oneline --abbrev-commit\r\n*   e1e9c68 (HEAD -> master) merge with no-ff\r\n|\\  \r\n| * f52c633 (dev) add merge\r\n|/  \r\n*   cf810e4 conflict fixed\r\n...\r\n```\r\n**可以看到，不使用Fast forward模式，merge后就像这样：**\r\n![](/public/img/posts/git_not_fast_forward.png)\r\n```\r\ngit-no-ff-mode\r\n```\r\n分支策略\r\n在实际开发中，我们应该按照几个基本原则进行分支管理：\r\n\r\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\r\n\r\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\r\n\r\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\r\n\r\n所以，团队合作的分支看起来就像这样：\r\n![](/public/img/posts/git_fast_forward.png)\r\ngit-br-policy\r\n\r\n## 小结\r\nGit分支十分强大，在团队开发中应该充分应用。\r\n\r\n合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。', '1', '1', '2019-01-19 05:56:50', '2019-01-19 06:04:09');
INSERT INTO `posts` VALUES ('64', '4', '0-4', '2', 'git-错误分支', '“任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人能读懂的代码” —— Martin Fowler', '>“任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人能读懂的代码” —— Martin Fowler\r\n\r\n软件开发中，错误就像家常便饭一样。有了错误就需要修复，在混帐中，由于分支是如此的强大，所以，每个错误都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\r\n\r\n当你接到一个修复一个代号101的错误的任务时，很自然地，想你创建³³一个分支issue-101来修复它，但是，等等，正在当前dev上进行的工作还没有提交：\r\n```\r\n$ git status\r\nOn branch dev\r\nChanges to be committed:\r\n  (use \"git reset HEAD <file>...\" to unstage)\r\n\r\n    new file:   hello.py\r\n\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\r\n\r\n    modified:   readme.txt\r\n```\r\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该错误，怎么办？\r\n\r\n幸好，Git的提供还了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\r\n```\r\n$ git stash\r\nSaved working directory and index state WIP on dev: f52c633 add merge\r\n```\r\n现在，用git status查看工作区，就是干净的（除非有没有被GIT中管理的文件），因此可以放心地创建分支来修复错误。\r\n\r\n首先确定要在哪个分支上修复的bug，需要假定在master分支上修复，从就master创建³³临时分支：\r\n```\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\nYour branch is ahead of \'origin/master\' by 6 commits.\r\n  (use \"git push\" to publish your local commits)\r\n\r\n$ git checkout -b issue-101\r\nSwitched to a new branch \'issue-101\'\r\n```\r\n现在修复bug，需要把“Git是自由软件......”改为“Git是一个自由软件...”，然后提交：\r\n```\r\n$ git add readme.txt \r\n$ git commit -m \"fix bug 101\"\r\n[issue-101 4c805e2] fix bug 101\r\n 1 file changed, 1 insertion(+), 1 deletion(-)\r\n```\r\n修复完成后，到e月刊master分支，并完成合并，删除求最后issue-101分支：\r\n```\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\nYour branch is ahead of \'origin/master\' by 6 commits.\r\n  (use \"git push\" to publish your local commits)\r\n\r\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\r\nMerge made by the \'recursive\' strategy.\r\n readme.txt | 2 +-\r\n 1 file changed, 1 insertion(+), 1 deletion(-)\r\n```\r\n太棒了，原计划两个小时的缺陷修复只花了5分钟！现在，时候的英文接着回到dev分支干活了！\r\n```\r\n$ git checkout dev\r\nSwitched to branch \'dev\'\r\n\r\n$ git status\r\nOn branch dev\r\nnothing to commit, working tree clean\r\n？工作区是干净的，的刚才工作现场存到哪去了用git stash list命令看看：\r\n\r\n$ git stash list\r\nstash@{0}: WIP on dev: f52c633 add merge\r\n```\r\n工作现场还在，Git的把藏匿内容存在某个地方了，但是需要恢复一下，有两个办法：\r\n\r\n用一是git stash apply恢复，但是恢复后，藏匿内容并不删除，需要你用git stash drop来删除;\r\n\r\n另一种方式是用git stash pop，恢复的同时把藏匿内容也删了：\r\n```\r\n$ git stash pop\r\nOn branch dev\r\nChanges to be committed:\r\n  (use \"git reset HEAD <file>...\" to unstage)\r\n\r\n    new file:   hello.py\r\n\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\r\n\r\n    modified:   readme.txt\r\n\r\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\r\n```\r\n再用git stash list查看，就看不到任何藏匿内容了：\r\n```\r\n$ git stash list\r\n```\r\n你可以多次藏匿处，恢复的时候，用先git stash list查看，然后恢复指定的藏匿处，用命令：\r\n```\r\n$ git stash apply stash@{0}\r\n```\r\n## 小结\r\n修复错误时，我们会通过创建新的错误分支进行修复，然后合并，最后删除;\r\n\r\n当手头工作没有完成时，工作先把现场git stash一下，然后去修复的bug，修复后，再git stash pop，回到工作现场。', '1', '1', '2019-01-19 06:06:29', '2019-01-19 06:13:01');
INSERT INTO `posts` VALUES ('65', '4', '0-4', '2', 'git-Feature分支', '如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。', '软件开发中，总有无穷无尽的新的功能要不断添加进来。\r\n\r\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\r\n\r\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\r\n\r\n于是准备开发：\r\n````\r\n$ git checkout -b feature-vulcan\r\nSwitched to a new branch \'feature-vulcan\'\r\n```\r\n5分钟后，开发完毕：\r\n```\r\n$ git add vulcan.py\r\n\r\n$ git status\r\nOn branch feature-vulcan\r\nChanges to be committed:\r\n  (use \"git reset HEAD <file>...\" to unstage)\r\n\r\n    new file:   vulcan.py\r\n\r\n$ git commit -m \"add feature vulcan\"\r\n[feature-vulcan 287773e] add feature vulcan\r\n 1 file changed, 2 insertions(+)\r\n create mode 100644 vulcan.py\r\n```\r\n切回dev，准备合并：\r\n```\r\n$ git checkout dev\r\n```\r\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\r\n\r\n但是！\r\n\r\n就在此时，接到上级命令，因经费不足，新功能必须取消！\r\n\r\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\r\n```\r\n$ git branch -d feature-vulcan\r\nerror: The branch \'feature-vulcan\' is not fully merged.\r\nIf you are sure you want to delete it, run \'git branch -D feature-vulcan\'.\r\n```\r\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\r\n\r\n现在我们强行删除：\r\n```\r\n$ git branch -D feature-vulcan\r\nDeleted branch feature-vulcan (was 287773e).\r\n```\r\n终于删除成功！\r\n\r\n## 小结\r\n开发一个新feature，最好新建一个分支；\r\n\r\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。', '1', '1', '2019-01-19 06:16:54', '2019-01-19 06:19:06');
INSERT INTO `posts` VALUES ('66', '4', '0-4', '2', 'git-多人协作', '使用git push origin branch-name，如果推送失败，用先git pull抓取远程的新提交', '当你从远程仓库克隆时，实际上Git的把自动本地的master分支远程状语从句：的master分支对应起来了，并且，远程仓库的默认名称是origin。\r\n\r\n要查看远程库的信息，用git remote：\r\n```\r\n$ git remote\r\norigin\r\n```\r\n或者，用git remote -v显示更详细的信息：\r\n```\r\n$ git remote -v\r\norigin  git@github.com:michaelliao/learngit.git (fetch)\r\norigin  git@github.com:michaelliao/learngit.git (push)\r\n```\r\n显示上面可以了状语从句：抓取推送的origin的地址。如果没有推送权限，就看不到推的地址。\r\n\r\n## 推送分支\r\n推送分支，就是把该分支上的所有本地提交推送到远程库推送时，要指定本地分支，这样，Git的就会把该分支推送到远程库对应的远程分支上：\r\n```\r\n$ git push origin master\r\n```\r\n如果要推送其他分支，比如dev，就改成：\r\n```\r\n$ git push origin dev\r\n```\r\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\r\n\r\nmaster分支是主分支，因此要时刻与远程同步;\r\n\r\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步;\r\n\r\n错误分支只用于在本地修复错误，就没必要推到远程了，除非老板要看看你每周到底修复了几个错误;\r\n\r\n设有分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\r\n\r\n总之，就是在混帐中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\r\n\r\n## 抓取分支\r\n多人协作时，都会大家往master状语从句：dev分支上推送各自的修改。\r\n\r\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\r\n```\r\n$ git clone git@github.com:michaelliao/learngit.git\r\nCloning into \'learngit\'...\r\nremote: Counting objects: 40, done.\r\nremote: Compressing objects: 100% (21/21), done.\r\nremote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0\r\nReceiving objects: 100% (40/40), done.\r\nResolving deltas: 100% (14/14), done.\r\n```\r\n当你的小伙伴从远程库的克隆时，默认情况下，的你小伙伴只能看到本地的master分支不信可以用。git branch命令看看：\r\n```\r\n$ git branch\r\n* master\r\n```\r\n现在，的你小伙伴要在dev分支上开发，必须就创建³³远程origin的dev分支到本地，他于是用这个命令创建³³本地dev分支：\r\n```\r\n$ git checkout -b dev origin/dev\r\n```\r\n现在，就他在可以dev上继续修改，然后，地时不时把dev分支push到远程：\r\n```\r\n$ git add env.txt\r\n\r\n$ git commit -m \"add env\"\r\n[dev 7a5e5dd] add env\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 env.txt\r\n\r\n$ git push origin dev\r\nCounting objects: 3, done.\r\nDelta compression using up to 4 threads.\r\nCompressing objects: 100% (2/2), done.\r\nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.\r\nTotal 3 (delta 0), reused 0 (delta 0)\r\nTo github.com:michaelliao/learngit.git\r\n   f52c633..7a5e5dd  dev -> dev\r\n```\r\n 的你小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\r\n```\r\n$ cat env.txt\r\nenv\r\n\r\n$ git add env.txt\r\n\r\n$ git commit -m \"add new env\"\r\n[dev 7bd91f1] add new env\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 env.txt\r\n\r\n$ git push origin dev\r\nTo github.com:michaelliao/learngit.git\r\n ! [rejected]        dev -> dev (non-fast-forward)\r\nerror: failed to push some refs to \'git@github.com:michaelliao/learngit.git\'\r\nhint: Updates were rejected because the tip of your current branch is behind\r\nhint: its remote counterpart. Integrate the remote changes (e.g.\r\nhint: \'git pull ...\') before pushing again.\r\nhint: See the \'Note about fast-forwards\' in \'git push --help\' for details.\r\n```\r\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，GIT中已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\r\n```\r\n$ git pull\r\nThere is no tracking information for the current branch.\r\nPlease specify which branch you want to merge with.\r\nSee git-pull(1) for details.\r\n\r\n    git pull <remote> <branch>\r\n\r\nIf you wish to set tracking information for this branch you can do so with:\r\n\r\n    git branch --set-upstream-to=origin/<branch> dev\r\n```\r\ngit pull也失败了，的英文原因没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev状语从句：origin/dev的链接：\r\n```\r\n$ git branch --set-upstream-to=origin/dev dev\r\nBranch \'dev\' set up to track remote branch \'dev\' from \'origin\'.\r\n```\r\n再拉：\r\n```\r\n$ git pull\r\nAuto-merging env.txt\r\nCONFLICT (add/add): Merge conflict in env.txt\r\nAutomatic merge failed; fix conflicts and then commit the result.\r\n```\r\n回这git pull成功，但是合并有冲突，需要手动解决，的解决方法状语从句：分支管理中的解决冲突完全一样解决后，提交，再推动。：\r\n```\r\n$ git commit -m \"fix env conflict\"\r\n[dev 57c53ab] fix env conflict\r\n\r\n$ git push origin dev\r\nCounting objects: 6, done.\r\nDelta compression using up to 4 threads.\r\nCompressing objects: 100% (4/4), done.\r\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\r\nTotal 6 (delta 0), reused 0 (delta 0)\r\nTo github.com:michaelliao/learngit.git\r\n   7a5e5dd..57c53ab  dev -> dev\r\n```\r\n\r\n因此，多人协作的工作模式通常是这样：\r\n\r\n首先，试图可以用git push origin <branch-name>推送自己的修改;\r\n\r\n如果推送失败，则因为远程分支比你的本地更新，先需要用git pull试图合并;\r\n\r\n如果合并有冲突，则解决冲突，并在本地提交;\r\n\r\n没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！\r\n\r\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令\r\n```\r\ngit branch --set-upstream-to <branch-name> origin/<branch-name>\r\n```\r\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\r\n\r\n## 小结\r\n查看远程库信息，使用\r\n```\r\ngit remote -v\r\n```\r\n\r\n本地新建的分支如果不推送到远程，对其他人就是不可见的;\r\n\r\n从本地推送分支，使用git push origin branch-name，如果推送失败，用先git pull抓取远程的新提交;\r\n\r\n在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致;\r\n\r\n建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name;\r\n\r\n从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。', '1', '1', '2019-01-19 06:19:46', '2019-01-19 06:24:03');
INSERT INTO `posts` VALUES ('67', '4', '0-4', '2', 'git-标签', 'Git有commit，为什么还要引入tag？\r\n\r\n“请把上周一的那个版本打包发布，commit号是6a5819e...”\r\n\r\n“一串乱七八糟的数字不好找！”\r\n\r\n如果换一个办法：\r\n\r\n“请把上周一的那个版本打包发布，版本号是v1.2”\r\n\r\n“好的，按照tag v1.2查找commit就行！”\r\n\r\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。', '# 创建标签\r\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\r\n```\r\n$ git branch\r\n* dev\r\n  master\r\n$ git checkout master\r\nSwitched to branch \'master\'\r\n```\r\n然后，敲命令git tag <name>就可以打一个新标签：\r\n```\r\n$ git tag v1.0\r\n```\r\n可以用命令git tag查看所有标签：\r\n```\r\n$ git tag\r\nv1.0\r\n```\r\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\r\n\r\n方法是找到历史提交的commit id，然后打上就可以了：\r\n```\r\n$ git log --pretty=oneline --abbrev-commit\r\n12a631b (HEAD -> master, tag: v1.0, origin/master) merged bug fix 101\r\n4c805e2 fix bug 101\r\ne1e9c68 merge with no-ff\r\nf52c633 add merge\r\ncf810e4 conflict fixed\r\n5dc6824 & simple\r\n14096d0 AND simple\r\nb17d20e branch test\r\nd46f35e remove test.txt\r\nb84166e add test.txt\r\n519219b git tracks changes\r\ne43a48b understand how stage works\r\n1094adb append GPL\r\ne475afc add distributed\r\neaadf4e wrote a readme file\r\n```\r\n比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\r\n```\r\n$ git tag v0.9 f52c633\r\n```\r\n再用命令git tag查看标签：\r\n```\r\n$ git tag\r\nv0.9\r\nv1.0\r\n```\r\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：\r\n```\r\n$ git show v0.9\r\ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\r\nAuthor: Michael Liao <askxuefeng@gmail.com>\r\nDate:   Fri May 18 21:56:54 2018 +0800\r\n\r\n    add merge\r\n\r\ndiff --git a/readme.txt b/readme.txt\r\n...\r\n```\r\n可以看到，v0.9确实打在add merge这次提交上。\r\n\r\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\r\n```\r\n$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb\r\n```\r\n用命令git show <tagname>可以看到说明文字：\r\n```\r\n$ git show v0.1\r\ntag v0.1\r\nTagger: Michael Liao <askxuefeng@gmail.com>\r\nDate:   Fri May 18 22:48:43 2018 +0800\r\n\r\nversion 0.1 released\r\n\r\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)\r\nAuthor: Michael Liao <askxuefeng@gmail.com>\r\nDate:   Fri May 18 21:06:15 2018 +0800\r\n\r\n    append GPL\r\n\r\ndiff --git a/readme.txt b/readme.txt\r\n...\r\n```\r\n注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\r\n## 小结\r\n命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；\r\n\r\n命令git tag -a <tagname> -m \"blablabla...\"可以指定标签信息；\r\n\r\n命令git tag可以查看所有标签。\r\n\r\n# 操作标签\r\n\r\n如果标签打错了，也可以删除：\r\n```\r\n$ git tag -d v0.1\r\nDeleted tag \'v0.1\' (was f15b0dd)\r\n```\r\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\r\n\r\n如果要推送某个标签到远程，使用命令git push origin <tagname>：\r\n```\r\n$ git push origin v1.0\r\nTotal 0 (delta 0), reused 0 (delta 0)\r\nTo github.com:michaelliao/learngit.git\r\n * [new tag]         v1.0 -> v1.0\r\n```\r\n或者，一次性推送全部尚未推送到远程的本地标签：\r\n```\r\n$ git push origin --tags\r\nTotal 0 (delta 0), reused 0 (delta 0)\r\nTo github.com:michaelliao/learngit.git\r\n * [new tag]         v0.9 -> v0.9\r\n```\r\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\r\n```\r\n$ git tag -d v0.9\r\nDeleted tag \'v0.9\' (was f52c633)\r\n```\r\n然后，从远程删除。删除命令也是push，但是格式如下：\r\n```\r\n$ git push origin :refs/tags/v0.9\r\nTo github.com:michaelliao/learngit.git\r\n - [deleted]         v0.9\r\n```\r\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\r\n\r\n## 小结\r\n命令git push origin <tagname>可以推送一个本地标签；\r\n\r\n命令git push origin --tags可以推送全部未推送过的本地标签；\r\n\r\n命令git tag -d <tagname>可以删除一个本地标签；\r\n\r\n命令git push origin :refs/tags/<tagname>可以删除一个远程标签。', '1', '1', '2019-01-19 06:26:04', '2019-01-19 06:40:03');
INSERT INTO `posts` VALUES ('68', '4', '0-4', '2', 'Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件', '它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 R', '>今天开始学习redis，加油ヾ(◍°∇°◍)ﾉﾞ\r\n\r\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 \r\n\r\n它支持多种类型的数据结构，如 \r\n\r\n字符串（strings）， \r\n\r\n散列（hashes）， \r\n\r\n列表（lists）， \r\n\r\n集合（sets）， \r\n\r\n有序集合（sorted sets） \r\n\r\n与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\r\n\r\n[查看Redis中文网 →](http://www.redis.cn)\r\n\r\n[查看Redis命令大全 →](http://www.redis.cn/commands.html)\r\n\r\n[访问Redis论坛 → ](http://bbs.redis.cn/)\r\n\r\n[Redis使用内存计算器 →](http://www.redis.cn/redis_memory/)', '1', '1', '2019-01-19 06:41:09', '2019-01-19 06:46:54');
INSERT INTO `posts` VALUES ('69', '3', '0-3', '2', 'PHP开发自己的框架必备知识点', 'phpms框架设计思路, 欢迎访问www.phpms.cn  ', '>phpms框架源码https://github.com/wuxiumu/ms\r\n\r\n## 一、PHP常用的四种数据结构\r\n\r\n简介：spl是php的一个标准库。\r\n\r\n官方文档：http://php.net/manual/zh/book.spl.php\r\n\r\n```\r\n<?php\r\n \r\n//spl（php标准库）数据结构\r\n \r\n/**\r\n * 栈（先进后出）\r\n */\r\nfunction zan(){\r\n    $stack = new SplStack();\r\n    $stack->push(\'data1\');//入栈（先进后出）\r\n    $stack->push(\'data2\');//入栈\r\n    $stack->push(\'data3\');//入栈\r\n     \r\n    echo $stack->pop().PHP_EOL;//出栈\r\n    echo $stack->pop().PHP_EOL;//出栈\r\n    echo $stack->pop().PHP_EOL;//出栈\r\n}\r\n \r\n /**\r\n *队列(先进先出）\r\n */\r\n\r\nfunction duilie(){\r\n    $queue = new SplQueue();\r\n    $queue->enqueue(\'data4\');//入队列\r\n    $queue->enqueue(\'data5\');//入队列\r\n    $queue->enqueue(\'data6\');//入队列\r\n    \r\n    echo $queue->dequeue().PHP_EOL;//出队列\r\n    echo $queue->dequeue().PHP_EOL;//出队列\r\n    echo $queue->dequeue().PHP_EOL;//出队列\r\n}\r\n \r\n/**\r\n * 堆\r\n */\r\nfunction dui(){\r\n    $heap = new SplMinHeap();\r\n    $heap->insert(\'data8\');//入堆\r\n    $heap->insert(\'data9\');//入堆\r\n    $heap->insert(\'data10\');//入堆\r\n    \r\n    echo $heap->extract().PHP_EOL;//从堆中提取数据\r\n    echo $heap->extract().PHP_EOL;//从堆中提取数据\r\n    echo $heap->extract().PHP_EOL;//从堆中提取数据\r\n}\r\n  \r\n/**\r\n * 固定数组（不论使不使用，都会分配相应的内存空间）\r\n */\r\n$array = new SplFixedArray(15);\r\n$array[\'0\'] = 54;\r\n$array[\'6\'] = 69;\r\n$array[\'10\'] = 32;\r\nvar_dump($array);\r\n\r\n```\r\n\r\n## 二、PHP链式操作的实现（原理）\r\n\r\n### 1、入口文件 \r\nindex.php\r\n```\r\nheader(\"content-type:text/html;charset=utf-8\"); \r\ndefine(\'PHPMSFRAME\',__DIR__);                   \r\ndefine(\'CORE\',PHPMSFRAME.\'/core\');\r\ndefine(\'APP\',PHPMSFRAME.\'/app\');\r\ndefine(\'MODULE\',\'app\');\r\n\r\ndefine(\'DEBUG\',true);\r\n \r\ninclude \"vendor/autoload.php\";\r\n\r\nif(DEBUG){\r\n	$whoops = new \\Whoops\\Run;\r\n	$whoops->pushHandler(new \\Whoops\\Handler\\PrettyPageHandler);\r\n	$whoops->register();\r\n	ini_set(\'display_error\', \'On\');\r\n}else{\r\n	ini_set(\'display_error\', \'Off\');\r\n}\r\n\r\ninclude CORE.\'/common/function.php\';\r\n\r\ninclude CORE.\'/phpmsframe.php\';\r\n\r\nspl_autoload_register(\'\\core\\phpmsframe::load\');\r\n\r\n\\core\\phpmsframe::run();\r\n```\r\n### 2、自动加载类 \r\ncore\\phpmsframe.php\r\n```\r\n<?php\r\n\r\nnamespace core;\r\n\r\nclass phpmsframe \r\n{\r\n	public static $classMap = array();\r\n\r\n	public $assign; \r\n \r\n	static public function run()\r\n	{		\r\n		$route = new \\core\\lib\\route();\r\n		$ctrlClass = $route->ctrl;\r\n		$action = $route->action;		\r\n		$ctrlfile = APP.\'/ctrl/\'.$ctrlClass.\'Ctrl.php\';\r\n		$ctrlClass = \'\\\\\'.MODULE.\'\\ctrl\\\\\'.$ctrlClass.\'Ctrl\';\r\n		if(is_file($ctrlfile)){			\r\n			include $ctrlfile;			\r\n			$ctrl = new $ctrlClass();\r\n			$ctrl->$action();					\r\n		}else{	\r\n			$msg = \"控制器 $ctrlClass 不存在\\n\";		 \r\n			self::reportingDog($msg);			\r\n		}\r\n	}\r\n\r\n	static public function load($class)\r\n	{\r\n		if(isset($classMap[$class])){\r\n			return true;\r\n		}else{\r\n			$class  = str_replace(\'\\\\\', \'/\', $class);\r\n			$file = PHPMSFRAME.\'/\'.$class.\'.php\';\r\n			if(is_file($file)){\r\n				include $file;\r\n				self::$classMap[$class] = $class; \r\n			}else{\r\n				return false;\r\n			}\r\n		}\r\n	}\r\n\r\n	public function assign($name,$value){\r\n		$this->assign[$name]=$value;\r\n	}\r\n\r\n	public function display($file){\r\n		$file_path = APP.\'/views/\'.$file;\r\n		if(is_file($file_path)){	\r\n			/***********twig模板***********/\r\n			$loader = new \\Twig_Loader_Filesystem(APP.\'/views\');\r\n			$twig = new \\Twig_Environment($loader, array(\r\n			    \'cache\' => PHPMSFRAME.\'/cache\',\r\n			    \'debug\'=>DEBUG,\r\n			));						\r\n			$template = $twig->load($file);			\r\n			$template->display($this->assign?$this->assign:\'\');\r\n			/***********twig模板end***********/\r\n\r\n			/***********原生模板***********/\r\n			//extract($this->assign);\r\n			//include $file_path;\r\n			/***********原生模板end***********/\r\n		}\r\n	}\r\n\r\n	static private function reportingDog($msg){\r\n		echo $msg.\"\\n\";		\r\n		include \'smile/havefun.php\';		\r\n		$num = str_pad(rand(00,32),2,\"0\",STR_PAD_LEFT);\r\n		$num = \"str_\".$num;		\r\n		$Parsedown = new \\Parsedown();\r\n		echo $Parsedown->text($$num);\r\n		$num = \"str_\".rand(50,84);\r\n		echo $Parsedown->text($$num); \r\n		exit;\r\n	}\r\n}\r\n\r\n```\r\n### 3、数据库类\r\n注：只是原理，并没有对方法进行具体的封装，具体的封装还是看个人喜好去定链式查询的风格。\r\n\r\ncore\\lib\\model.php\r\n```\r\n<?php\r\n\r\nnamespace core\\lib;\r\n\r\nuse  core\\lib\\drive\\database\\medooModel;\r\n\r\nclass model extends medooModel\r\n{	\r\n	\r\n}\r\n```\r\ncore\\lib\\drive\\database\\medooModel.php\r\n```\r\n<?php\r\n/**\r\n * 继承medoo第3方类库，模型基类\r\n */\r\nnamespace core\\lib\\drive\\database;\r\n\r\nuse core\\lib\\conf;\r\n\r\nuse Medoo\\Medoo;\r\n\r\nclass medooModel extends  Medoo{\r\n    //初始化，继承pdo应该是就可以直接用手册中的pdo中的方法了\r\n    public function __construct()\r\n    {\r\n		$option = conf::all(\'database\');		\r\n		parent::__construct($option[\'mysql_medoo_conf\']);\r\n    }\r\n}\r\n```\r\n## 三、PHP魔术方法的使用\r\n在php设计模式中，会涉及到很多魔术方法的使用，这里也对经常会用到的魔术方法进行简单总结。\r\n\r\n### 1、框架入口文件 \r\n\r\ncore\\phpmsframe.php\r\n```\r\n\r\n   /**\r\n    * 魔术方法的使用\r\n    */\r\n \r\n   /* 这是一个魔术方法，当一个对象或者类获取其不存在的属性的值时，\r\n    * 如：$obj = new BaseController ;\r\n    * $a = $obj -> a ;\r\n    * 该方法会被自动调用,这样做很友好，可以避免系统报错\r\n    */\r\n    public function __get($property_name){\r\n        $msg = \"属性 $property_name 不存在\\n\";\r\n        self::reportingDog($msg);	\r\n    }\r\n\r\n   /* 这是一个魔术方法，当一个对象或者类给其不存在的属性赋值时，\r\n    * 如：$obj = new BaseController ;\r\n    * $obj -> a = 12 ;\r\n    * 该方法(__set(属性名,属性值))会被自动调用,这样做很友好，可以避免系统报错\r\n    */\r\n    public function __set($property_name,$value){\r\n        $msg = \"属性 $property_name 不存在\\n\";\r\n		self::reportingDog($msg);	\r\n    }\r\n\r\n   /* 这是一个魔术方法，当一个对象或者类的不存在属性进行isset()时，\r\n    * 注意：isset 用于检查一个量是否被赋值 如果为NULL会返回false\r\n    * 如：$obj = new BaseController ;\r\n    * isset($obj -> a) ;\r\n    * 该方法会被自动调用,这样做很友好，可以避免系统报错\r\n    */\r\n    public function __isset($property_name){\r\n        $msg = \"属性 $property_name 不存在\\n\";\r\n        self::reportingDog($msg);	\r\n    }\r\n\r\n   /* 这是一个魔术方法，当一个对象或者类的不存在属性进行unset()时，\r\n    * 注意：unset 用于释放一个变量所分配的内存空间\r\n    * 如：$obj = new BaseController ;\r\n    * unset($obj -> a) ;\r\n    * 该方法会被自动调用,这样做很友好，可以避免系统报错\r\n    */\r\n    public function __unset($property_name){\r\n        $msg = \"属性 $property_name 不存在\\n\";\r\n        self::reportingDog($msg);	\r\n    }\r\n\r\n    /* 当对这个类的对象的不存在的实例方法进行“调用”时，会自动调用该方法，\r\n     * 这个方法有2个参数（必须带有的）：\r\n     * $methodName 表示要调用的不存在的方法名;\r\n     * $argument 是一个数组，表示要调用该不存在的方法时，所使用的实参数据，\r\n     */\r\n    public function __call($methodName,$argument){\r\n		$msg = \"实例方法 $methodName 不存在\\n\";\r\n        self::reportingDog($msg);	\r\n    }\r\n```\r\n## 四、三种基础设计模式\r\n### 1、工厂模式\r\n\r\n通过传入参数的不同，来实例化不同的类。\r\n```\r\n$cache =\\Core\\extend\\CacheFactory::getCacheObj(\'redis\',array(\r\n			\'host\' => \'127.0.0.1\',\r\n			\'pass\' => \'myRedis&&&\'\r\n		));\r\nvar_dump($cache);\r\n```\r\ncore\\extend\\CacheFactory.php\r\n```\r\n<?php\r\n\r\nnamespace core\\extend;\r\n\r\nclass CacheFactory\r\n{\r\n    const FILE = 1;\r\n    const MEMCACHE = 2;\r\n    const REDIS = 3;\r\n \r\n    static $instance;//定义静态属性，用于存储对象\r\n \r\n    /**\r\n     * 工厂类创建缓存对象\r\n     * @param $type 指定缓存类型\r\n     * @param array $options 传入缓存参数\r\n     * @return FileCache|Memcache|RedisCache\r\n     */\r\n    static function getCacheObj($type, array $options)\r\n    {\r\n        switch ($type) {\r\n            case \'file\':\r\n            case self::FILE:\r\n                self::$instance = new FileCache($options);\r\n                break;\r\n \r\n            case \'memcache\':\r\n            case self::MEMCACHE:\r\n                self::$instance = new Memcache($options);\r\n                break;\r\n \r\n            case \'redis\':\r\n            case self::REDIS:\r\n                self::$instance = new RedisCache($options);\r\n                break;\r\n \r\n            default:\r\n                self::$instance = new FileCache($options);\r\n                break;\r\n \r\n        }\r\n        return self::$instance;\r\n    }\r\n}\r\n```\r\n## 2、单例模式\r\n\r\n保证一个类只实例化一个类对象，进而减少系统开销和资源的浪费\r\n```\r\n//单例模式创建对象\r\n$obj = Extend\\SingleObject::getInstance();\r\n$obj2 = Extend\\SingleObject::getInstance();\r\nvar_dump($obj,$obj2);//从结果可以看出，两个实例化的对象其实是一个对象\r\n```\r\ncore\\extend\\SingleObject.php\r\n```\r\n<?php\r\n\r\nnamespace core\\extend;\r\n\r\nclass SingleObject\r\n{\r\n    //私有的静态属性，用于存储类对象\r\n    private static $instance = null;\r\n    \r\n    //私有的构造方法,保证不允许在类外 new\r\n    private function __construct(){\r\n\r\n    }\r\n\r\n    //私有的克隆方法, 确保不允许通过在类外 clone 来创建新对象\r\n    private function __clone(){\r\n        \r\n    }\r\n\r\n    //公有的静态方法，用来实例化唯一当前类对象\r\n    public static function getInstance()\r\n    {\r\n        if(is_null(self::$instance)){\r\n            self::$instance = new self;\r\n        }\r\n        return self::$instance;\r\n    }\r\n}\r\n```\r\n### 3、注册树模式\r\n\r\n将我们用到的对象注册到注册树上，然后在之后要用到这个对象的时候，直接从注册树上取下来就好。（就和我们用全局变量一样方便）\r\n\r\ncore\\extend\\RegisterTree,php\r\n```\r\n<?php\r\n\r\nnamespace core\\extend;\r\n\r\nclass RegisterTree\r\n{\r\n    static protected $objects;//静态类属性，用于储存注册到注册树上的对象\r\n \r\n    /**\r\n     * 将对象注册到注册树上\r\n     * @param $alias 对象的别名\r\n     * @param $object 对象\r\n     */\r\n    static function setObject($alias,$object)\r\n    {\r\n        self::$objects[$alias] = $object;\r\n    }\r\n \r\n    /**\r\n     * 从注册树上取出给定别名相应的对象\r\n     * @param $alias 将对象插入到注册树上时写的别名\r\n     * @return mixed 对象\r\n     */\r\n    static protected function getObject($alias)\r\n    {\r\n        return self::$objects[$alias];\r\n    }\r\n \r\n    /**\r\n     * 将对象从注册树上删除\r\n     * @param $alias 将对象插入到注册树上时写的别名\r\n     */\r\n    public function unsetObject($alias)\r\n    {\r\n        unset(self::$objects[$alias]);\r\n    }\r\n}\r\n```\r\n关于注册树模式，这里推荐一篇文章 ，可以方便理解。 https://segmentfault.com/a/1190000007495855\r\n\r\n## 五、其他常见的8种PHP设计模式\r\n### 1、适配器模式\r\n\r\n将一个类的接口转换成客户希望的另一个接口,适配器模式使得原本的由于接口不兼容而不能一起工作的那些类可以一起工作。\r\n应用场景：老代码接口不适应新的接口需求，或者代码很多很乱不便于继续修改，或者使用第三方类库。\r\n\r\n常见的有两种适配器，分别是类适配器和对象适配器，这里拿更看好的对象适配器举例： \r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\n/**\r\n * 对象适配器模式具体流程\r\n * 1、根据需求定义接口，进而满足新需求功能\r\n * 2、定义新类，继承并实现定义的接口\r\n * 3、在实现接口时，原有的功能，只通过原有类对象调用原有类功能（委托）\r\n * 4、再根据需求，在新类中实现新需求功能\r\n * 【适用性】\r\n * （1）你想使用一个已经存在的类，而它的接口不符合你的需求\r\n * （2）你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作\r\n * （3）你想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口（仅限于对\r\n */\r\n \r\n \r\n/**\r\n * 目标角色（根据需求定义含有旧功能加上新功能的接口）\r\n * Interface Target 我们期望得到的功能类\r\n * @package Extend\r\n */\r\ninterface Target\r\n{\r\n    public function simpleMethod1();\r\n    public function simpleMethod2();\r\n}\r\n \r\n/**\r\n * 源角色（在新功能提出之前的旧功能类和方法）\r\n * Class Adaptee\r\n * @package Extend\r\n */\r\nclass Adaptee\r\n{\r\n \r\n    public function simpleMethod1()\r\n    {\r\n        echo \'Adapter simpleMethod1\'.\"<br>\";\r\n    }\r\n \r\n}\r\n \r\n/**\r\n * 类适配器角色（新定义接口的具体实现）\r\n * Class Adapter\r\n * @package Extend\r\n */\r\nclass Adapter implements Target\r\n{\r\n \r\n    private $adaptee;\r\n \r\n    function __construct()\r\n    {\r\n        //适配器初始化直接new 原功能类，以方便之后委派\r\n        $adaptee = new Adaptee();\r\n        $this->adaptee = $adaptee;\r\n    }\r\n \r\n    //委派调用Adaptee的sampleMethod1方法\r\n    public function simpleMethod1()\r\n    {\r\n        echo $this->adaptee->simpleMethod1();\r\n    }\r\n \r\n    public function simpleMethod2()\r\n    {\r\n        echo \'Adapter simpleMethod2\'.\"<br>\";\r\n    }\r\n \r\n}\r\n \r\n/**\r\n * 客户端调用\r\n */\r\n$adapter = new Adapter();\r\n$adapter->simpleMethod1();\r\n$adapter->simpleMethod2();\r\n\r\n``` \r\n这篇文章介绍了类适配器的使用，感兴趣的可以了解一下 https://segmentfault.com/a/1190000007508128\r\n\r\n### 2、策略模式\r\n\r\n将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，这种模式就是策略模式，策略模式可以实现依赖倒置以及控制反转。\r\n\r\n实例举例：假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有的广告位展示展示不同的广告。\r\n```\r\n<?php\r\n \r\n/**\r\n * 首页数据控制器\r\n * Class Index\r\n */\r\nclass Home\r\n{\r\n    /**\r\n     * 最好写上这个注释，告诉phpstorm是对应的哪个接口类，否则虽然程序执行正确，但phpstorm识别不了\r\n     * @var \\Extend\\UserType\r\n     */\r\n    protected $userType;\r\n \r\n    /**\r\n     * 首页展示数据\r\n     * 使用策略模式\r\n     * Index constructor.\r\n     */\r\n    function index()\r\n    {\r\n        echo \"AD：\";\r\n        $this->userType->showAd();\r\n        echo \"Category：\";\r\n        $this->userType->showCategory();\r\n    }\r\n \r\n    /**\r\n     * 策略模式\r\n     * 根据传递的用户性别展示不同类别数据\r\n     * @param \\Extend\\UserType $userType\r\n     */\r\n    function setUserType(\\Extend\\UserType $userType)\r\n    {\r\n        $this->userType = $userType;\r\n    }\r\n \r\n}\r\n \r\n$obj = new Home();\r\nif ($_GET[\'userType\'] == \'female\'){\r\n    $userType = new \\Extend\\FemaleUserType();\r\n} else {\r\n    $userType = new \\Extend\\MaleUserType();\r\n}\r\n$obj->setUserType($userType);\r\n$obj->index();\r\n\r\n```\r\nExtend/userType.php（定义的接口）\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\n/**\r\n * 策略模式\r\n * 定义根据性别不同展示不同商品类目和广告接口\r\n * Interface UserType\r\n * @package Extend\r\n */\r\ninterface UserType\r\n{\r\n    //显示广告\r\n    function showAd();\r\n    //展示类目\r\n    function showCategory();\r\n \r\n}\r\n\r\n```\r\nMaleUserType.php、FemaleUserType.php（具体实现的类 ）\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\n/**\r\n * 定义男性商品类目和广告位数据接口\r\n * Class MaleUserType\r\n * @package Extend\r\n */\r\nclass MaleUserType implements UserType\r\n{\r\n    /**\r\n     * 广告栏数据展示\r\n     */\r\n    function showAd()\r\n    {\r\n        echo \"this is 男性’s 广告条目数据\";\r\n    }\r\n \r\n    /**\r\n     * 商品类目数据展示\r\n     */\r\n    function showCategory()\r\n    {\r\n        echo \"this is 男性’s 商品类目数据\";\r\n    }\r\n \r\n}\r\n\r\n```\r\n\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\n/**\r\n * 定义女性商品类目和广告位数据接口\r\n * Class FemaleUserType\r\n * @package Extend\r\n */\r\nclass FemaleUserType implements UserType\r\n{\r\n \r\n    /**\r\n     * 广告栏数据展示\r\n     */\r\n    function showAd()\r\n    {\r\n        echo \"this is 女性’s 广告条目数据\";\r\n    }\r\n \r\n    /**\r\n     * 商品类目数据展示\r\n     */\r\n    function showCategory()\r\n    {\r\n        echo \"this is 女性’s 商品类目数据\";\r\n    }\r\n \r\n \r\n}\r\n\r\n```\r\n\r\n### 3、数据对象映射模式\r\n\r\n将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作。\r\n\r\n下面在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的sql语句映射成对象属性的操作。并结合使用数据对象映射模式、工厂模式、注册模式。\r\n\r\n \r\n\r\n（1）数据库映射模式简单实例实现\r\n```\r\n<?php\r\n \r\n//使用数据对象映射模式代替写sql\r\n$user = new Extend\\User(25);\r\n$user->name = \'小卜丢饭团子\';\r\n$user->salary = \'20000\';\r\n$user->city = \'浙江省\';\r\n \r\n```\r\nExtend/User.php\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\nclass User\r\n{\r\n    //对应数据库中的4个字段\r\n    public $id;\r\n    public $name;\r\n    public $salary;\r\n    public $city;\r\n    //存储数据库连接对象属性\r\n    protected $pdo;\r\n \r\n    public $data;\r\n \r\n    function __construct($id)\r\n    {\r\n        $this->id = $id;\r\n        $this->pdo = new \\PDO(\'mysql:host=127.0.0.1;dbname=test\',\'root\',\'123456\');\r\n    }\r\n \r\n    function __destruct()\r\n    {\r\n        $this->pdo->query(\"update user set name = \'{$this->name}\',salary = \'{$this->salary}\',city = \'{$this->city}\' where id=\'{$this->id}\'\");\r\n    }\r\n}\r\n\r\n```\r\n这样，执行index.php文件，数据库就会发生相应的操作，也就实现了基本的数据对象映射。\r\n\r\n \r\n\r\n（2）数据库映射模式复杂案例实现\r\n```\r\n<?php\r\n \r\nclass EX\r\n{\r\n    function index()\r\n    {\r\n        //使用数据对象映射模式代替写sql\r\n        $user = Extend\\Factory::getUserObj(25);\r\n        $user->name = \'小卜丢饭团子\';\r\n        $user->salary = \'20000\';\r\n        $user->city = \'浙江省\';\r\n    }\r\n \r\n    function test()\r\n    {\r\n        $user = Extend\\Factory::getUserObj(25);\r\n        $user->city = \'广东省\';\r\n    }\r\n \r\n}\r\n \r\n$ex = new EX();\r\n$ex->index();\r\n\r\n```\r\nExtend/Factory.php\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\nclass Factory\r\n{\r\n    /**\r\n     * 工厂模式创建数据库对象，单例模式保证创建唯一db对象\r\n     * @return mixed\r\n     */\r\n    static function CreateDatabaseObj()\r\n    {\r\n        $db = Database::getInstance();\r\n        return $db;\r\n    }\r\n \r\n    /**\r\n     * 工厂模式创建user对象，注册树模式保证创建唯一对象，避免资源浪费\r\n     * @param $id\r\n     * @return User|mixed\r\n     */\r\n    static function getUserObj($id)\r\n    {\r\n        $key = \'user\'.$id;\r\n        $user = RegisterTree::getObject($key);\r\n        if (!$user) {\r\n            $user = new User($id);\r\n            RegisterTree::setObject($key,$user);\r\n        }\r\n        return $user;\r\n    }\r\n}\r\n\r\n```\r\nExtend/Register.php\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\n/**\r\n * 注册树模式\r\n * Class RegisterTree\r\n * @package Extend\r\n */\r\nclass RegisterTree\r\n{\r\n    static protected $objects;//静态类属性，用于储存注册到注册树上的对象\r\n \r\n    /**\r\n     * 将对象注册到注册树上\r\n     * @param $alias 对象的别名\r\n     * @param $object 对象\r\n     */\r\n    static function setObject($alias,$object)\r\n    {\r\n        self::$objects[$alias] = $object;\r\n    }\r\n \r\n \r\n    /**\r\n     * 从注册树上取出给定别名相应的对象\r\n     * @param $alias 将对象插入到注册树上时写的别名\r\n     * @return mixed 对象\r\n     */\r\n    static function getObject($alias)\r\n    {\r\n        return self::$objects[$alias];\r\n    }\r\n \r\n    /**\r\n     * 将对象从注册树上删除\r\n     * @param $alias 将对象插入到注册树上时写的别名\r\n     */\r\n    public function unsetObject($alias)\r\n    {\r\n        unset(self::$objects[$alias]);\r\n    }\r\n \r\n}\r\n\r\n```\r\n\r\nExtend/User.php\r\n```\r\n<?php\r\n \r\nnamespace Extend;\r\n \r\nclass User\r\n{\r\n    //对应数据库中的4个字段\r\n    public $id;\r\n    public $name;\r\n    public $salary;\r\n    public $city;\r\n    //存储数据库连接对象属性\r\n    protected $pdo;\r\n \r\n    public $data;\r\n \r\n    function __construct($id)\r\n    {\r\n        $this->id = $id;\r\n        $this->pdo = new \\PDO(\'mysql:host=127.0.0.1;dbname=test\',\'root\',\'123456\');\r\n    }\r\n \r\n    function __destruct()\r\n    {\r\n        $this->pdo->query(\"update user set name = \'{$this->name}\',salary = \'{$this->salary}\',city = \'{$this->city}\' where id=\'{$this->id}\'\");\r\n    }\r\n}\r\n\r\n```\r\n这样，就实现了稍复杂的数据对象映射模式和工厂模式、注册树模式相结合的案例。\r\n\r\n \r\n## 4、观察者模式\r\n\r\n当一个对象状态发生改变时，依赖它的对象会全部收到通知，并自动更新。\r\n\r\n场景：一个事件发生后，要执行一连串更新操作。传统的编程方式就是在事件的代码之后直接加入处理逻辑，当更新的逻辑增多之后，代码会变的难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码。观察者模式实现了低耦合，非侵入式的通知与更新机制。\r\n\r\n \r\n\r\n### 4.1、传统模式举例：\r\n```\r\n<?php\r\n/**\r\n * 一个事件的逻辑控制器\r\n * Class Event\r\n */\r\nclass Event\r\n{\r\n    /**\r\n     * 用户确认订单\r\n     */\r\n    function firmOrder()\r\n    {\r\n        //这里假设一个事件发生了，比如用户已经完成下单\r\n        echo \"用户已下单<br>\";\r\n        //传统方式是在发生一个事件之后直接进行一系列的相关处理，耦合度比较高，比如写入日志，给用户发邮件等等\r\n        echo \"在用户下单之后进行的一系列操作<br>\";\r\n    }\r\n \r\n}\r\n \r\n$event = new Event();\r\n$event->firmOrder();\r\n\r\n```\r\n### 4.2、观察者模式典型实现方式：\r\n\r\n（1）定义2个接口：观察者（通知）接口、被观察者（主题）接口\r\n\r\n（2）定义2个类，观察者类实现观察者接口、被观察者类实现被观察者接口\r\n\r\n（3）被观察者注册自己需要通知的观察者\r\n\r\n（4）被观察者类某个业务逻辑发生时，通知观察者对象，进而每个观察者执行自己的业务逻辑。\r\n\r\n\r\n代码示例：\r\n```\r\n<?php\r\n/**\r\n * 观察者模式场景描述：\r\n * 1、购票后记录文本日志\r\n * 2、购票后记录数据库日志\r\n * 3、购票后发送短信\r\n * 4、购票送抵扣卷、兑换卷、积分\r\n * 5、其他各类活动等\r\n */\r\n \r\n \r\n/**\r\n * 观察者接口\r\n */\r\ninterface TicketObserver\r\n{\r\n    function buyTicketOver($sender, $args); //得到通知后调用的方法\r\n}\r\n \r\n/**\r\n * 被观察者接口（购票主题接口）\r\n */\r\ninterface TicketObserved\r\n{\r\n    function addObserver($observer); //提供注册观察者方法\r\n}\r\n \r\n \r\n/**\r\n * 主体逻辑，继承被观察者接口\r\n * Class BuyTicket\r\n */\r\nclass BuyTicket implements TicketObserved\r\n{\r\n \r\n    /**\r\n     * 定义观察者数组属性，用于储存观察者\r\n     * @var array\r\n     */\r\n    private $observers = array();\r\n \r\n \r\n    /**\r\n     * 实现被观察者接口定义的方法（添加观察者）\r\n     * @param $observer 实例化后的观察者对象\r\n     */\r\n    public function addObserver($observer)\r\n    {\r\n        $this->observers[] = $observer;\r\n    }\r\n \r\n \r\n    /**\r\n     * 购票主体方法\r\n     * BuyTicket constructor.\r\n     * @param $ticket 购票排号\r\n     */\r\n    public function buyTicket($ticket)\r\n    {\r\n        //1、根据需求写购票逻辑\r\n        //..............\r\n \r\n        //2、购票成功之后，循环通知观察者，并调用其buyTicketOver实现不同业务逻辑\r\n        foreach ($this->observers as $observe) {\r\n            $observe->buyTicketOver($this, $ticket); //$this 可用来获取主题类句柄，在通知中使用\r\n        }\r\n \r\n    }\r\n \r\n}\r\n \r\n \r\n \r\n/**\r\n * 购票成功后，发送短信通知\r\n * Class buyTicketMSN\r\n */\r\nclass buyTicketMSN implements TicketObserver\r\n{\r\n    public function buyTicketOver($sender, $ticket)\r\n    {\r\n        echo (date ( \'Y-m-d H:i:s\' ) . \" 短信日志记录：购票成功:$ticket<br>\");\r\n    }\r\n}\r\n \r\n/**\r\n * 购票成功后，记录日志\r\n * Class buyTicketLog\r\n */\r\nclass buyTicketLog implements TicketObserver\r\n{\r\n    public function buyTicketOver($sender, $ticket) \r\n    {\r\n        echo (date ( \'Y-m-d H:i:s\' ) . \" 文本日志记录：购票成功:$ticket<br>\");\r\n    }\r\n}\r\n \r\n \r\n/**\r\n * 购票成功后，赠送优惠券\r\n * Class buyTicketCoupon\r\n */\r\nclass buyTicketCoupon implements TicketObserver\r\n{\r\n    public function buyTicketOver($sender, $ticket) \r\n    {\r\n        echo (date ( \'Y-m-d H:i:s\' ) . \" 赠送优惠券：购票成功:$ticket 赠送10元优惠券1张。<br>\");\r\n    }\r\n}\r\n \r\n \r\n//实例化购票类\r\n$buy = new BuyTicket();\r\n//添加多个观察者\r\n$buy->addObserver(new buyTicketMSN());\r\n$buy->addObserver(new buyTicketLog());\r\n$buy->addObserver(new buyTicketCoupon());\r\n//开始购票\r\n$buy->buyTicket (\"7排8号\");\r\n\r\n```\r\n\r\n### 5、原型模式\r\n\r\n原型模式与工厂模式的作用类似，都是用来创建对象的。但是实现方式是不同的。原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样，就免去了类创建时重复的初始化操作。\r\n\r\n原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可。\r\n\r\n代码实例：\r\n```\r\n<?php\r\n/**\r\n * 抽象原型角色\r\n */\r\ninterface Prototype\r\n{\r\n    public function copy();\r\n}\r\n \r\n/**\r\n * 具体原型角色\r\n */\r\nclass ConcretePrototype implements Prototype\r\n{\r\n \r\n    private $_name;\r\n \r\n    public function __construct($name)\r\n    {\r\n        $this->_name = $name;\r\n    }\r\n \r\n    public function setName($name)\r\n    {\r\n        $this->_name = $name;\r\n    }\r\n \r\n    public function getName()\r\n    {\r\n        return $this->_name;\r\n    }\r\n \r\n    public function copy()\r\n    {\r\n        //深拷贝实现\r\n         //$serialize_obj = serialize($this); // 序列化\r\n         //$clone_obj = unserialize($serialize_obj); // 反序列化\r\n         //return $clone_obj;\r\n \r\n        // 浅拷贝实现\r\n        return clone $this;\r\n    }\r\n \r\n}\r\n \r\n/**\r\n * 测试深拷贝用的引用类\r\n */\r\nclass Demo\r\n{\r\n    public $array;\r\n}\r\n \r\n \r\n//测试\r\n$demo = new Demo();\r\n$demo->array = array(1, 2);\r\n$object1 = new ConcretePrototype($demo);\r\n$object2 = $object1->copy();\r\n \r\nvar_dump($object1->getName());\r\necho \'<br />\';\r\nvar_dump($object2->getName());\r\necho \'<br />\';\r\n \r\n$demo->array = array(3, 4);\r\nvar_dump($object1->getName());\r\necho \'<br />\';\r\nvar_dump($object2->getName());\r\necho \'<br />\';\r\n\r\n```\r\n关于原型模式文章：https://www.imooc.com/article/16973\r\n\r\n\r\n### 6、装饰器模式\r\n\r\n可以动态的添加或修改类的功能\r\n\r\n一个类实现一个功能，如果要再修改或添加额外的功能，传统的编程模式需要写一个子类继承它，并重新实现类的方法。\r\n\r\n使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性。\r\n```\r\n<?php\r\n/**\r\n * 装饰器流程\r\n * 1、声明装饰器接口（装饰器接口）\r\n * 2、具体类继承并实现装饰器接口（颜色装饰器实现，字体大小装饰器实现）\r\n * 3、在被装饰者类中定义\"添加装饰器\"方法（EchoText类中的addDecorator方法）\r\n * 4、在被装饰者类中定义调用装饰器的方法（EchoText类中的beforeEcho和afterEcho方法）\r\n * 5、使用时，实例化被装饰者类，并传入装饰器对象（比如new ColorDecorator(\'yellow\'))\r\n */\r\n \r\n/**\r\n * 装饰器接口\r\n * Class Decorator\r\n */\r\ninterface Decorator\r\n{\r\n    public function beforeEcho();\r\n    public function afterEcho();\r\n}\r\n \r\n/**\r\n * 颜色装饰器实现\r\n * Class ColorDecorator\r\n */\r\nclass ColorDecorator implements Decorator\r\n{\r\n    protected $color;\r\n \r\n    public function __construct($color)\r\n    {\r\n        $this->color = $color;\r\n    }\r\n \r\n    public function beforeEcho()\r\n    {\r\n        echo \"<dis style=\'color: {$this->color}\'>\";\r\n    }\r\n \r\n    public function afterEcho()\r\n    {\r\n        echo \"</div>\";\r\n    }\r\n}\r\n \r\n/**\r\n * 字体大小装饰器实现\r\n * Class SizeDecorator\r\n */\r\nclass SizeDecorator implements Decorator\r\n{\r\n    protected $size;\r\n \r\n    public function __construct($size)\r\n    {\r\n        $this->size = $size;\r\n    }\r\n \r\n    public function beforeEcho()\r\n    {\r\n        echo \"<dis style=\'font-size: {$this->size}px\'>\";\r\n    }\r\n \r\n    public function afterEcho()\r\n    {\r\n        echo \"</div>\";\r\n    }\r\n}\r\n \r\n/**\r\n * 被装饰者\r\n * 输出一个字符串\r\n * 装饰器动态添加功能\r\n * Class EchoText\r\n */\r\nclass EchoText\r\n{\r\n    protected $decorators = array();//存放装饰器\r\n \r\n    //装饰方法\r\n    public function Index()\r\n    {\r\n        //调用装饰器前置操作\r\n        $this->beforeEcho();\r\n        echo \"你好，我是装饰器。\";\r\n        //调用装饰器后置操作\r\n        $this->afterEcho();\r\n    }\r\n \r\n    //添加装饰器\r\n    public function addDecorator(Decorator $decorator)\r\n    {\r\n        $this->decorators[] = $decorator;\r\n    }\r\n \r\n    //执行装饰器前置操作 先进先出原则\r\n    protected function beforeEcho()\r\n    {\r\n        foreach ($this->decorators as $decorator)\r\n            $decorator->beforeEcho();\r\n    }\r\n \r\n    //执行装饰器后置操作 先进后出原则\r\n    protected function afterEcho()\r\n    {\r\n        $tmp = array_reverse($this->decorators);\r\n        foreach ($tmp as $decorator)\r\n            $decorator->afterEcho();\r\n    }\r\n}\r\n \r\n//实例化输出类\r\n$echo = new EchoText();\r\n//增加装饰器\r\n$echo->addDecorator(new ColorDecorator(\'yellow\'));\r\n//增加装饰器\r\n$echo->addDecorator(new SizeDecorator(\'22\'));\r\n//输出\r\n$echo->Index();\r\n\r\n```\r\n\r\n### 7、迭代器模式\r\n\r\n在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素而又不暴露该对象的内部表示，这就是PHP迭代器模式的定义。\r\n\r\n相对于传统编程模式，迭代器模式可以隐藏遍历元素的所需的操作。\r\n```\r\n<?php\r\n\r\n$users = new Extend\\AllUser();\r\n//循环遍历出所有用户数据\r\nforeach ($users as $user) {\r\n    var_dump($user);\r\n}\r\n\r\n```\r\nExtend/AllUser.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\n/**\r\n * 迭代器模式，继承php内部自带的迭代器接口（\\Iterator）\r\n * Class AllUser\r\n * @package Extend\r\n */\r\nclass AllUser implements \\Iterator\r\n{\r\n    protected $index = 0;//表示索引\r\n    protected $ids = array();//用于储存所有user的id（实际应用中，可以采用注册树模式进行存储）\r\n    protected $pdo;//用于存储数据库对象\r\n \r\n    function __construct()\r\n    {\r\n        //获取pdo数据库对象\r\n        $this->pdo = new \\PDO(\'mysql:host=127.0.0.1;dbname=test\',\'root\',\'123456\');\r\n        //获取所有用户的id\r\n        $this->ids = $this->pdo->query(\"select id from user\")->fetchAll(2);\r\n    }\r\n \r\n    /**\r\n     * 实现接口方法，重置迭代器，回到集合开头\r\n     */\r\n    public function rewind()\r\n    {\r\n        $this->index = 0;\r\n    }\r\n \r\n    /**\r\n     * 实现接口方法，获取当前元素\r\n     * @return mixed|void\r\n     */\r\n    public function current()\r\n    {\r\n        $id = $this->ids[$this->index][\'id\'];\r\n        //获取当前用户的数据\r\n        $user_data = $this->pdo->query(\"select * from user where id=\'{$id}\'\")->fetch(2);\r\n        return $user_data;\r\n    }\r\n \r\n    /**\r\n     * 实现接口方法，获取当前元素键值\r\n     * @return mixed|void\r\n     */\r\n    public function key()\r\n    {\r\n        return $this->index;\r\n    }\r\n \r\n    /**\r\n     * 实现接口方法，获取下一个元素\r\n     */\r\n    public function next()\r\n    {\r\n        $this->index++;\r\n    }\r\n \r\n    /**\r\n     * 实现接口方法，验证是否还有下一个元素\r\n     * @return bool|void\r\n     */\r\n    public function valid()\r\n    {\r\n        return $this->index < count($this->ids);\r\n    }\r\n \r\n}\r\n\r\n```\r\n\r\n关于php迭代器文章 http://www.php.cn/php-weizijiaocheng-365294.html\r\n\r\n \r\n\r\n### 8、代理模式\r\n\r\n在客户端与实体之间建立一个代理对象（proxy），客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。\r\n\r\n典型的应用就是mysql的主从结构，读写分离。在mysql中，对所有读的操作请求从库，所有写的操作请求主库。\r\n\r\n声明一个代理类，前台使用时只需创建一个代理类，调用对应方法即可。代码实例：\r\n```\r\n<?php\r\n \r\n// 1、传统编程模式是手动选择\r\n#查询操作使用从库\r\n//$db_slave = Extend\\Factory::getDatabase(\'slave\');\r\n//$info = $db_slave->query(\"select * from user where id = 1 limit 1\");\r\n#增删改操作使用主库\r\n//$db_master = Extend\\Factory::getDatabase(\'master\');\r\n//$db_master->query(\"update user name = \'xiaobudiu\' where id = 29 limit 1\");\r\n \r\n \r\n// 2、使用代理模式\r\n$db_proxy = new Extend\\Proxy();\r\n$db_proxy->getUserName(1);\r\n$db_proxy->setUserName(29,\'xiaobudiu\');\r\n\r\n```\r\nExtend/Proxy.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\nclass Proxy implements IUserProxy\r\n{\r\n    function getUserName($id)\r\n    {\r\n        $db = Factory::getDatabase(\'slave\');\r\n        $db->query(\"select name from user where id =$id limit 1\");\r\n    }\r\n \r\n    function setUserName($id, $name)\r\n    {\r\n        $db = Factory::getDatabase(\'master\');\r\n        $db->query(\"update user set name = $name where id =$id limit 1\");\r\n    }\r\n}\r\n\r\n```\r\nExtend/Factory.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\nclass Factory\r\n{\r\n    static function getDatabase($id)\r\n    {\r\n        $key = \'database_\'.$id;\r\n        if ($id == \'slave\')\r\n        {\r\n            $slaves = Application::getInstance()->config[\'database\'][\'slave\'];\r\n            $db_conf = $slaves[array_rand($slaves)];\r\n        } else {\r\n            $db_conf = Application::getInstance()->config[\'database\'][$id];\r\n        }\r\n        //注册树模式存储及获取对象\r\n        $db = Register::get($key);\r\n        if (!$db) {\r\n            $db = new Database\\MySQLi();\r\n            $db->connect($db_conf[\'host\'], $db_conf[\'user\'], $db_conf[\'password\'], $db_conf[\'dbname\']);\r\n            Register::set($key, $db);\r\n        }\r\n        return $db;\r\n    }\r\n \r\n}\r\n\r\n```\r\nExtend/Application.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\nclass Application\r\n{\r\n    public $base_dir;\r\n    protected static $instance;\r\n \r\n    public $config;\r\n \r\n    protected function __construct($base_dir)\r\n    {\r\n        $this->base_dir = $base_dir;\r\n        $this->config = new Config($base_dir.\'/configs\');\r\n    }\r\n \r\n    static function getInstance($base_dir = \'\')\r\n    {\r\n        if (empty(self::$instance))\r\n        {\r\n            self::$instance = new self($base_dir);\r\n        }\r\n        return self::$instance;\r\n    }\r\n    \r\n}\r\n\r\n```\r\n\r\nExtend/Config.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\n/**\r\n * 配置类，继承于php自带的ArrayAccess接口\r\n * 允许一个对象以数组的方式访问\r\n * Class Config\r\n * @package Extend\r\n */\r\nclass Config implements \\ArrayAccess\r\n{\r\n    protected $path;\r\n    protected $configs = array();\r\n \r\n    function __construct($path)\r\n    {\r\n        $this->path = $path;\r\n    }\r\n \r\n    function offsetGet($key)\r\n    {\r\n        if (empty($this->configs[$key]))\r\n        {\r\n            $file_path = $this->path.\'/\'.$key.\'.php\';\r\n            $config = require $file_path;\r\n            $this->configs[$key] = $config;\r\n        }\r\n        return $this->configs[$key];\r\n    }\r\n \r\n    function offsetSet($key, $value)\r\n    {\r\n        throw new \\Exception(\"cannot write config file.\");\r\n    }\r\n \r\n    function offsetExists($key)\r\n    {\r\n        return isset($this->configs[$key]);\r\n    }\r\n \r\n    function offsetUnset($key)\r\n    {\r\n        unset($this->configs[$key]);\r\n    }\r\n}\r\n\r\n```\r\nconfigs/database.php\r\n```\r\n<?php\r\n$config = array(\r\n    \'master\' => array(\r\n        \'type\' => \'MySQL\',\r\n        \'host\' => \'127.0.0.1\',\r\n        \'user\' => \'root\',\r\n        \'password\' => \'123456\',\r\n        \'dbname\' => \'test\',\r\n    ),\r\n    \'slave\' => array(\r\n        \'slave1\' => array(\r\n            \'type\' => \'MySQL\',\r\n            \'host\' => \'127.0.0.1\',\r\n            \'user\' => \'root\',\r\n            \'password\' => \'123456\',\r\n            \'dbname\' => \'test\',\r\n        ),\r\n        \'slave2\' => array(\r\n            \'type\' => \'MySQL\',\r\n            \'host\' => \'127.0.0.1\',\r\n            \'user\' => \'root\',\r\n            \'password\' => \'123456\',\r\n            \'dbname\' => \'test\',\r\n        ),\r\n    ),\r\n);\r\nreturn $config;\r\n\r\n```\r\n关于php代理模式文章 https://segmentfault.com/a/1190000007547503\r\n\r\n## 五、其余设计模式以及总结\r\n文章接：\r\n\r\nhttps://segmentfault.com/a/1190000017940733\r\n\r\nhttps://segmentfault.com/a/1190000017942443\r\n\r\n \r\n\r\n## 六、面向对象编程的基本原则\r\n1、单一职责原则：一个类只需要做好一件事情。不要使用一个类完成很多功能，而应该拆分成更多更小的类。\r\n\r\n2、开放封闭原则：一个类写好之后，应该是可扩展而不可修改的。\r\n\r\n3、依赖倒置原则：一个类不应该强依赖另外一个类，每个类对于另外一个类都是可替换的。\r\n\r\n4、配置化原则：尽量使用配置，而不是硬编码。\r\n\r\n5、面向接口编程原则：只需要关心某个类提供了哪些接口，而不需要关心他的实现。\r\n\r\n \r\n\r\n## 七、自动加载配置类文件\r\n1、php中使用ArrayAccess实现配置文件的加载（使得程序可以以数组的方式进行读取配置）\r\n\r\n（1）定义Config.php，继承php自带的ArrayAccess接口，并实现相应的方法，用于读取和设置配置\r\n\r\nExtend/Config.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\n/**\r\n * 配置类，继承于php自带的ArrayAccess接口\r\n * 允许一个对象以数组的方式访问\r\n * Class Config\r\n * @package Extend\r\n */\r\nclass Config implements \\ArrayAccess\r\n{\r\n    protected $path;\r\n    protected $configs = array();\r\n \r\n    function __construct($path)\r\n    {\r\n        $this->path = $path;\r\n    }\r\n \r\n    function offsetGet($key)\r\n    {\r\n        if (empty($this->configs[$key]))\r\n        {\r\n            $file_path = $this->path.\'/\'.$key.\'.php\';\r\n            $config = require $file_path;\r\n            $this->configs[$key] = $config;\r\n        }\r\n        return $this->configs[$key];\r\n    }\r\n \r\n    function offsetSet($key, $value)\r\n    {\r\n        throw new \\Exception(\"cannot write config file.\");\r\n    }\r\n \r\n    function offsetExists($key)\r\n    {\r\n        return isset($this->configs[$key]);\r\n    }\r\n \r\n    function offsetUnset($key)\r\n    {\r\n        unset($this->configs[$key]);\r\n    }\r\n}\r\n\r\n```\r\n（2）configs/database.php\r\n```\r\n<?php\r\n$config = array(\r\n    \'master\' => array(\r\n        \'type\' => \'MySQL\',\r\n        \'host\' => \'127.0.0.1\',\r\n        \'user\' => \'root\',\r\n        \'password\' => \'123456\',\r\n        \'dbname\' => \'test\',\r\n    ),\r\n    \'slave\' => array(\r\n        \'slave1\' => array(\r\n            \'type\' => \'MySQL\',\r\n            \'host\' => \'127.0.0.1\',\r\n            \'user\' => \'root\',\r\n            \'password\' => \'123456\',\r\n            \'dbname\' => \'test\',\r\n        ),\r\n        \'slave2\' => array(\r\n            \'type\' => \'MySQL\',\r\n            \'host\' => \'127.0.0.1\',\r\n            \'user\' => \'root\',\r\n            \'password\' => \'123456\',\r\n            \'dbname\' => \'test\',\r\n        ),\r\n    ),\r\n);\r\nreturn $config;\r\n\r\n```\r\n（3）读取配置\r\n```\r\n<?php\r\n \r\n$config = new Extend\\Config(__DIR__.\'/configs\');\r\nvar_dump($config[\'database\']);\r\n\r\n```\r\n到此，就可以在程序中随心所欲的加载配置文件了。\r\n\r\n\r\n### 2、在工厂方法中读取配置，生成可配置化的对象\r\n\r\nExtend/Factory.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\nclass Factory\r\n{\r\n    static function getDatabase($id)\r\n    {\r\n        $key = \'database_\'.$id;\r\n        if ($id == \'slave\')\r\n        {\r\n            $slaves = Application::getInstance()->config[\'database\'][\'slave\'];\r\n            $db_conf = $slaves[array_rand($slaves)];\r\n        } else {\r\n            $db_conf = Application::getInstance()->config[\'database\'][$id];\r\n        }\r\n        //注册树模式存储及获取对象\r\n        $db = Register::get($key);\r\n        if (!$db) {\r\n            $db = new Database\\MySQLi();\r\n            $db->connect($db_conf[\'host\'], $db_conf[\'user\'], $db_conf[\'password\'], $db_conf[\'dbname\']);\r\n            Register::set($key, $db);\r\n        }\r\n        return $db;\r\n    }\r\n \r\n}\r\n\r\n```\r\n Extend/Application.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\nclass Application\r\n{\r\n    public $base_dir;\r\n    protected static $instance;\r\n \r\n    public $config;\r\n \r\n    protected function __construct($base_dir)\r\n    {\r\n        $this->base_dir = $base_dir;\r\n        $this->config = new Config($base_dir.\'/configs\');\r\n    }\r\n \r\n    static function getInstance($base_dir = \'\')\r\n    {\r\n        if (empty(self::$instance))\r\n        {\r\n            self::$instance = new self($base_dir);\r\n        }\r\n        return self::$instance;\r\n    }\r\n \r\n}\r\n\r\n```\r\nExtend/Config.php\r\n```\r\n<?php\r\nnamespace Extend;\r\n \r\n/**\r\n * 配置类，继承于php自带的ArrayAccess接口\r\n * 允许一个对象以数组的方式访问\r\n * Class Config\r\n * @package Extend\r\n */\r\nclass Config implements \\ArrayAccess\r\n{\r\n    protected $path;\r\n    protected $configs = array();\r\n \r\n    function __construct($path)\r\n    {\r\n        $this->path = $path;\r\n    }\r\n \r\n    function offsetGet($key)\r\n    {\r\n        if (empty($this->configs[$key]))\r\n        {\r\n            $file_path = $this->path.\'/\'.$key.\'.php\';\r\n            $config = require $file_path;\r\n            $this->configs[$key] = $config;\r\n        }\r\n        return $this->configs[$key];\r\n    }\r\n \r\n    function offsetSet($key, $value)\r\n    {\r\n        throw new \\Exception(\"cannot write config file.\");\r\n    }\r\n \r\n    function offsetExists($key)\r\n    {\r\n        return isset($this->configs[$key]);\r\n    }\r\n \r\n    function offsetUnset($key)\r\n    {\r\n        unset($this->configs[$key]);\r\n    }\r\n}\r\n\r\n```\r\n', '1', '1', '2019-01-19 10:33:59', '2019-01-19 13:13:39');
INSERT INTO `posts` VALUES ('70', '13', '0-13', '2', '星期日打卡', '学习了MySQL 索引原理及设计，巩固一下go的基本语法', '## 昨天梳理了一下php框架的流程，已经git的使用分支的一些技巧\r\n- [我设计一个phpms框架前的准备](https://segmentfault.com/a/1190000017953263)\r\n- [创建与合并分支](/index.php/index/postinfo/id/61)\r\n\r\n## 今天上午学习了MySQL 索引原理及设计，已经go的基本语法\r\n- [MySQL 索引原理及设计](https://icell.io/how-mysql-index-works)\r\n- [go的基础](/index.php/index/term/id/15)\r\n\r\n## 今天下午要理解一下常用算法的优化，和网络协议\r\n- [算法](http://wqb.science/tags/#%E7%AE%97%E6%B3%95)\r\n- [网络协议](http://wqb.science/tags/#%E7%BD%91%E7%BB%9C)', '1', '1', '2019-01-20 05:02:30', '2019-01-20 07:36:04');
INSERT INTO `posts` VALUES ('71', '15', '0-15', '2', '2-语法结构', '先了解一下语法结构，var,cont,type和func 什么意义，有什么作用，哪里能用的上，有哪些可以避开的坑', '>Go语言主要有四种类型的声明语句：var, const, type 和 func, 分别对应变量, 常量, 类型和函数实体对象的声明\r\n\r\n```\r\n// 当前程序的包名(一个可执行程序只有一个 main 包)\r\n//一般建议package的名称和目录名保持一致\r\npackage main\r\n\r\n// 导入其它包\r\n// 缺少或未使用的包,程序都无法编译通过\r\nimport \"fmt\"\r\n\r\n// 通过 const 关键字来进行常量的定义\r\nconst number1 = 10\r\n\r\n// 通过 var 关键字来声明变量\r\nvar number2 = 20\r\n\r\n// 数组\r\nvar number3 = [5]int{1, 3, 5, 7, 9}\r\n\r\n// 集合\r\nvar number4 = map[string]int{\r\n	\"Age1\": 18,\r\n	\"Age2\": 19,\r\n	\"Age2\": 20,\r\n}\r\n\r\n// 一般类型声明\r\ntype number5 int\r\n\r\n// 结构声明\r\ntype number6 struct{}\r\n\r\n// 接口声明\r\ntype number7 interface{}\r\n\r\n// 通过 func 关键字来进行函数的声明\r\n// 只有 package 名称为 main 的包才可以包含 main 函数\r\nfunc main() {\r\n	fmt.Println(\"Hello World\")\r\n}\r\n```', '1', '1', '2019-01-20 05:49:03', '2019-01-20 05:52:03');
INSERT INTO `posts` VALUES ('72', '15', '0-15', '2', '3-变量, 常量', '命名规范，常量，变量，常量计数器。都有哪些特点。', '## 命名规则\r\n名字必须以一个字母或下划线开头, 后面可以跟任意数量的字母, 数字或下划线\r\nGo语言中有25个关键字, 关键字不能用于命名, 只能在特定语法结构中使用\r\n\r\n  1 |   2  |   3 |   4 |   5\r\n---|---|---|---|---\r\nbreak|default |func|interface|select\r\ncase|	defer	|go|	map	|struct\r\nchan|	else	|goto	|package	|switch\r\nconst|	fallthrough	|if	|range	|type\r\ncontinue|	for	|import	| return|var\r\n\r\nGo语言有大约30多个预定义的名字, 比如int和true等, 主要对应内建的常量类型和函数\r\n\r\n常量: true false iota nil\r\n\r\n类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr\r\nfloat32 float64 complex128 complex64 bool byte rune string error\r\n\r\n函数: make len cap new append copy close delete complex real imag panic recover\r\n\r\n这些内部预先定义的名字并不是关键字, 你可以在定义中重新使用它们, 但是要注意避免语义混乱\r\n\r\n根据首字母的大小写来确定可以访问的权限; 首字母大写, 可以被其他的包访问; 首字母小写, 则只能在本包中使用\r\n\r\n## 变量\r\n``` 5\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	var a int = 1\r\n	fmt.Println(a)\r\n\r\n	//var可以声明一个或多个变量\r\n    //已声明但未使用的变量会在编译阶段报错\r\n	var b, c string = \"a\", \"b\"\r\n	fmt.Println(b, c)\r\n\r\n	//声明为没有相应初始化的变量是零值的(int的零值是0, string的零值是空)\r\n	var d int\r\n	fmt.Println(d)\r\n\r\n	//Go将推断初始化变量的类型\r\n	//(:=)简短变量声明一般用于局部变量的声明和初始化,var往往是用在需要先指定变量类型稍后再赋值的\r\n	//不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量\r\n	e := true\r\n	fmt.Println(e)\r\n\r\n	//_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃\r\n	_, f := 7, 8\r\n	fmt.Println(f)\r\n}\r\n```\r\n\r\n```\r\n1\r\na b\r\n0\r\ntrue\r\n8\r\n```\r\n## 常量\r\n```\r\n// Go支持字符, 字符串, 布尔值和数值的常量\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\n//用 const 关键字定义常量\r\nconst a string = \"A\"\r\n\r\nfunc main() {\r\n\r\n	fmt.Println(a)\r\n\r\n	//const 可以定义一个或多个常量\r\n	const b, c = 1, 3\r\n	fmt.Println(b, c)\r\n\r\n	//表达式里可以有常量, 但不能有变量\r\n	const d = 4 - b\r\n	fmt.Println(d)\r\n\r\n}\r\n```\r\n\r\n```\r\nA\r\n1 3\r\n3\r\n```\r\n## 常量计数器 iota\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\n// iota是常量的计数器, 从0开始, 组中每定义1个常量自动递增1\r\n// 每遇到一个const关键字, iota就会重置为0\r\n\r\nconst (\r\n	GB int = 1 << (iota * 10)\r\n	MB int = 1 << (iota * 10)\r\n	KB int = 1 << (iota * 10)\r\n)\r\n\r\nconst (\r\n	a int = iota\r\n	b\r\n)\r\n\r\nfunc main() {\r\n\r\n	fmt.Println(GB, MB, KB)\r\n	fmt.Println(a, b)\r\n\r\n}\r\n```\r\n```\r\n1 1024 1048576\r\n0 1\r\n```', '1', '1', '2019-01-20 05:53:30', '2019-01-20 06:11:59');
INSERT INTO `posts` VALUES ('73', '15', '0-15', '2', '4-条件语句', '常见的判断if，选择switch,循环range，跳转goto,break,continue', '## 判断语句if\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	//条件表达式没有括号\r\n	//支持一个初始化表达式(可以是多变量初始化语句)\r\n	//左大括号必须和条件语句同一行\r\n    \r\n	if number := 7; number < 1 {\r\n		fmt.Println(1)\r\n	} else if number >= 1 && number <= 10 {\r\n		fmt.Println(2)\r\n	} else {\r\n		fmt.Println(3)\r\n	}\r\n\r\n}\r\n```\r\n\r\n```\r\n2\r\n```\r\n## 选择语句switch\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	switch number1 := 3; number1 {\r\n	case 1:\r\n		fmt.Println(1)\r\n	case 3:\r\n		fmt.Println(3)\r\n	case 5:\r\n		fmt.Println(5)\r\n	}\r\n	//不需要写break，一旦条件符合自动结束\r\n\r\n	number2 := 6\r\n	switch {\r\n	case number2 == 2:\r\n		fmt.Println(2)\r\n	case number2 == 4:\r\n		fmt.Println(4)\r\n	case number2 == 6:\r\n		fmt.Println(6)\r\n		//如希望继续执行下一个case，可以使用fallthrough语句\r\n		fallthrough\r\n	default:\r\n		fmt.Println(\"default\")\r\n	}\r\n\r\n}\r\n```\r\n```\r\n3\r\n6\r\ndefault\r\n```\r\n## 循环语句 for\r\n```\r\n//支持3种形式\r\nfor init; condition; post {}\r\nfor condition {}\r\nfor {}\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	//形式一:\r\n	for number1 := 1; number1 < 3; number1++ {\r\n\r\n		fmt.Printf(\"number1:%d\\n\", number1)\r\n	}\r\n	//形式二:\r\n	number2 := 1\r\n\r\n	for number2 < 3 {\r\n\r\n		fmt.Printf(\"number2:%d\\n\", number2)\r\n		number2++ //不能写成 number2 = number2++(++ 与 -- 是作为语句而不是作为表达式)\r\n	}\r\n	//形式三: for没有条件将无限循环;用break 退出循环\r\n	for {\r\n\r\n		fmt.Println(\"loop\")\r\n		break\r\n	}\r\n\r\n}\r\nnumber1:1\r\nnumber1:2\r\nnumber2:1\r\nnumber2:2\r\n```\r\n\r\n### loop 冒泡排序\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	number := [5]int{8, 3, 7, 1, 5}\r\n\r\n	for i := 0; i < len(number); i++ {\r\n		for j := i + 1; j < len(number); j++ {\r\n			if number[i] > number[j] {\r\n				number[i], number[j] = number[j], number[i]\r\n			}\r\n		}\r\n	}\r\n\r\n	fmt.Println(number)\r\n\r\n}\r\n```\r\n```\r\n[1 3 5 7 8]\r\n```\r\n## 遍历 range\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    \r\n    //range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素\r\n\r\n	number := [5]string{\"a\", \"b\", \"c\", \"d\", \"e\"}\r\n	for k, v := range number {\r\n		fmt.Println(k, v)\r\n	}\r\n\r\n	/* 省略key的写法\r\n		for _, v := range number {\r\n			fmt.Println(v)\r\n		}\r\n	*/\r\n\r\n}\r\n```\r\n```\r\n0 a\r\n1 b\r\n2 c\r\n3 d\r\n4 e\r\n```\r\n\r\n## 跳转语句goto, break, continue\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    //支持函数内部 goto 跳转, continue 跳出当前循环进入一下次循环，break 终止循环体\r\n    //break 和 continue 都可以配合标签,在多级嵌套循环间跳出.这和 goto 调整执行位置完全不同\r\n    //通常建议往后 goto,避免死循环\r\n    \r\n	for number := 1; number < 5; number++ {\r\n		if number == 3 {\r\n			break\r\n		}\r\n		fmt.Println(\"break:\", number)\r\n	}\r\n\r\n	for number := 1; number < 5; number++ {\r\n		if number == 3 {\r\n			continue\r\n		}\r\n		fmt.Println(\"continue:\", number)\r\n	}\r\nlable1:\r\n\r\n	for {\r\n		for {\r\n			//配合标签跳出最外层循环\r\n			//标签名是大小写敏感的\r\n			break lable1\r\n		}\r\n	}\r\n\r\n	fmt.Println(\"Hello World1\")\r\n\r\n	goto lable2\r\n\r\n	fmt.Println(\"Hello World2\")\r\n\r\nlable2:\r\n	fmt.Println(\"Hello World3\")\r\n\r\n}\r\n```\r\n```\r\nbreak: 1\r\nbreak: 2\r\ncontinue: 1\r\ncontinue: 2\r\ncontinue: 4\r\nHello World1\r\nHello World3\r\n```\r\n', '1', '1', '2019-01-20 06:16:38', '2019-01-20 06:22:34');
INSERT INTO `posts` VALUES ('74', '15', '0-15', '2', '5-数组,切片,集合,通道', '数组,切片,集合,通道这是未接触过的概念，好学习。', '> make\r\n\r\n```\r\n// The make built-in function allocates and initializes an object of type\r\n// slice, map, or chan (only). Like new, the first argument is a type, not a\r\n// value. Unlike new, make\'s return type is the same as the type of its\r\n// argument, not a pointer to it. The specification of the result depends on\r\n// the type:\r\n//	Slice: The size specifies the length. The capacity of the slice is\r\n//	equal to its length. A second integer argument may be provided to\r\n//	specify a different capacity; it must be no smaller than the\r\n//	length, so make([]int, 0, 10) allocates a slice of length 0 and\r\n//	capacity 10.\r\n//	Map: An empty map is allocated with enough space to hold the\r\n//	specified number of elements. The size may be omitted, in which case\r\n//	a small starting size is allocated.\r\n//	Channel: The channel\'s buffer is initialized with the specified\r\n//	buffer capacity. If zero, or the size is omitted, the channel is\r\n//	unbuffered.\r\nfunc make(Type, size IntegerType) Type\r\n```\r\n\r\n1. 内建函数 make 分配和初始化 一个 slice 或 map 或 chan 对象, 并且只能是这三种对象\r\n2. 和 new 类似，第一个参数也是一个类型而不是一个值， 不同的是 make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型\r\n3. slice : 第二个参数指定它的长度, 此时它的容量和长度相同. 可以用第三个参数来指定不同容量大小,但不能小于它的长度(第二个参数)\r\n4. map : 根据size 大小来初始化分配内存，不过分配后的 map 长度为0。 如果 size 被忽略了，那么会在初始化分配内存的时候 分配一个小尺寸的内存\r\n5. channel : 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者被忽略，管道是没有缓冲区的。\r\n\r\n> len\r\n\r\n```\r\n// The len built-in function returns the length of v, according to its type:\r\n//	Array: the number of elements in v.\r\n//	Pointer to array: the number of elements in *v (even if v is nil).\r\n//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.\r\n//	String: the number of bytes in v.\r\n//	Channel: the number of elements queued (unread) in the channel buffer;\r\n//	if v is nil, len(v) is zero.\r\nfunc len(v Type) int\r\n```\r\n\r\n> cap\r\n\r\n```\r\n// The cap built-in function returns the capacity of v, according to its type:\r\n//	Array: the number of elements in v (same as len(v)).\r\n//	Pointer to array: the number of elements in *v (same as len(v)).\r\n//	Slice: the maximum length the slice can reach when resliced;\r\n//	if v is nil, cap(v) is zero.\r\n//	Channel: the channel buffer capacity, in units of elements;\r\n//	if v is nil, cap(v) is zero.\r\nfunc cap(v Type) int\r\n```\r\n- map变量被创建后，你可以指定map的容量，但是不可以在map上使用cap()方法\r\n\r\n> new\r\n\r\n```\r\n// The new built-in function allocates memory. The first argument is a type,\r\n// not a value, and the value returned is a pointer to a newly\r\n// allocated zero value of that type.\r\nfunc new(Type) *Type\r\n```\r\n- 内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	number1 := [5]int{}\r\n	number2 := new([5]int)\r\n\r\n	fmt.Println(number1)\r\n	fmt.Println(number2)\r\n\r\n}\r\n```\r\n```\r\n[0 0 0 0 0]\r\n&[0 0 0 0 0]\r\n```\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\ntype person struct {\r\n	name string\r\n	age  int\r\n}\r\n\r\nfunc main() {\r\n\r\n	p1 := person{}\r\n	p2 := &person{}\r\n	p3 := new(person)\r\n\r\n	fmt.Println(p1) // 返回类型\r\n	fmt.Println(p2) // 返回指针\r\n	fmt.Println(p3) // 和p2一样\r\n\r\n}\r\n```\r\n```\r\n{ 0}\r\n&{ 0}\r\n&{ 0}\r\n```\r\n\r\n> nil\r\n\r\n```\r\n// nil is a predeclared identifier representing the zero value for a\r\n// pointer, channel, func, interface, map, or slice type.\r\nvar nil Type // Type must be a pointer, channel, func, interface, map, or slice type\r\n```\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    // nil 是一个预定义标识符，其代表（用作）一些类型的零值；这些类型包括：pointer, channel, func, interface, map, slice \r\n\r\n	var n1 []int\r\n\r\n	var n2 map[int]string\r\n\r\n	var n3 chan int\r\n\r\n	if n1 == nil {\r\n		fmt.Println(\"n1\")\r\n	}\r\n\r\n	if n2 == nil {\r\n		fmt.Println(\"n1\")\r\n	}\r\n\r\n	if n3 == nil {\r\n		fmt.Println(\"n1\")\r\n	}\r\n}\r\n```\r\n\r\n### 相关阅读\r\n\r\n[理解Go语言的nil](http://www.jianshu.com/p/dd80f6be7969)\r\n\r\n\r\n[golang: 详解interface和nil](https://my.oschina.net/goal/blog/194233)\r\n\r\n## 数组 array\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n   //如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算\r\n   //数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定\r\n   \r\n	number1 := [3]int{1, 2, 2: 3}\r\n\r\n	number2 := [3][4]int{\r\n		{1, 2, 3, 4},\r\n		{5, 6, 7, 8},\r\n		{0: 9, 1: 10, 2: 11, 3: 12},\r\n	}\r\n\r\n	number3 := [2][2][3]int{\r\n		{{1, 2, 3}, {4, 5, 6}},\r\n		{{7, 8, 9}, {10, 11, 12}},\r\n	}\r\n\r\n	fmt.Println(number1)\r\n\r\n	fmt.Println(number2)\r\n\r\n	fmt.Println(number3)\r\n\r\n	number4 := [...]int{3, 1, 9, 6, 8}\r\n\r\n	for i := 0; i < len(number4); i++ {\r\n		for j := i + 1; j < len(number4); j++ {\r\n			if number4[i] < number4[j] {\r\n				number4[i], number4[j] = number4[j], number4[i]\r\n			}\r\n		}\r\n	}\r\n\r\n	fmt.Println(number4)\r\n}\r\n```\r\n```\r\n[1 2 3]\r\n[[1 2 3 4] [5 6 7 8] [9 10 11 12]]\r\n[[[1 2 3] [4 5 6]] [[7 8 9] [10 11 12]]]\r\n[9 8 6 3 1]\r\n```\r\n\r\n> 切片 slice\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    // make([]T, length长度, capacity容量)        \r\n    // 一般使用make()创建 : 用len获取切片长度, cap获取切片容量 \r\n    // 一个切片在未初始化之前默认为 nil，长度为 0\r\n    // 与数组相比切片的长度是不固定的,可以追加元素,在追加时可能使切片的容量增大\r\n    \r\n	number1 := make([]int, 9, 10)\r\n	fmt.Println(len(number1), cap(number1))\r\n\r\n	number2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\r\n	number3 := number2[:6]\r\n	number4 := number2[6:]\r\n	number5 := number2[4:5]\r\n\r\n	fmt.Println(number3, number4, number5)\r\n}\r\n```\r\n```\r\n9 10\r\n[1 2 3 4 5 6] [7 8 9] [5]\r\n```\r\n\r\n> copy\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n   //`copy` 函数`copy`从源`slice`的`src`中复制元素到目标`dst`，并且返回复制的元素的个数\r\n\r\n	number1 := []int{1, 2, 3, 4, 5}\r\n	number2 := []int{6, 7, 8}\r\n	number3 := copy(number1, number2)\r\n	fmt.Println(number1, number2, number3)\r\n\r\n	number4 := []int{1, 2, 3, 4, 5}\r\n	number5 := []int{6, 7, 8}\r\n	number6 := copy(number5, number4)\r\n	fmt.Println(number4, number5, number6)\r\n\r\n}\r\n```\r\n```\r\n[6 7 8 4 5] [6 7 8] 3\r\n[1 2 3 4 5] [1 2 3] 3\r\n```\r\n\r\n> append\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n   //`append` 向`slice`里面追加一个或者多个元素，然后返回一个和`slice`一样类型的`slice`\r\n\r\n	number1 := []int{1, 2, 3}\r\n	fmt.Println(number1, len(number1), cap(number1))\r\n	number1 = append(number1, 4, 5)\r\n	fmt.Println(number1, len(number1), cap(number1)) //按初始容量成倍扩大\r\n\r\n	number3 := append(number1, number1...) //用省略号自动展开切片,以使用每个元素\r\n	fmt.Println(number3)\r\n\r\n}\r\n```\r\n```\r\n[1 2 3] 3 3\r\n[1 2 3 4 5] 5 6\r\n[1 2 3 4 5 1 2 3 4 5]\r\n```\r\n\r\n> 集合 map\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"sort\"\r\n)\r\n\r\nfunc main() {\r\n\r\n    //map的key必须是支持==或!=比较运算的类型,不可以是函数,map或slice;   map的value 则没有任何的限制\r\n\r\n	number3 := map[int]string{1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\"}\r\n	number4 := make([]int, len(number3))\r\n\r\n	i := 0\r\n	for k, v := range number3 {\r\n		fmt.Println(k, v)\r\n		number4[i] = k\r\n		i++\r\n	}\r\n\r\n	sort.Ints(number4)\r\n	fmt.Println(number4)\r\n\r\n}\r\n```\r\n```\r\n2 b\r\n3 c\r\n4 d\r\n5 e\r\n1 a\r\n[1 2 3 4 5]\r\n```\r\n\r\n- Map的迭代顺序是随机的\r\n\r\n```\r\n3 c\r\n4 d\r\n5 e\r\n1 a\r\n2 b\r\n[1 2 3 4 5]\r\n```\r\n\r\n> delete\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    //删除对应的键值对,如果集合为空或找不到对应的键,则无操作\r\n\r\n	number := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}\r\n	fmt.Println(number)\r\n\r\n	delete(number, \"b\")\r\n	fmt.Println(number)\r\n\r\n	delete(number, \"f\")\r\n	fmt.Println(number)\r\n}\r\n```\r\n```\r\nmap[b:2 c:3 d:4 e:5 a:1]\r\nmap[a:1 c:3 d:4 e:5]\r\nmap[c:3 d:4 e:5 a:1]\r\n```\r\n\r\n> 通道 channel\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n     \r\n     //go 关键字用来创建 goroutine (协程)，是实现并发的关键\r\n     //channel  用来进行多个goroutine通信的，可以设置缓存大小,在未被填满前不会发生阻塞(默认为0,无缓冲)\r\n     //无缓冲的信道是一批数据一进一出, 有缓冲的信道则是一个一个存储，然后一起流出去\r\n     //select 可以处理一个或多个 channel 的发送与接收\r\n\r\n	//使用 make(chan val-type) 创建一个新的通道\r\n	ch := make(chan int)\r\n\r\n	//go 关键字创建一个协程\r\n	go loop(ch)\r\n	go loop(ch)\r\n\r\n	//使用阻塞的接受方式来等待一个 go 协程的运行结束\r\n	<-ch\r\n	<-ch //从通道中接收值\r\n}\r\n\r\nfunc loop(ch chan int) {\r\n	for i := 0; i < 8; i++ {\r\n		fmt.Println(i)\r\n	}\r\n	ch <- 1 //发送值到通道\r\n}\r\n```\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n	ch1 := make(chan int)\r\n	ch2 := make(chan int)\r\n	ch3 := make(chan int)\r\n\r\n	go func() {\r\n		ch1 <- 1\r\n	}()\r\n\r\n	go func() {\r\n		ch2 <- 2\r\n	}()\r\n\r\n	go func() {\r\n		ch3 <- 3\r\n	}()\r\n\r\n	//select 关键字同时等待多个值\r\n	//默认处理第一个已准备好的接收操作\r\n	//default 可以实现非阻塞\r\n	for i := 0; i < 3; i++ {\r\n		select {\r\n		case <-ch1:\r\n			fmt.Println(1)\r\n		case <-ch2:\r\n			fmt.Println(2)\r\n		case <-ch3:\r\n			fmt.Println(3)\r\n//		default:\r\n//			fmt.Println(4)\r\n		}\r\n	}\r\n\r\n}\r\n```\r\n\r\n> close\r\n\r\n```\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\r\n    //close 关闭通道\r\n\r\n	ch := make(chan int)\r\n	close(ch)\r\n\r\n	go loop(ch)\r\n	go loop(ch)\r\n\r\n	<-ch\r\n	<-ch\r\n}\r\n\r\nfunc loop(ch chan int) {\r\n	for i := 0; i < 8; i++ {\r\n		fmt.Println(i)\r\n	}\r\n	ch <- 1\r\n}\r\n```\r\n## 相关阅读\r\n\r\n- [Go语言并发与并行学习笔记(一)]()\r\n\r\n- [Go语言并发与并行学习笔记(二)]()\r\n\r\n- [Go语言并发与并行学习笔记(三)]()\r\n\r\n- [进程和线程、协程的区别]()\r\n\r\n- [Go 语言 select 语句]()', '1', '1', '2019-01-20 06:24:43', '2019-01-20 06:53:48');
INSERT INTO `posts` VALUES ('75', '3', '0-3', '2', 'RESTful API详解', 'RESTful API就是REST风格的API\r\nREST 的目的:Client 和 Server 端进一步 解耦', '## 解释:\r\n```\r\nRESTful:URL定位资源，用HTTP动词（GET,POST,PUT,DELETE)描述操作。\r\n   Resource：资源，即数据。\r\n   Representational：某种表现形式，比如用JSON，XML，JPEG等；\r\n   State Transfer：状态变化。通过HTTP动词实现。\r\n```\r\n所以RESTful API就是REST风格的API。\r\n\r\n\r\n## 目的:\r\n\r\nREST 的目的:Client 和 Server 端进一步 解耦 \r\n\r\n\r\n## 特点:\r\n\r\n- 安全可靠，高效，易扩展\r\n- 简单明了，可读性强，没有歧义\r\n- API风格统一，调用规则，传入参数和返回数据有统一的标准\r\n\r\n## 设计原则:\r\n\r\n### 1.HTTPS：\r\n\r\nhttps 为接口的安全提供了保障,可以有效防止通信被窃听和篡改, 而且现在部署https的成本越来月低,你可以通过cerbot等工具, 方便快速的制作免费的安全证书,所以生产环境,请务必使用https.\r\n\r\n\r\n### 2.域名:\r\n\r\n应当尽可能的将API与其主域名区分开,可以使用专用的域名, 访问我们的API,例如(推荐使用):\r\n```\r\nhttps://api.larabbs.com \r\n```\r\n或者可以放到主域名下,例如:\r\n```\r\nhttps://www.larabbs.com/api \r\n```\r\n\r\n### 3.版本控制\r\n\r\n随着业务的发展,需求的不断变化, API的迭代是必然的,很可能当前版本正在使用, 而我们就得开发甚至上线一个不兼容的版本, 为了让旧用户可以正常使用,为了保证开发的顺利进行,我们需要控制好API的版本.\r\n\r\n通常情况下, 有两种做法:\r\n\r\n将版本号直接加入URL中\r\n```\r\nhttps://api.larabbs.com/v1 \r\nhttps://api.larabbs.com/v2 \r\n```\r\n\r\n使用HTTP请求头的Accept字段进行区分\r\n```\r\n https://api.larabbs.com/\r\n    Accept: application/prs.larabbs.v1+json\r\n    Accept: application/prs.larabbs.v2+json\r\n```\r\n\r\n### 4.用URL定位资源\r\n\r\n在restful 的架构中,所有的一切表示资源,每一个URL都代表这一种资源,资源应当是一个名词, 而且大部分情况下是名词的附属,尽量不要在URL中出现动词\r\n\r\ngithub的例子:\r\n```\r\nGET /issues                                     列出所有的issues\r\nGET /orgs/:org/issues                           列出某个项目的 issues\r\nGET /repos/:owner/:repo/issues/:number          获取某个项目的某个 issue\r\nPOST /repos/:owner/:repo/issues                 为某个项目创建 issue\r\nPATCH /repos/:owner/:repo/issues/:number        修改某个issue\r\nPUT /repos/:owner/:repo/issues/:number/lock     锁住某个issue\r\nDELETE /repos/:owner/:repo/issues/:number/lock  接收某个issue\r\n```\r\n例子中冒号开始的代表变量，例如 /repos/summerblue/larabbs/issues\r\n\r\n在github的实现中, 我们可以总结出:\r\n\r\n资源的设计可以嵌套,表明资源与资源之间的关系。\r\n\r\n大部分的情况下我们访问的是某个资源集合,想得到单个资源可以通过资源的id 或 number等唯一标识获取\r\n\r\n某些情况下 资源会是单数形式,例如某个项目某个issue的锁,每一个issue只会有一把锁,所以它是单数\r\n\r\n\r\n错误例子:\r\n```\r\nPOST https://api.larabbs.com/createTopic\r\nGET https://api.larabbs.com/topic/show/1\r\nPOST https://api.larabbs.com/topics/1/comments/create\r\nPOST https://api.larabbs.com/topics/1/comments/100/delete\r\n```\r\n正确的例子：\r\n```\r\nPOST https://api.larabbs.com/topics\r\nGET https://api.larabbs.com/topics/1\r\nPOST https://api.larabbs.com/topics/1/comments\r\nDELETE https://api.larabbs.com/topics/1/comments/100\r\n```\r\n\r\n### 5.用HTTP动词描述操作\r\n\r\nHttp设计了很多动词, 来标识不同的操作, RESTful 很好的利用的这一点, 我们需要正确的使用HTTP 动词, 来表明我们如何操作资源.\r\n\r\n### 6.资源过滤\r\n\r\n我们需要提供合理的参数供客户端过滤资源, 例如:\r\n```\r\n?state=closed: 不同状态的资源\r\n?page=2&per_page=100：访问第几页数据，每页多少条。\r\n?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\r\n```\r\n\r\n### 7.正确的使用状态码\r\n\r\nHTTP提供了丰富的状态码,正确的使用状态码可以让相应的数据具有可读性。\r\n\r\n在状态码的设计编排上尽量遵守HTTP的状态码,\r\n\r\n### 8.数据相应格式\r\n\r\n考虑到响应数据的可读性及通用性，默认使用 JSON 作为数据响应格式。如果客户端有需求使用其他的响应格式，例如 XML，需要在 Accept 头中指定需要的格式。\r\n```\r\nhttps://api.larabbs.com/\r\n    Accept: application/prs.larabbs.v1+json\r\n    Accept: application/prs.larabbs.v1+xml\r\n```\r\n对于错误数据,默认使用个如下结构:\r\n```\r\n\'messgae\'=>\':messgae\'   //错误的具体描述\r\n\'errors\'=>\':errors\',    // 参数的具体错误描述, 422 等状态提供\r\n\'code\'=>\':code\',    // 自定义的异常码,\r\n\'status_code\'=>\':status_code\', // http状态码\r\n\'debug\'=>\':debug\'  // debug 信息, 非生产环境提供\r\n```\r\n例如:\r\n```\r\n{\r\n    \"message\": \"422 Unprocessable Entity\",\r\n    \"errors\": {\r\n        \"name\": [\r\n            \"姓名 必须为字符串。\"\r\n        ]\r\n    },\r\n    \"status_code\": 422\r\n}\r\n{\r\n    \"message\": \"您无权访问该订单\",\r\n    \"status_code\": 403\r\n}\r\n```\r\n\r\n### 9、调用的频率限制\r\n\r\n为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况\r\n```\r\nX-RateLimit-Limit :100 最大访问次数\r\nX-RateLimit-Remaining :93 剩余的访问次数\r\nX-RateLimit-Reset :1513784506 到该时间点，访问次数会重置为 X-RateLimit-Limit\r\n```\r\n超过限流次数后，需要返回 429 Too Many Requests 错误。\r\n\r\n### 10.编写文档\r\n\r\n为了方便用户使用，我们需要提供清晰的文档，尽可能包括以下几点:\r\n\r\n- 包括每个接口的请求参数，每个参数的类型限制，是否必填，可选的值等。\r\n- 响应结果的例子说明，包括响应结果中，每个参数的释义。 \r\n- 对于某一类接口，需要有尽量详细的文字说明，比如针对一些特定场景，接口应该如何调用。', '1', '1', '2019-01-20 07:24:17', '2019-01-20 07:31:07');
INSERT INTO `posts` VALUES ('76', '13', '0-13', '2', '这今天最有收获的好东西', '深度｜从一个故事说起，谈谈企业应用架构的演变史', '[深度｜从一个故事说起，谈谈企业应用架构的演变史](http://www.woshipm.com/pd/586436.html)\r\n## 我决定个人网站也引入 百度语言 http://yuyin.baidu.com/docs/tts/44\r\n##  还有百度的图片识别文字\r\n解决看blog,又想不动鼠标的回顾blog内容.以语音的形式读出来，', '1', '1', '2019-01-21 13:32:30', '2019-01-21 13:37:08');
INSERT INTO `posts` VALUES ('77', '13', '0-13', '2', '好开心，百度语言和百度OCR', '更人性话的软件，是我追求的。', '这是OCR 百度官方文档 http://ai.baidu.com/docs#/OCR-API/top\r\n\r\n这是语音 百度官方文档  http://ai.baidu.com/docs#/TTS-API/top', '1', '1', '2019-01-22 11:34:48', '2019-01-22 03:39:42');
INSERT INTO `posts` VALUES ('78', '5', '0-5', '2', '百度', '滕刚 帅爆了', '职位描述\r\n\r\n工作职责： \r\n\r\n1）负责业务后台业务开发 \r\n\r\n2）负责对现行系统的性能优化及数据库优化 \r\n\r\n3）负责产品架构的优化调整 \r\n\r\n4）负责对用户体验的优化创新 \r\n\r\n职位要求： \r\n\r\n1）本科及以上学历，2年以上工作经验，计算机相关专业 \r\n\r\n2）精通算法设计/数据结构，有系统分析和设计的项目经验 \r\n\r\n3）精通linux平台上的PHP/Python编程 \r\n\r\n4）具备较强的分析问题和解决问题的能力\r\n\r\n公司介绍\r\n\r\n百度（纳斯达克：BIDU），全球最大的中文搜索引擎、最大的中文网站。1999年底,身在美国硅谷的李彦宏看到了中国互联网及中文搜索引擎服务的巨大发展潜力，抱着技术改变世界的梦想，他毅然辞掉硅谷的高薪工作，携搜索引擎专利技术，于 2000年1月1日在中关村创建了百度公司。', '1', '0', '2019-01-22 03:52:41', '2019-01-22 12:03:24');
INSERT INTO `posts` VALUES ('79', '5', '0-5', '2', '字节跳动', '鲁莎', '职位描述：\r\n\r\n1、负责对标业内顶级 PaaS 和 SaaS 平台的需求研究、技术研究和实现，包括但不限于底层元数据管理、高度灵活的权限管理系统、可扩展的数据存储方案、分布式搜索引擎技术；\r\n\r\n2、负责团队服务质量、稳定性，从工具、系统上提升团队开发效率，对重点及有难度的技术攻坚；\r\n\r\n3、负责团队 Scrum 流程推进和优化；\r\n\r\n4、负责发现和产出对团队效率提升有价值的产品和工具。\r\n\r\n职位要求：\r\n\r\n1、统招本科学历，3年左右工作经验；\r\n\r\n2、良好的设计和编码品味，热爱写代码； \r\n\r\n3、较好的产品意识，愿意将产品效果做为工作最重要的驱动因素；\r\n\r\n4、掌握WEB后端开发技术: 协议、架构、存储、缓存、安全等；\r\n\r\n5、积极乐观，认真负责，乐于协作。\r\n\r\n公司介绍\r\n\r\n字节跳动，是全球第一家将人工智能应用到主产品的科技公司。\r\n\r\n短短6年，我们从最初的一个“今日头条”，已经发展为拥有“抖音”、“西瓜视频”、“火山小视频”、“FaceU”等十几款', '1', '0', '2019-01-22 11:57:22', '2019-01-22 12:02:52');
INSERT INTO `posts` VALUES ('80', '13', '0-13', '2', '拜读经典《企业应用架构模式》', 'Patterns of Enterprise Application Architecture --Martin Fowler', '京东昨天下的单，今天就可以拜读《Patterns of Enterprise Application Architecture 》--Martin Fowler\r\n\r\n## 第一眼\r\n\r\n看了一下模式列表\r\n\r\n内容部分分两部表述和模式\r\n\r\n## 表述部分有\r\n1.分层\r\n\r\n2.组织邻域逻辑\r\n\r\n3.映射关系数据库\r\n\r\n4.web表现层\r\n\r\n5.并发\r\n\r\n6.会话状态\r\n\r\n7.分布策略\r\n\r\n8.通盘考虑\r\n\r\n## 模式部分有\r\n1.邻域逻辑模式\r\n\r\n2.数据源架构模式\r\n\r\n3.对象-关系行为模式\r\n\r\n4.对象-关系结构模式\r\n\r\n5.对象-关系元数据映射模式\r\n\r\n6.web表现模式\r\n\r\n7.分布模式\r\n\r\n8.离线并发模式\r\n\r\n9.会话状态模式\r\n\r\n10.基本模式', '1', '1', '2019-01-22 12:24:27', '2019-01-22 12:41:21');
INSERT INTO `posts` VALUES ('81', '5', '0-5', '2', '北京古稀仁科技有限公司', '', '职位描述\r\n\r\n1.之前有做过或接触过全站性质的开发，有熟悉或一定了解\r\n\r\n2.有独立的技术能力，可自行完成项目后端规划实施\r\n\r\n3.主做后端技术开发，对服务器数据库有一定基本，擅长一两种框架\r\n\r\n工商信息\r\n\r\n北京古稀仁科技有限公司\r\n\r\n法人代表：张向宇 \r\n\r\n注册资金：100万元人民币 \r\n\r\n成立时间：2018-10-24\r\n\r\n企业类型：有限责任公司(自然人独资) \r\n\r\n经营状态：开业\r\n', '1', '0', '2019-01-22 13:02:24', '2019-01-22 13:06:02');
INSERT INTO `posts` VALUES ('82', '5', '0-5', '2', '成都板扎科技有限公司', '熊启明 人事专员', '岗位要求:\r\n```\r\n1.具有三到五年或以上的PHP编程经验，可独立编写程序，代码编写规范，对PHP性能和兼容性都有较深的体会；\r\n2.可进行主流开源框架和开源程序的二次开发、模版改进和系统重构；\r\n3.熟悉小程序开发、微信平台开发经验者优先考虑；\r\n4.了解XML、 HTML/XHTML 、CSS、Javascript、AJAX、JSON等Web页面技术；\r\n5.熟悉服务器，数据库MySQL，对大数据量和大访问量有架构和优化经验者优先考虑；\r\n6.抗压能力强，对新技术有钻研精神；\r\n```\r\n职责范围:\r\n```\r\n1.负责公司系统平台应用的后台设计与开发；\r\n2.负责后台数据库的设计、管理和维护；\r\n3.负责公司网站优化升级；\r\n4.负责公司网站的附加功能开发，为市场部门提供技术支持；\r\n```\r\n福利：\r\n提供住宿和工作餐\r\n团队介绍\r\n```\r\n*专业市场地推团队，20年地推进调，踏遍8次中国，服务26个国家；\r\n*专业企业咨询团队，20年服务过携程、滴滴、美团、阿里、腾讯等互联网巨头，以及平安银行、联想集团等大型企业。\r\n*懂战略，懂架构，懂管理，懂运营；\r\n*懂政治，懂消费者，懂企业，懂市场。\r\n年终分红 移动互联网 扁平管理 免费零食 公司氛围好 智能硬件\r\n```\r\n公司介绍\r\n\r\n成都板扎科技有限公司是一家互联网服务型企业，致力于服务那些想从线下走到线上，实现线下和线上相结合的企业；通过精准的数据分析服务各行各业，帮助政府进行精准扶贫。\r\n\r\n公司负责新项目在西南五省一市的技术支持和销售；目前在北京、上海、杭州、西安、昆明、武汉和深圳已成立公司。', '1', '0', '2019-01-22 13:08:50', '2019-01-22 13:10:35');
INSERT INTO `posts` VALUES ('83', '5', '0-5', '2', '网上客点亮科技（北京）有限公司', '王', '职责描述：\r\n```\r\n1.负责公司相关产品业务平台的开发和维护；\r\n2.负责网站后端开发和维护工作；\r\n3.负责所属项目数据库、程序模块的设计、编码和内部测试；\r\n4.负责应用模块开发和实现；\r\n```\r\n岗位要求：\r\n```\r\n1.2年以上PHP项目实际开发经验，会二次修改开发，能熟练运用面向对象思想进行开发；\r\n2.熟练使用ThinkPHP5框架，有相关开发经验；\r\n3.熟悉前端CSS，JS(JQuery)，HTML，熟练使用AJAX，\r\n4.熟悉MYSQL数据库，精通SQL语句，有设计数据库的能力；\r\n5.优化、调试能力和分析、解决问题能力，逻辑思维清晰严谨\r\n6.熟悉服务端开发中各类缓存设计、站点优化方案\r\n7.了解memcache、redis、mongodb等常用nosql解决方案，了解各自的优缺点以及使用场景\r\n8.有良好的团队精神、敬业精神和沟通协调能力，善于学习，能主动学习钻研与工作相关的知识\r\n9.计算机相关专业\r\n```', '1', '0', '2019-01-22 13:36:51', '2019-01-22 13:38:19');
INSERT INTO `posts` VALUES ('84', '3', '0-3', '2', '$.ajax()参数详解及标准写法(太全面了，值得收藏)', '你用了那么多ajax,你真的懂他吗？', '## 1.url: \r\n要求为String类型的参数，（默认为当前页地址）发送请求的地址。\r\n\r\n## 2.type: \r\n要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。\r\n\r\n## 3.timeout: \r\n要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。\r\n\r\n## 4.async: \r\n要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\r\n\r\n## 5.cache: \r\n要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\r\n\r\n## 6.data: \r\n要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:\"bar1\",foo2:\"bar2\"}转换为&foo1=bar1&foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[\"bar1\",\"bar2\"]}转换为&foo=bar1&foo=bar2。\r\n\r\n## 7.dataType: \r\n要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：\r\nxml：返回XML文档，可用JQuery处理。\r\nhtml：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。\r\nscript：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。\r\njson：返回JSON数据。\r\njsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。\r\ntext：返回纯文本字符串。\r\n\r\n## 8.beforeSend：\r\n要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。\r\n```\r\nfunction(XMLHttpRequest){\r\n    this;   //调用本次ajax请求时传递的options参数\r\n}\r\n```\r\n## 9.complete：\r\n要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。\r\n```\r\nfunction(XMLHttpRequest, textStatus){\r\n     this;    //调用本次ajax请求时传递的options参数\r\n}\r\n```\r\n\r\n## 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。\r\n\r\n(1)由服务器返回，并根据dataType参数进行处理后的数据。\r\n\r\n(2)描述状态的字符串。\r\n```\r\nfunction(data, textStatus){\r\n    //data可能是xmlDoc、jsonObj、html、text等等\r\n    this;  //调用本次ajax请求时传递的options参数\r\n}\r\n```\r\n\r\n## 11.error:\r\n要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：\r\n```\r\nfunction(XMLHttpRequest, textStatus, errorThrown){\r\n    //通常情况下textStatus和errorThrown只有其中一个包含信息\r\n    this;   //调用本次ajax请求时传递的options参数\r\n}\r\n```\r\n\r\n## 12.contentType：\r\n要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为\"application/x-www-form-urlencoded\"。该默认值适合大多数应用场合。\r\n\r\n## 13.dataFilter：\r\n要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。\r\n```\r\nfunction(data, type){\r\n     //返回处理后的数据\r\n     return data;\r\n}\r\n```\r\n\r\n## 14.dataFilter：\r\n要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。\r\n```\r\nfunction(data, type){\r\n   //返回处理后的数据\r\n   return data;\r\n}\r\n```\r\n\r\n## 15.global：\r\n要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。\r\n\r\n## 16.ifModified：\r\n要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。\r\n\r\n## 17.jsonp：\r\n要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在\"callback=?\"这种GET或POST请求中URL参数里的\"callback\"部分，例如{jsonp:\'onJsonPLoad\'}会导致将\"onJsonPLoad=?\"传给服务器。\r\n\r\n## 18.username：\r\n要求为String类型的参数，用于响应HTTP访问认证请求的用户名。\r\n\r\n## 19.password：\r\n要求为String类型的参数，用于响应HTTP访问认证请求的密码。\r\n\r\n## 20.processData：\r\n要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型\"application/x-www-form-urlencoded\"。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。\r\n\r\n## 21.scriptCharset：\r\n\r\n要求为String类型的参数，只有当请求时dataType为\"jsonp\"或者\"script\"，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。\r\n\r\n标准写法：\r\n```\r\n$.ajax({\r\n    url:\"http://www.microsoft.com\",    //请求的url地址\r\n    dataType:\"json\",   //返回格式为json\r\n    async:true,//请求是否异步，默认为异步，这也是ajax重要特性\r\n    data:{\"id\":\"value\"},    //参数值\r\n    type:\"GET\",   //请求方式 get 或者post\r\n    beforeSend:function(){\r\n        //请求前的处理\r\n    },\r\n    success:function(req){\r\n        //请求成功时处理\r\n    },\r\n    complete:function(){\r\n        //请求完成的处理\r\n    },\r\n    error:function(){\r\n        //请求出错处理\r\n    }\r\n});\r\n \r\n \r\n \r\n$.getJSON(\"http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&tagmode=any&format=json&jsoncallback=?\",function(req){\r\n    $.each(req.items,function(i, item){\r\n        if(i == vnum){\r\n            $(\"<img src=\"\" + item.media.m + \"\" title=\"\" + item.title + \"\" />\").appendTo(\"#showjson\");\r\n        }\r\n    });\r\n});\r\n```', '1', '1', '2019-01-22 19:04:30', '2019-01-22 19:09:31');
INSERT INTO `posts` VALUES ('85', '3', '0-3', '2', 'iconv(): Detected an illegal character in input st', '$text = \"覃天卫强调，各级关工委要深刻领会习近平新时代中国特色社会主义思想和党的十九大精神，打牢新时代关心下一代的思想理论根基，立足新时代坐标思考谋划工作，聚焦新时代任务把准工作方向，根据新时代要求明确建设方向。要坚持以新思想为统领，奋力开创新时代全市关心下一代工作的工作局面，着眼于习近平新时代中国特色社会主义思想这一主线和灵魂，将其贯彻到新时代关心下一代工作全过程;着眼于党对青年一代的殷切期望，进一步激发广大“五老”投身关心下一代事业的积极性和热情;着眼于对我国社会主要矛盾做出的新判断，进一步提', '## 500 Internal Server Error\r\n### iconv(): Detected an illegal character in input string \r\n今天调用百度语言接口的时候\r\n\r\n却报iconv(): Detected an illegal character in input string这个错误\r\n\r\n## 先来解释一下什么是 iconv\r\n```\r\niconv ( string $in_charset , string $out_charset , string $str ) : string\r\n```\r\n\r\n对字符串str执行字符集转换，从in_charset到out_charset。\r\n```\r\niconv(\"UTF-8\", \"GBK//IGNORE\", $data);\r\n```\r\n任然报这个错误，最后：\r\n```\r\nmb_convert_encoding($data,\"GBK\",\"UTF-8\");\r\n```\r\n使用了这个方法，就好啦，\r\n\r\n## 现在说一下区别：\r\n1、PHP中利用ICONV转化字符串编码出错【DETECTED AN ILLEGAL CHARACTER IN INPUT STRING 】解决办法\r\n在php中利用iconv函数转化汉字字符串时提示如下错误：\r\n```\r\nNotice: iconv() [function.iconv]: Detected an illegal character in input string in a.php on line 796\r\n```\r\n### 出错的语句如下：\r\n```\r\niconv(\"GB2312\",\"UTF-8\",$a);\r\n```\r\n解决办法，将GB2312更改为GBK即可搞定：\r\n```\r\niconv(\"GBK\",\"UTF-8\",$a);\r\n```\r\n出现这个错误的原因是字符串$a中出现了超出gb2312范围的字符，所以iconv函数出错。因为gbk范围比gb3212范围广，又因为这两种格式的编码相同只是范围不同而已，故采用大范围的gbk来定义字符串能够包含比较多的字符，因此转化成功！\r\n\r\n2、数原型string iconv ( string $in_charset , string $out_charset , string $str )\r\n\r\n特别是第二个参数说明：\r\n```\r\nthe output charset.\r\n```\r\n用iconv()转换一个输出字符编码不支持的字符时，如iconv(\'utf-8\', \'gb2312\', \'www.111cn.net\')，会遇到这样的错误提示：\r\n```\r\nnotice: iconv() [function.iconv]: detected an illegal character in input string ...\r\n```\r\n因为gb2312表示的是简体中文，不支持像\"www.111cn.net\"之类的更为复杂的汉字以及一些特殊字符，这当然会报错了，解决办法有两种：\r\n\r\n1.扩大输出字符编码的范围，如iconv(\'utf-8\', \'gbk\', \'www.phpms.cn\')，则可以正确地输出，因为gbk支持的字符范围更广；\r\n\r\n2.在输出的字符编码字符串后面加上\"//ignore\"，如iconv(\'utf-8\', \'gb2312//ignore\', \'www.phpms.cn\')，这样做其实是忽略了不能转换的字符，避免了出错但却不能够正确地输出(即空白不、输出)。\r\n\r\n下面来看看关于php教程 iconv() : detected an illegal character in input string处理方法\r\n```\r\n$str = iconv(\'utf-8\', \'gbk//ignore\', unescape(isset($_get[\'str\'])? $_get[\'str\']:\'\'));\r\n```\r\n本地测试//ignore能忽略掉它不认识的字接着往下转，并且不报错，而//translit是截掉它不认识的字及其后面的内容，并且报错。//ignore是我需要的。\r\n\r\n3、转换字符串编码iconv与mb_convert_encoding的区别\r\n```\r\niconv — convert string to requested character encoding(php 4 >= 4.0.5, php 5)\r\nmb_convert_encoding — convert character encoding(php 4 >= 4.0.6, php 5)\r\n```\r\n\r\n## 用法：\r\n```\r\nstring mb_convert_encoding ( string str, string to_encoding [, mixed from_encoding] )\r\n```\r\n需要先启用 mbstring 扩展库，在 php.ini里将; \r\n\r\nextension=php_mbstring.dll 前面的 ; 去掉\r\n```\r\nstring iconv ( string in_charset, string out_charset, string str )\r\n```\r\n注意：\r\n\r\n第二个参数，除了可以指定要转化到的编码以外，还可以增加两个后缀：\r\n```\r\n//translit 和 //ignore，\r\n```\r\n其中：\r\n```\r\n//translit 会自动将不能直接转化的字符变成一个或多个近似的字符，\r\n//ignore 会忽略掉不能转化的字符，而默认效果是从第一个非法字符截断。\r\nreturns the converted string or false on failure.\r\n```\r\n使用：\r\n\r\n1. 发现iconv在转换字符\"-\"到gb2312时会出错，如果没有ignore参数，所有该字符后面的字符串都无法被保存。不管怎么样，这个\"-\"都无法转换成功，无法输出。另外mb_convert_encoding没有这个bug.\r\n\r\n2. mb_convert_encoding 可以指定多种输入编码，它会根据内容自动识别,但是执行效率比iconv差太多；如：\r\n```\r\n$str = mb_convert_encoding($str,\"euc-jp\",\"ascii,jis,euc-jp,sjis,utf- 8\");\r\n```\r\n“ascii,jis,euc-jp,sjis,utf-8”的顺序不同效果也有差异\r\n\r\n3. 一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数\r\n', '1', '1', '2019-01-22 19:17:37', '2019-01-22 19:31:26');
INSERT INTO `posts` VALUES ('86', '14', '0-14', '2', '0-企业应用架构模式（摘抄）', '30天挑战企业架构模式\r\n——选自：《企业应用架构模式》 [Patterns of Enterprise Application Architecture] [英] 福勒 著；王怀民，周斌 译\r\n人生的架构和企业也是类似的。', '—选自《企业应用架构模式》\r\n\r\n## 目 录\r\n\r\n1  [引言](#引言)\r\n\r\n 0.1 [架构](#架构)\r\n\r\n 0.2 [企业应用](#企业应用)\r\n\r\n 0.3 [企业应用的种类](#企业应用的种类)\r\n\r\n 0.4 [关于性能的考虑](#关于性能的考虑)\r\n\r\n 0.5 [模式](#模式)\r\n\r\n  0.5.1 [模式的结构](#模式的结构)\r\n\r\n  0.5.2 [模式的局限性](#模式的局限性)\r\n\r\n<div id=\"引言\" style=\"font-size: 28px;\r\n    font-weight: bold;\">引言</div>\r\n\r\n构建计算机系统并非易事。随着系统复杂性的增大，构建相应软件的难度将呈指数增大。同其他行业一样，我们只有在不断的学习中进步，从成功经验中学习，从失败教训中学习，才有望克服这些困难。本书的内容就是这样一些“学习”经验。我希望它们的撰写和编排方式，能够有助于读者更快地学习这些内容，并且，和我在总结出这些模式之前相比，能更有效地与他人进行交流。\r\n\r\n在引用中，我想设定本书讨论的范围，并提供一些相关的背景知识与材料。 \r\n\r\n<div id=\"架构\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.1架构</div>\r\n软件业的人乐于做这样的事——找一些词汇，并把它们引申到大量微妙而又互相矛盾的含义。一个最大的受害者就是“架构”（architecture）这个词。我个人对“架构”的感觉是，它是一个让人印象深刻的词，主要用来表示一些非常重要的东西。当然，我也会小心，不让这些对“系统结构”的“不恭之词”，影响到读者对本书的兴趣。\r\n\r\n很多人都试图给“架构”下定义，而这些定义本身却很难统一。能够统一的内容有两点：一点是“最高层次的系统分解”；另一点是“系统中不易改变的决定”。越来越多的人发现：表述一个系统架构的方法不只一种；一个系统中也可能有很多种不同的架构，而且，对于什么在架构上意义重大的看法也会随着系统的生命周期变化。\r\n\r\nRalph Johnson经常在邮件列表上发帖，并提出一些令人关注的见解。就在我完成本书初稿的同时，他又发表了一些关于“架构”的观点。他认为，架构是一种主观上的东西，是专家级项目开发人员对系统设计的一些可共享的理解。一般地，这种可共享的理解表现为系统中主要的组成部分以及这些组成间的交互关系。它还包括一些决定，开发者们希望这些决定能及早做出，因为在开发者看来它们是难以改变的。架构的主观性也来源于此——如果你发现某些决定并不像你想象的那么难以改变，那么它就不再与架构相关。到了最后，架构自然就浓缩成一些重要的东西，不论这些东西是什么。\r\n\r\n在本书中，我提出一些自己的理解，涉及企业应用主要组成部分和我希望能尽早做出的决定。在这些架构模式中，我最欣赏的就是“层次”，将在第1章中进行详细介绍。全书实际上就是关于如何将企业应用组织成不同的层次，以及这些层次之间如何协同工作。大多数重要的企业应用都是按照某种形式的层次分层设计的；当然，在某些情况下，别的设计方式（如管道方式、过滤器方式等）也有它们自己的价值。在本书中我们将不会讨论这些方式，而把注意力集中在层次方式上，因为它是应用最广的设计方式。\r\n\r\n本书中的一些模式毫无疑问是关于架构的，它们表示了企业应用各主要组成部分间的重要决定；另外一些模式是关于设计的，有助于架构的实现。我没有刻意区分这两类模式，因为正如我们前面讨论的，是否与架构相关往往带有主观性。\r\n\r\n<div id=\"企业应用\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.2企业应用</div>\r\n编写计算机软件的人很多，我们通常把这些活动都称为软件开发。但是软件的种类是不同的，每种软件都有自身的挑战性和复杂性。我是在与几个从事电信软件开发的朋友交谈后，意识到这个问题的。企业应用在某些方面要比电信软件简单得多——多线程问题没有那么困难，无需关注硬件设备与软件的集成。但是，在某些方面，企业应用又比电信软件复杂得多——企业应用一般都涉及到大量复杂数据，而且必须处理很多“不合逻辑”的业务规则。虽然有些模式是适合所有软件的，但是大多数模式都还只适合某些特定的领域和分支。\r\n\r\n我的工作主要是关于企业应用的，因此，这里所谈及的模式也都是关于企业应用的。（企业应用还有一些其他的说法，如“信息系统”或更早期的“数据处理”。）那么，这里的“企业应用”具体指的是什么呢？我无法给出一个精确的定义，但是我可以罗列一些个人的理解。\r\n\r\n先举几个例子。企业应用包括工资单、患者记录、发货跟踪、成本分析、信誉评估、保险、供应链、记账、客户服务以及外币交易等。企业应用不包括车辆加油、文字处理、电梯控制、化工厂控制器、电话交换机、操作系统、编译器以及电子游戏等。\r\n\r\n企业应用一般都涉及到持久化数据。数据必须持久化是因为程序的多次运行都需要用到它们——实际上，有些数据需要持久化若干年。在此期间，操作这些数据的程序往往会有很多变化。这些数据的生命周期往往比最初生成它们的那些硬件、操作系统和编译器还要长。在此期间，数据本身的结构一般也会被扩展，使得它在不影响已有信息的基础上，还能表示更多新信息。即使是有根本性的变化发生，或公司安装了一套全新的软件，这些数据也必须被“迁移”到这些全新的应用上。\r\n\r\n企业应用一般都涉及到大量数据——一个中等规模的系统往往都包含1GB以上的数据，这些数据是以百万条记录的方式存在的。巨大的数据量导致数据的管理成为系统的主要工作。早期的系统使用的是索引文件系统，如IBM的VSAM和ISAM。现代的系统往往采用数据库，绝大多数是关系型数据库。数据库的设计和演化已使其本身成为新的技术领域。\r\n\r\n企业应用一般还涉及到很多人同时访问数据。对于很多系统来说，人数可能在100人以下，但是对于一些基于Web的系统，人数会呈指数级增长。要确保这些人都能够正确地访问数据，就一定会存在这样或那样的问题。即使人数没有那么多，要确保两个人在同时操作同一数据项时不出现错误，也是存在问题的。事务管理工具可以处理这个问题，但是它通常无法做到对应用开发者透明。\r\n\r\n企业应用还涉及到大量操作数据的用户界面屏幕。有几百个用户界面是不足为奇的。用户使用频率的差异很大，他们也经常没什么技术背景。因此，为了不同的使用目的，数据需要很多种表现形式。系统一般都有很多批处理过程，当专注于强调用户交互的用例时，这些批处理过程很容易被忽视。\r\n\r\n企业应用很少独立存在，通常需要与散布在企业周围的其他企业应用集成。这些各式各样的系统是在不同时期，采用不同技术构建的，甚至连协作机制都不同：COBOL数据文件、CORBA系统或是消息系统。企业经常希望能用一种统一的通信技术来集成所有系统。当然，每次这样的集成工作几乎都很难真正实现，所有留下来的就是一个个风格各异的集成环境。当商业用户需要同其业务伙伴进行应用集成时，情况就更糟糕。\r\n\r\n即使是某个企业统一了集成技术，它们也还是会遇到业务过程中的差异以及数据中概念的不一致性。一个部分可能认为客户是当前签有协议的人；而另外一个部门可能还要将那些以前有合同，但现在已经没有了的人计算在内。再有，一个部门可能只关心产品销售而不关心服务销售。粗看起来，这些问题似乎容易解决，但是，一旦几百个记录中的每个字段都有可能存在着细微差别，问题的规模就会形成不小的挑战——就算唯一知道这些字段之间差别的员工还在公司任职（当然，也许他在你察觉到之前就早已辞职不干了）。这样，数据就必须被不停地读取、合并、然后写成各种不同语法和语义的格式。\r\n\r\n再接下来的问题是由“业务逻辑”带来的。我认为“业务逻辑”这个词很滑稽，因为很难找出什么东西比“业务逻辑”更加没有逻辑。当我们构建一个操作系统时，总是尽可能地使得系统中的各种事物符合逻辑。而业务逻辑生来就是那样的，没有相当的行政努力，不要想改变它，当然，它们都有自己的理由。你必须面对很多奇怪的条件。而且这些条件相互作用的方式也非常怪异。比如，某个销售人员为了签下其客户几百万美元的一张单，可能会在商务谈判中与对方达成协议，将该项目的年度到账时间推迟两天，因为这样才能与该客户的账务周期相吻合。成千上万的这类“一次特殊情况”最终导致了复杂的业务“无逻辑”，使得商业软件开发那么困难。在这种情况下，必须尽量将这些业务逻辑组织成有效的方式，因为我们可以确定的是，这些“逻辑”一定会随着时间不断变化。\r\n\r\n对于一些人来说，“企业应用”这个词指的是大型系统。但是 需要注意的是，并不是所有的企业应用都是大型的，尽管它们可能都为企业提供巨大的价值。很多人认为，由于小型系统的规模不大，可以不用太注意它们，而且在某种程度上，这种观点能够带来一定的成本节约。如果一个小型系统失败了，相对于大型系统的失败，这种失败就不会显得那么起眼了。但是，我认为这种思想没有对小型项目的累积作用给予足够的重视。试想，如果在小型项目上能够进行某些改善措施，那么一旦这些改善措施被成功运用于大型项目，它带来的效果就会非常大。实际上，最好是通过简化架构和过程，将一个大型项目简化成小型项目。\r\n\r\n<div id=\"企业应用的种类\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.3企业应用的种类</div>\r\n\r\n在我们讨论如何设计企业应用以及使用哪些模式之前，明确这样一个观点是非常重要的，即企业应用是多种多样的，不同的问题将导致不同的处理方法。如果有人说“总是这样做” 的时候，就应该敲响警钟了。我认为，设计中最具挑战性（也是我最感兴趣）的地方就是了解有哪些候选的设计方法以及各种不同设计方法之间的优劣比较。进行选择的控件很大，但我在这里只选三个方面。\r\n\r\n考虑一个B2C（Business to Customer）的网上零售商：人们通过浏览器浏览，通过购物车购买商品。通过购物车购买商品。这样一个系统必须能够应付大量的客户，因此，其解决方案不但要考虑到资源利用的有效性，还要考虑到系统的可伸缩性，以便在用户规模增大时能够通过增加硬件的办法加以解决。该系统的业务逻辑可以非常简单：获取订单，进行简单的价格计算和发货计算，给出发货信息。我们希望任何人都能够访问该系统，因此用户界面可以选用通用的Web表现方式，以支持各种不同的浏览器。数据源包括用来存放订单的数据库，还可能包括某种与库存系统的通信交流，以便获得商品的可用性信息和发货信息。\r\n\r\n再考虑一个租约合同自动处理系统。在某些方面，这样的系统比起前面介绍的B2C系统要简单，因为它的用户数很少（在特定时间内不会超过100个），但是它的业务逻辑却比较复杂。计算每个租约的月供，处理如提早解约和延迟付款这样的事件，签订合同时验证各种数据，这些都是非常复杂的任务，因为租约领域的许多竞争都是以过去的交易为基础稍加变化而出现的。正是因为规则的随意性很大，才使得像这样一个复杂领域具有挑战性。\r\n\r\n这样的系统在用户界面（UI）上也很复杂。这就要求HTML界面要能提供更丰富的功能和更复杂的屏幕，而这些要求往往是HTML界面目前无法达到的，需要更常规的胖客户界面。用户交互的复杂性还会带来事务行为的复杂性：签订租约可能要耗时1~2个小时，这期间用户要处于一个逻辑事务中。一个复杂的数据库设计方案中可能也会涉及到200多个表以及一些有关资产评估和计价的软件包。\r\n\r\n第三个例子是一家小型公司使用的简单的“开支跟踪系统”。这个系统的用户很少，功能简单，通过HTML表现方式可以很容易实现，涉及的数据源表项也不多。尽管如此，开发这样的系统也不是没有挑战。一方面你必须快速地开发出它，另一方面你又必须为它以后可能的发展考虑；也许以后会为它增加赔偿校验的功能，也许它会被集成到工资系统中，也许还要增加关于税务的功能，也许要为公司的CFO生成汇总报表，也许会被集成到一个航空订票Web Service中，等等。如果在这个系统的开发中，也试图使用前面两个例子中的一些架构，可能会影响开发进度。如果一个系统会带来业务效益（如所有的企业应用应该的那样），则系统进度延误同样也是开销。如果现在不做决策又有可能影响系统未来的发展。但是，如果现在就考虑了这些灵活性但是考虑不得当，额外的复杂性又可能会影响到系统的发展，进一步延误系统部署，减少系统的效益。虽然这类系统很小，但是一个企业中往往有很多这样的系统，这些系统的架构不良性累积起来，后果将会非常可怕。\r\n\r\n这三个企业应用的例子都有难点，而且难点各不相同。当然，也不可能有一个适合于三者的通用架构。选择架构时，必须很清楚地了解面临的问题，在理解的基础上再来选择合适的设计。本书中也没有一个通用的解决方案。实际上，很多模式仅仅是一些可选方案罢了。即使你选择了某种模式，也需要进一步根据面临的问题来修改模式。在构建企业应用时，你不思考是不行的。所有书本知识只是给你提供信息，作为你做决定的基础。\r\n\r\n模式是这样，工具也同样如此。在系统开发时应该选取尽可能少的工具，同时也要注意，不同的工具擅长处理的方面也不同，切记不要用错了工具，否则只会事倍功半。\r\n\r\n<div id=\"关于性能的考虑\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.4关于性能的考虑</div>\r\n很多架构的设计决策和性能有关。对于大多数与性能相关的问题，我的办法是首先建立系统，调试运行，然后通过基于测量的严格的优化过程来提高性能。但是，有一些架构上的决策对性能的影响，可能是后期优化难以弥补的。而且即使这种影响可以在后期很容易地弥补，参与这个项目的人们任然会从一开始就担心这些决策。\r\n\r\n在这样的一本书中讨论性能通常很困难。这是因为“眼见为实”：所有那些关于性能的条条框框，不在你的具体系统中配置运行一下，是很难有说服力的。我也经常看到一些设计方案因为性能方面的考虑而被接受或拒绝，但是一旦有人在真实的设置环境中做一些测量，就会证明这些考虑是错误的。\r\n\r\n本书将提出一些这方面的建议，包括尽量减少远程调用（它在很长时间内都被认为是优化性能的好建议）。尽管如此，还是建议读者在运用这些原则之前，在你的应用中具体试一试。同样，本书中的样例代码也有一些地方为了提高可读性而牺牲了效率。在你的系统中，需要自行决定是否进行优化。在做性能优化后，一定要与优化前进行测量对比，以确定真的得到了优化，否则，你可能只是破坏了代码的可读性。\r\n\r\n还有一个很重要的推论：配置上的重大变化会使得某些性能优化失效。因此，在升级虚拟机、硬件、数据库或其他东西到新的版本时，必须重新确认性能优化工作的有效性。很多情况下，配置变更都会对性能优化有影响，有时候你真的会发现，以前为了提升性能做的优化，在新环境下居然影响性能。\r\n\r\n关于性能的另一个问题是很多术语的使用不一致。最明显的例子就是“可伸缩性”（scalability），它可能有6-7种含义。下面我使用其中一些术语。\r\n\r\n响应时间是系统完成一次外部请求处理所需要的时间。这些外部请求可能是用户交互行为，例如按下一个按钮，或是服务器API调用。\r\n\r\n响应性不同于请求处理，它是系统响应请求的速度有多快。这个指标在许多系统里非常重要，因为对于一些系统而言，如果其响应性太慢，用户将难以忍受——尽管其响应时间可能不慢。如果在请求处理期间，系统一直处于等待状态，则系统的响应性和响应时间是相同的。然而，如果能够在处理真正完成之前就给用户一些信息表明系统已经接到请求，则响应性就会好一些。例如，在文件拷贝过程中，为用户提供一个“进度条”，将会提高用户界面的响应性，但并不会提高响应时间。\r\n\r\n等待时间是获得系统任何形式响应的最小时间，即使应该做的工作并不存在。通常它是远程系统中的大问题。假设我们让程序什么都不做，只是调用返回即可，则如果在本机上运行程序，一般都会立即得到响应。但是，如果在远程计算机上运行程序，情况就不一样，往往需要数秒的时间才能得到响应。因为从发出请求到得到响应的数秒时间主要用于排除使信息在线路上传输的困难。作为应用开发者，我经常对等待时间无能为力。这也是为什么要尽量避免远程调用的原因。\r\n\r\n吞吐率是给定时间内能够处理多大的请求量。如果考察的是文件拷贝，则吞吐率可以用每秒字节量来表示。对于企业应用来说，吞吐率通常用每秒事务数（tps）来度量。这种方法的一个问题是指标依赖于事务的复杂程度。对于特定系统的测试，应该选取普通的事务集合。\r\n\r\n在这里，性能或指吞吐率，或者指响应时间，由用户自己决定。当通过某种优化技术后，使得系统的吞吐率提高了，但是响应时间下降了，这时就不好说系统的性能提高了，最好用更准确的术语表示。从用户角度而言，响应性往往比响应时间更重要，因此，为了提高响应性而损失一些响应时间或者吞吐率是值得的。\r\n\r\n负载是关于系统当前负荷的表述，也许可以用当前有多少用户与系统相连来表示。负载有时也作为其他指标（如响应时间）的背景。因此，我们可以说：在10个用户的情况下，请求响应时间是0.5秒，在20个用户的情况下，请求响应时间是2秒。\r\n\r\n负载敏感度是指响应时间随负载变化的程度。假设：系统A在10~20个用户的情况下，请求响应时间都是0.5秒；系统B在10个用户的情况下，请求响应时间是0.2秒，在20个用户的情况下，请求响应时间上升到2秒。此时，系统A的负载敏感度比系统B低；我们还可以使用术语衰减（degradation），称系统B衰减得比系统A快。\r\n\r\n效率是性能除以资源。如果一个双CPU系统的性能是30tps，另一个系统有4个同样的CPU，性能是40tps，则前者效率高于后者。\r\n\r\n系统的容量是指最大有效负载或吞吐率的指标。它可以是一个绝对最大值或性能衰减至低于一个可接受的阈值之前的临界点。\r\n\r\n可伸缩性度量的是向系统中增加资源（通常是硬件）对系统性能的影响。一个可伸缩性的系统允许在增加了硬件后，能够有性能上的合理提高。例如，为了使吞吐率提高一倍，要增加多少服务器等。垂直可伸缩性或称垂直延展，通常指提高单个服务器的性能，例如增加内存。水平可伸缩性或称水平延展，通常指增加服务器的数目。\r\n\r\n问题是，设计决策对所有性能指标的作用并不相同。比如，某个服务器上运行着两个软件系统：Swordfish的容量是20tps，而Camel的容量是40tps。哪一个的性能更高？哪一个的可伸缩性好？仅凭这些数据，我们无法回答关于可伸缩性的问题，我们只能说Camel系统在单片机上的效率更高。假设又增加了一台服务器后，我们发现：Swordfish的容量是35tps，Camel的容量是50tps。尽管Camel的容量仍然大于Swordfish，但是后者在可伸缩性上却显得比前者更好。假设我们继续增加服务器数目后发现：Swordfish每增加一台服务器提高15tps，Camel每增加一台服务器提高10tps。在获得了这些数据后，我们才可以说，Swordfish的水平可伸缩性比Camel好，尽管Camel在5个服务器以下会有更好的效率。\r\n\r\n当构建企业应用系统时，关注硬件的可伸缩性往往比关注容量或效率更重要。如果需要，可伸缩性可以给予你获得更好性能的选择，可伸缩性也可以更容易实现。有时，设计人员费了九牛二虎之力才提高了少许容量，其开销还不如多买一些硬件。换句话说，假设Camel的费用比Swordfish高，高出的部分正好可以买几台服务器，那么选择Swordfish可能更合算，尽管你目前只需要40tps。现在人们经常抱怨软件对硬件的依赖性越来越大，有时为了运行某些软件就不得不对硬件进行升级，就像我一样，为了用最新版本的Word，就必须不断地升级笔记本电脑。但是总的来说，购买新硬件还是比修改旧软件来得便宜。同样，增加更多的服务器也比增加更多的程序员来得便宜——只要你的系统有足够的可伸缩性。\r\n\r\n<div id=\"模式\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.5模式</div>\r\n模式的概念早就有了。我在这里不想把这段历史重新演绎一遍。只是想简单谈谈我对模式和它们为什么是描述设计的重要手段的一些看法。\r\n\r\n模式没有统一的定义。可能最好的起点是Christopher Alexander给出的定义（这也是许多模式狂热者的灵感来源）：“每一个模式描述了一个在我们周围不断重复发生的问题以及该问题解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”[Alexander et al.]。尽管Alexander是建筑家，他谈论的是建筑模式，但其定义也能很好地适用于软件业。模式的核心就是特定的解决方案，它有效而且有足够的通用性，能解决重复出现的问题，模式的另一种视角是把它看成一组建议，而创造模式的艺术则是将很多建议分解开来，形成相互独立的组，在此基础上可以相对独立地讨论它们。\r\n\r\n模式的关键点是它们源于实践。必须观察人们的工作过程，发现其中好的设计，并找出“这些解决方案的核心”。这并不是一个简单的过程，但是一旦发现了某个模式，他将是非常有价值的。对于我来说，价值之一是能够撰写这样一本参考书。你不必通读本书的全部内容，也不必通读所有有关于模式的书。你只需要了解到这些模式都是干什么的，它们解决什么问题，它们是如何解决问题的，就足够了。这样，一旦碰到类似问题，就可以从书中找出相应的模式。那时，再深入了解相应的模式也不迟。\r\n\r\n一旦需要使用模式，就必须知道如何将它运用于当前的问题。使用模式的关键之一是不能盲目使用，这也是模式工具为什么都那么惨的原因。我认为模式是一种“半生不熟品”，为了用好它，还必须在自己的项目中把剩下的那一半“火候”补上。我本人每次在使用模式时，都会东改一点西改一点。因此你会多次看到同一解决方案，但没有一次是完全相同的。\r\n\r\n每个模式相对独立，但又不彼此孤立。有时候它们相互影响，如影随形。例如，如果在设计中使用了领域模型，那么经常还会用到类表继承。模式的边界本来也是模糊的，我在本书中也尽量让它们各自独立。如果有人说“使用工作单元”，你就可以直接去看工作单元这个模式如何使用，而不必阅读全书。\r\n\r\n如果你是一个有经验的企业应用设计师，也许会对大多数模式都很熟悉。希望本书不会给你带来太大的失望。（实际上我在前言里面已经提醒过了。）模式不是什么新鲜概念。因此，撰写模式书籍的作者们也不会声称我们“发明”了某某模式，而是说我们“发现”了某某模式。我们的职责是记录通用的解决方案，找出其核心，并把最终的模式记录下来。对于一个高级设计师，模式的价值并不在于它给予你一些新东西，而在于它能帮助你更好地交流。如果你和你的同事都明白什么是远程外观，你就可以这样非常简洁地交流大量信息：“这个类是一个远程外观模式。”也可以对新人说：“用数据传输对象模式来解决这个问题。”他们就可以查找本书来搞清楚如何做。模式为设计提供了一套词汇，这也是为什么模式的名字这么重要的原因。\r\n\r\n本书的大多数模式是用来解决企业应用的，基本模式一章（见第18章）则更通用一些。我把它们包含进来的原因是：在前面的讨论中，我引用了这些通用的模式。\r\n\r\n<div id=\"模式的结构\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.5.1模式的结构</div>\r\n每个作者都必须选择表达模式的形式。一些人采用的表达基于模式的一些经典教材如[Alexander et al.]、[Gang of Four]或[POSA]。另一些人用他们自己的方式。我在这个问题上也斟酌了很久。一方面我不想象GOF一样太精炼，另一方面我还要引用他们的东西。这就形成了本书的模式结构。\r\n\r\n第一部分是模式的名字。模式名非常重要，因为模式的目的之一就是为设计者们交流提供一组词汇。因此，如果我告诉你Web服务器是用前端控制器和转换试图构建的，而你又了解这些模式，那么你对我的Web服务器的架构就会非常清楚了。\r\n\r\n接下来的两部分是相关的：意图和概要。意图用一两句话总结模式；概要是模式的一种可视化表示，通常是（但不总是）一个UML图。这主要是想给模式一个简单的概况，以帮助记忆。如果你对模式已经“心知肚明”，只是不知道它的名字，那么模式的意图和概要这两部分就能为你提供足够的信息。\r\n\r\n接下来的部分描述了模式的动机。这可能不是该模式所能解决的唯一问题，但却是我认为最具代表性的问题。\r\n\r\n“运行机制”部分描述了解决方案。在这一部分，我会讨论一些实现问题以及我遇到的变化情况。我会尽可能独立于平台来讨论——也有一个部分是针对平台来讨论的，如果不感兴趣可以跳过这部分。为了便于解释，我用了一些UML图来辅助说明。\r\n\r\n“使用动机”部分描述了模式何时被使用。这部分讨论是使我选择该模式而不是其他模式的权衡考虑。本书中很多模式都可以相互替代，例如页面控制器和前端控制器可以相互替代。很少有什么模式是非它不可的。因此，每当我选择了一种模式之后，我总是问自己“你什么时候不用它？”这个问题也经常驱使我选择其他方案。\r\n\r\n“进一步阅读”部分给出了与该模式相关的其他读物。它并不完善。我只选择我认为有助于理解模式的参考文献，所以我去掉了对本书内容没有价值的任何讨论，当然其中也可能会遗漏一些我不知道的模式。我也没有提到一些我认为可能读者无法找到的参考文献，再就是一些不太稳定的Web链接。\r\n\r\n我喜欢为模式增加一个或几个例子。每个例子都非常简单，它们是用Java语言或C#语言编写的。我之所以选择两种语言，是因为它们可能是目前绝大多数专业程序员都能读懂的语言。必须注意，例子本身不是模式。当你使用模式时，不要想当然地认为它会和例子一样，也不要把例子看成某种形式的宏替换。我把例子编得尽量简单以突出其中模式相关的部分。当然，省略的部分并不是不重要，只是它们一般都特定于具体环境，这也是为什么模式在使用时一般都必须做适当调整的原因。\r\n\r\n为了尽量使例子简单但是又能够突出核心意思，我主要选择那些简单而又明确的例子，而不是那些来自于系统中的复杂例子。当然，在简单和过分之间掌握平衡是不容易的，但是我们必须记住：过分强调具体应用环境反而会增加模式的复杂性，使得模式的核心内容不易理解。\r\n\r\n这就是为什么我在选择例子时选取的是一些相互独立的例子而不是相互关联的例子的原因。独立的例子有助于对模式的理解。但是在如何将这些模式联合在一起使用上却支持不多。相互关联的例子则相反，它体现了模式间是如何相互作用的，但是对其中每个模式的理解却依赖于对其他所有模式的理解。理论上，是可以构造出既相互关联又相互独立的例子，但这是一项非常艰巨的工作——至少对于我来说是这样。因此，我选择了相互独立的例子。\r\n\r\n例子中的代码本身也主要用来增强对思想的理解。因此，在其他一些方面考虑可能不够——特别是错误处理，在这方面，我没有花费很多笔墨，因为到目前为止，我还没有得出错误处理方面的模式。在此，那些代码纯粹用来说明模式，而并不是用来显示如何对任何特定的业务问题进行建模。\r\n\r\n正是由于这些原因，我没有把这些代码放到我的网站上供大家下载。为了让那些基本的思想在应用设置下有所意义，本书的每个样例代码都充满着太多的“脚手架”来简化它们。\r\n\r\n并不是每个模式中都包含上面所述的各个部分。如果我不能想出很好的例子或动机等内容，我就会把相应部分省略。\r\n\r\n<div id=\"模式的局限性\" style=\"font-size: 28px;\r\n    font-weight: bold;\">0.5.2模式的局限性</div>\r\n正如我在前言中所述，对于企业应用开发而言，本书介绍的模式并不全面。我对本书的要求，不在于它是否全面，而在于它是否有用。模式这个领域太大了，单凭一个人的头脑是无法做到面面俱到的，更不用说是一本书了。\r\n\r\n本书中所列的模式都是我在具体领域中遇到的，但这并不表明我已经理解了每一个模式以及它们之间的关系。本书的内容只是反映了我在写书时的理解，在编写本书的过程中，我对相关内容的理解也不断发展和加深，当然，在本书发表之后，我仍然希望本人对模式的理解还能够继续发展。对于软件开发而言，有一点是可以肯定的，那是软件开发永远不会停止。\r\n\r\n当你使用模式时请记住：它们只是开始，而不是结束。任何作者去囊括项目开发中的所有变化和技术是不可能的。我编写本书的目的也只是作为一个开始，希望它能够把我自己的和我所了解的经验和教训传递给读者，你们可以在此基础上继续努力。请大家记住：所有模式都是不完备的，你们都有责任在自己的系统中完善它们，你们也会在这个过程中得到乐趣。\r\n\r\n \r\n——选自：《企业应用架构模式》 [Patterns of Enterprise Application Architecture] [英] 福勒 著；王怀民，周斌 译', '1', '1', '2019-01-22 20:58:00', '2019-01-22 21:24:03');
INSERT INTO `posts` VALUES ('87', '14', '0-14', '31', '01-企业应用架构模式--分层', 'Ralph Johnson说：\r\n架构是一种主观 的东西，是项目专家开发人员对系统设计的一种共同理解 。通常，共同理解是指系统包含哪些主要组件以及这些组件相互之间如何交互。Martin认为架构模式中最重要就是分层 。', '### 1. 分层优缺点：\r\n\r\n**1）优点：**\r\n\r\n1. 在无需过多了解其他层次的基础上，可以将某一层作为一个有机整体来理解；\r\n\r\n2. 可以替换某层的具体实现，只要前后提供的服务相同即可；\r\n\r\n3. 可以将层次间的依赖性减到最低；\r\n\r\n4. 分层有利于标准化工作；\r\n\r\n5. 一旦构建好了某一层次，就可以用它为很多上层服务提供支持\r\n\r\n**2）缺点：**\r\n\r\n1. 层次并不能封装所有东西，有时会带来级联修改；\r\n\r\n2. 过多层次会影响性能；\r\n\r\n3. 决定建立那些层次以及每一层的职责是什么难以决定\r\n\r\n\r\n## 2. 企业应用中层次的演化：\r\n```\r\nC/S（领域逻辑放在客户端） -> 领域逻辑放到数据库，作为存储过程 -> 三层架构：表现层 + 领域层 + 数据源层\r\n```\r\n\r\n## 3. 三个基本层次：\r\n\r\n**职责如下：**\r\n\r\n层次 | 职责  \r\n----|----\r\n表现层|提供服务，显示信息（例如在Windows或HTML页面中，处理用户请求（鼠标点击、键盘敲击等），HTTP请求，命令行调用，批处理API）\r\n领域层|逻辑，系统中真正的核心\r\n数据源层|与数据库，消息系统、事务管理器及其他软件包通信\r\n\r\n其中，领域层，也称为业务逻辑。它的相关工作：对表现层输入的数据进行验证，根据输入数据或已有数据进行计算，根据从表现层接收到的命令来确定应该调度那些数据源逻辑\r\n\r\n\r\n## 4. 为各层选择运行环境：\r\n1）运行环境：\r\n\r\n   - 1.数据源层：服务器\r\n\r\n   - 2.表现层：胖客户，客户端；web：服务器端 （只要可能就用web表现方式，只在必须的情况下才使用胖客户方式）\r\n\r\n   - 3.领域层：全部运行在服务器端，或者全部运行于客户端，如果必须要分离则至少保证相关的部分在一起\r\n\r\n2）一旦选择了处理节点，尽可能使所有代码保持在单一进程内完成（可能拷贝在集群中的多个节点上），否则不但损失性能，还会增加复杂性\r\n\r\n3）复杂性增压器：分布、显示多线程、范型差异（如对象/关系）、多平台开发以及极限性要求', '1', '1', '2019-01-23 21:12:30', '2019-01-23 21:28:27');
INSERT INTO `posts` VALUES ('88', '13', '0-13', '31', '周三打卡（012321）', '第一次有怀孕的感觉', '## 设计模式18种\r\nhttps://meiyoufan.com/wordpress_d9bc69abf500eca6/?cat=56\r\n\r\n## PHP常用的５种设计模式\r\nhttps://meiyoufan.com/wordpress_d9bc69abf500eca6/?p=829', '1', '1', '2019-01-23 21:38:36', '2019-01-23 21:42:15');
INSERT INTO `posts` VALUES ('89', '14', '0-14', '2', '02-企业应用架构模式-组织领域逻辑', '比较难理解，要反复看一看，多查查资料', '## 1. 模型抉择：\r\n#### 1）领域逻辑复杂度：\r\n　　![](/public/img/posts/zuzhilingyuluoji.jpg)\r\n\r\n#### 2）抉择：\r\n　　　　领域逻辑复杂度较低时，选择事物脚本；\r\n\r\n　　　　如果开发环境拥有大量基于记录集的工具（.Net和VS），可以选择表模块；\r\n\r\n　　　　开发小组经验丰富时，选择领域模型；\r\n\r\n　　　　3种模式并不互相排斥，可以同时使用\r\n\r\n## 2. 服务层：\r\n\r\n　　1）服务层是从领域层分离出来的，用于置于底层的领域模型或表模块之上\r\n\r\n　　2）服务层用于放置事物控制和安全等功能\r\n\r\n　　3）如果确实需要，服务层尽可能最小化（充当于一个Facade层）', '1', '1', '2019-01-24 13:57:14', '2019-01-24 14:28:48');
INSERT INTO `posts` VALUES ('90', '3', '0-3', '2', 'PSR-4的示例实现', 'PSR 不是PHP官方标准，而是从如Zend、Symfony2等知名PHP项目中提炼出来的一系列标准，目前有越来越多的社区项目加入并遵循该标准。\r\n\r\nPSR-0 自动加载 X已废弃\r\n\r\nPSR-1 基本代码规范\r\n\r\nPSR-2 代码样式\r\n\r\nPSR-3 日志接口\r\n\r\nPSR-4 如何指定文件路径从而自动加载类定义', 'PSR-4的示例实现\r\n================================\r\n\r\n以下示例说明了符合PSR-4的代码：\r\n\r\nClosure Example\r\n---------------\r\n\r\n~~~php\r\n<?php\r\n/**\r\n * An example of a project-specific implementation.\r\n *\r\n * After registering this autoload function with SPL, the following line\r\n * would cause the function to attempt to load the \\Foo\\Bar\\Baz\\Qux class\r\n * from /path/to/project/src/Baz/Qux.php:\r\n *\r\n *      new \\Foo\\Bar\\Baz\\Qux;\r\n *\r\n * @param string $class The fully-qualified class name.\r\n * @return void\r\n */\r\nspl_autoload_register(function ($class) {\r\n\r\n    // project-specific namespace prefix\r\n    $prefix = \'Foo\\\\Bar\\\\\';\r\n\r\n    // base directory for the namespace prefix\r\n    $base_dir = __DIR__ . \'/src/\';\r\n\r\n    // does the class use the namespace prefix?\r\n    $len = strlen($prefix);\r\n    if (strncmp($prefix, $class, $len) !== 0) {\r\n        // no, move to the next registered autoloader\r\n        return;\r\n    }\r\n\r\n    // get the relative class name\r\n    $relative_class = substr($class, $len);\r\n\r\n    // replace the namespace prefix with the base directory, replace namespace\r\n    // separators with directory separators in the relative class name, append\r\n    // with .php\r\n    $file = $base_dir . str_replace(\'\\\\\', \'/\', $relative_class) . \'.php\';\r\n\r\n    // if the file exists, require it\r\n    if (file_exists($file)) {\r\n        require $file;\r\n    }\r\n});\r\n~~~\r\n\r\nClass Example\r\n-------------\r\n\r\nThe following is an example class implementation to handle multiple\r\nnamespaces:\r\n\r\n~~~php\r\n<?php\r\nnamespace Example;\r\n\r\n/**\r\n * An example of a general-purpose implementation that includes the optional\r\n * functionality of allowing multiple base directories for a single namespace\r\n * prefix.\r\n *\r\n * Given a foo-bar package of classes in the file system at the following\r\n * paths ...\r\n *\r\n *     /path/to/packages/foo-bar/\r\n *         src/\r\n *             Baz.php             # Foo\\Bar\\Baz\r\n *             Qux/\r\n *                 Quux.php        # Foo\\Bar\\Qux\\Quux\r\n *         tests/\r\n *             BazTest.php         # Foo\\Bar\\BazTest\r\n *             Qux/\r\n *                 QuuxTest.php    # Foo\\Bar\\Qux\\QuuxTest\r\n *\r\n * ... add the path to the class files for the \\Foo\\Bar\\ namespace prefix\r\n * as follows:\r\n *\r\n *      <?php\r\n *      // instantiate the loader\r\n *      $loader = new \\Example\\Psr4AutoloaderClass;\r\n *\r\n *      // register the autoloader\r\n *      $loader->register();\r\n *\r\n *      // register the base directories for the namespace prefix\r\n *      $loader->addNamespace(\'Foo\\Bar\', \'/path/to/packages/foo-bar/src\');\r\n *      $loader->addNamespace(\'Foo\\Bar\', \'/path/to/packages/foo-bar/tests\');\r\n *\r\n * The following line would cause the autoloader to attempt to load the\r\n * \\Foo\\Bar\\Qux\\Quux class from /path/to/packages/foo-bar/src/Qux/Quux.php:\r\n *\r\n *      <?php\r\n *      new \\Foo\\Bar\\Qux\\Quux;\r\n *\r\n * The following line would cause the autoloader to attempt to load the\r\n * \\Foo\\Bar\\Qux\\QuuxTest class from /path/to/packages/foo-bar/tests/Qux/QuuxTest.php:\r\n *\r\n *      <?php\r\n *      new \\Foo\\Bar\\Qux\\QuuxTest;\r\n */\r\nclass Psr4AutoloaderClass\r\n{\r\n    /**\r\n     * An associative array where the key is a namespace prefix and the value\r\n     * is an array of base directories for classes in that namespace.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $prefixes = array();\r\n\r\n    /**\r\n     * Register loader with SPL autoloader stack.\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        spl_autoload_register(array($this, \'loadClass\'));\r\n    }\r\n\r\n    /**\r\n     * Adds a base directory for a namespace prefix.\r\n     *\r\n     * @param string $prefix The namespace prefix.\r\n     * @param string $base_dir A base directory for class files in the\r\n     * namespace.\r\n     * @param bool $prepend If true, prepend the base directory to the stack\r\n     * instead of appending it; this causes it to be searched first rather\r\n     * than last.\r\n     * @return void\r\n     */\r\n    public function addNamespace($prefix, $base_dir, $prepend = false)\r\n    {\r\n        // normalize namespace prefix\r\n        $prefix = trim($prefix, \'\\\\\') . \'\\\\\';\r\n\r\n        // normalize the base directory with a trailing separator\r\n        $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . \'/\';\r\n\r\n        // initialize the namespace prefix array\r\n        if (isset($this->prefixes[$prefix]) === false) {\r\n            $this->prefixes[$prefix] = array();\r\n        }\r\n\r\n        // retain the base directory for the namespace prefix\r\n        if ($prepend) {\r\n            array_unshift($this->prefixes[$prefix], $base_dir);\r\n        } else {\r\n            array_push($this->prefixes[$prefix], $base_dir);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the class file for a given class name.\r\n     *\r\n     * @param string $class The fully-qualified class name.\r\n     * @return mixed The mapped file name on success, or boolean false on\r\n     * failure.\r\n     */\r\n    public function loadClass($class)\r\n    {\r\n        // the current namespace prefix\r\n        $prefix = $class;\r\n\r\n        // work backwards through the namespace names of the fully-qualified\r\n        // class name to find a mapped file name\r\n        while (false !== $pos = strrpos($prefix, \'\\\\\')) {\r\n\r\n            // retain the trailing namespace separator in the prefix\r\n            $prefix = substr($class, 0, $pos + 1);\r\n\r\n            // the rest is the relative class name\r\n            $relative_class = substr($class, $pos + 1);\r\n\r\n            // try to load a mapped file for the prefix and relative class\r\n            $mapped_file = $this->loadMappedFile($prefix, $relative_class);\r\n            if ($mapped_file) {\r\n                return $mapped_file;\r\n            }\r\n\r\n            // remove the trailing namespace separator for the next iteration\r\n            // of strrpos()\r\n            $prefix = rtrim($prefix, \'\\\\\');\r\n        }\r\n\r\n        // never found a mapped file\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Load the mapped file for a namespace prefix and relative class.\r\n     *\r\n     * @param string $prefix The namespace prefix.\r\n     * @param string $relative_class The relative class name.\r\n     * @return mixed Boolean false if no mapped file can be loaded, or the\r\n     * name of the mapped file that was loaded.\r\n     */\r\n    protected function loadMappedFile($prefix, $relative_class)\r\n    {\r\n        // are there any base directories for this namespace prefix?\r\n        if (isset($this->prefixes[$prefix]) === false) {\r\n            return false;\r\n        }\r\n\r\n        // look through base directories for this namespace prefix\r\n        foreach ($this->prefixes[$prefix] as $base_dir) {\r\n\r\n            // replace the namespace prefix with the base directory,\r\n            // replace namespace separators with directory separators\r\n            // in the relative class name, append with .php\r\n            $file = $base_dir\r\n                  . str_replace(\'\\\\\', \'/\', $relative_class)\r\n                  . \'.php\';\r\n\r\n            // if the mapped file exists, require it\r\n            if ($this->requireFile($file)) {\r\n                // yes, we\'re done\r\n                return $file;\r\n            }\r\n        }\r\n\r\n        // never found it\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * If a file exists, require it from the file system.\r\n     *\r\n     * @param string $file The file to require.\r\n     * @return bool True if the file exists, false if not.\r\n     */\r\n    protected function requireFile($file)\r\n    {\r\n        if (file_exists($file)) {\r\n            require $file;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n~~~\r\n\r\n### Unit Tests\r\n\r\nThe following example is one way of unit testing the above class loader:\r\n\r\n~~~php\r\n<?php\r\nnamespace Example\\Tests;\r\n\r\nclass MockPsr4AutoloaderClass extends Psr4AutoloaderClass\r\n{\r\n    protected $files = array();\r\n\r\n    public function setFiles(array $files)\r\n    {\r\n        $this->files = $files;\r\n    }\r\n\r\n    protected function requireFile($file)\r\n    {\r\n        return in_array($file, $this->files);\r\n    }\r\n}\r\n\r\nclass Psr4AutoloaderClassTest extends \\PHPUnit_Framework_TestCase\r\n{\r\n    protected $loader;\r\n\r\n    protected function setUp()\r\n    {\r\n        $this->loader = new MockPsr4AutoloaderClass;\r\n\r\n        $this->loader->setFiles(array(\r\n            \'/vendor/foo.bar/src/ClassName.php\',\r\n            \'/vendor/foo.bar/src/DoomClassName.php\',\r\n            \'/vendor/foo.bar/tests/ClassNameTest.php\',\r\n            \'/vendor/foo.bardoom/src/ClassName.php\',\r\n            \'/vendor/foo.bar.baz.dib/src/ClassName.php\',\r\n            \'/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php\',\r\n        ));\r\n\r\n        $this->loader->addNamespace(\r\n            \'Foo\\Bar\',\r\n            \'/vendor/foo.bar/src\'\r\n        );\r\n\r\n        $this->loader->addNamespace(\r\n            \'Foo\\Bar\',\r\n            \'/vendor/foo.bar/tests\'\r\n        );\r\n\r\n        $this->loader->addNamespace(\r\n            \'Foo\\BarDoom\',\r\n            \'/vendor/foo.bardoom/src\'\r\n        );\r\n\r\n        $this->loader->addNamespace(\r\n            \'Foo\\Bar\\Baz\\Dib\',\r\n            \'/vendor/foo.bar.baz.dib/src\'\r\n        );\r\n\r\n        $this->loader->addNamespace(\r\n            \'Foo\\Bar\\Baz\\Dib\\Zim\\Gir\',\r\n            \'/vendor/foo.bar.baz.dib.zim.gir/src\'\r\n        );\r\n    }\r\n\r\n    public function testExistingFile()\r\n    {\r\n        $actual = $this->loader->loadClass(\'Foo\\Bar\\ClassName\');\r\n        $expect = \'/vendor/foo.bar/src/ClassName.php\';\r\n        $this->assertSame($expect, $actual);\r\n\r\n        $actual = $this->loader->loadClass(\'Foo\\Bar\\ClassNameTest\');\r\n        $expect = \'/vendor/foo.bar/tests/ClassNameTest.php\';\r\n        $this->assertSame($expect, $actual);\r\n    }\r\n\r\n    public function testMissingFile()\r\n    {\r\n        $actual = $this->loader->loadClass(\'No_Vendor\\No_Package\\NoClass\');\r\n        $this->assertFalse($actual);\r\n    }\r\n\r\n    public function testDeepFile()\r\n    {\r\n        $actual = $this->loader->loadClass(\'Foo\\Bar\\Baz\\Dib\\Zim\\Gir\\ClassName\');\r\n        $expect = \'/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php\';\r\n        $this->assertSame($expect, $actual);\r\n    }\r\n\r\n    public function testConfusion()\r\n    {\r\n        $actual = $this->loader->loadClass(\'Foo\\Bar\\DoomClassName\');\r\n        $expect = \'/vendor/foo.bar/src/DoomClassName.php\';\r\n        $this->assertSame($expect, $actual);\r\n\r\n        $actual = $this->loader->loadClass(\'Foo\\BarDoom\\ClassName\');\r\n        $expect = \'/vendor/foo.bardoom/src/ClassName.php\';\r\n        $this->assertSame($expect, $actual);\r\n    }\r\n}\r\n~~~\r\n', '1', '1', '2019-01-24 23:34:56', '2019-01-24 23:36:41');
INSERT INTO `posts` VALUES ('91', '4', '0-4', '2', 'Markdown 语法一 (示例 字体 字号 颜色)', '基本语法已经熟练，Mardown真的是编辑利器', '我就是看这篇文章入门的，感觉很不错，于是把精华部分整理一下，做一个备份，方便以后自己查看，同时也可以和大家分享\r\n\r\n[github牛人收集的Markdown信息](https://github.com/younghz/Markdown)\r\n\r\n[github本页面地址](https://github.com/wuxiumu/Markdown)\r\n\r\n## <a name=\"index\"/>目录</a>\r\n* [横线](#line)\r\n* [标题](#title)\r\n* [文本](#text)\r\n    * 普通文本\r\n    * 单行文本\r\n    * 多行文本\r\n    * 文字高亮\r\n* [链接](#link) \r\n    * 文字超链接\r\n        *  链接外部URL\r\n        *  链接本仓库里的URL\r\n    *  锚点\r\n    * [图片超链接](#piclink)\r\n* [图片](#pic)\r\n    * 来源于网络的图片\r\n    * GitHub仓库中的图片\r\n* [列表](#dot)\r\n    * 圆点列表\r\n    * 数字列表\r\n    * 复选框列表\r\n* [块引用](#blockquotes)\r\n* [代码](#code)\r\n* [表格](#table) \r\n* [表情](#emoji)\r\n\r\n## <a name=\"line\"/>横线</a>\r\n\r\n三个或更多-_*，必须单独一行，可含空格\r\n```\r\n***\r\n---\r\n___\r\n```\r\n\r\n\r\n## <a name=\"title\"/>标题</a>\r\n# 一级标题\r\n## 二级标题\r\n### 三级标题\r\n#### 四级标题\r\n##### 五级标题\r\n###### 六级标题\r\n\r\n## <a name=\"text\"/>显示文本</a>\r\n### 普通文本\r\n这是一段普通的文本\r\n#### 关于换行\r\n直接回车不能换行，<br>\r\n可以使用\\<br>。\r\n但是使用html标签就丧失了markdown的意义。  \r\n可以在上一行文本后面补两个空格，  \r\n这样下一行的文本就换行了。\r\n\r\n或者就是在两行文本直接加一个空行。\r\n\r\n也能实现换行效果，不过这个行间距有点大。\r\n### 单行文本\r\n    Hello,大家好，我是挨踢小子。\r\n### 文本块\r\n    欢迎到访\r\n    很高兴见到您\r\n    祝您，早上好，中午好，下午好，晚安\r\n### 部分文字高亮\r\nThank `You` . Please `Call` Me `Coder`\r\n#### 高亮功能更适合做一篇文章的tag\r\n例如:<br>\r\n`PHP` `网络编程` `Swoole` `企业应用`\r\n#### 删除线\r\n这是一个 ~~删除线~~\r\n#### 斜体\r\n*斜体1*\r\n\r\n_斜体2_\r\n#### 粗体\r\n**粗体1**\r\n\r\n__粗体2__\r\n\r\n#### 组合使用粗体、斜体和删除线\r\n***斜粗体1***\r\n\r\n___斜粗体2___\r\n\r\n***~~斜粗体删除线1~~***\r\n\r\n~~***斜粗体删除线2***~~\r\n\r\n#### 字体、字号、颜色\r\n```\r\n<font face=\"黑体\">我是黑体字</font>\r\n<font face=\"微软雅黑\">我是微软雅黑</font>\r\n<font face=\"STCAIYUN\">我是华文彩云</font>\r\n<font color=#0099ff size=12 face=\"黑体\">黑体</font>\r\n<font color=#00ffff size=3>null</font>\r\n<font color=gray size=5>gray</font>\r\n```\r\n<font face=\"黑体\">我是黑体字</font>\r\n\r\n<font face=\"微软雅黑\">我是微软雅黑</font>\r\n\r\n<font face=\"STCAIYUN\">我是华文彩云</font>\r\n\r\n<font color=#0099ff size=12 face=\"黑体\">黑体</font>\r\n\r\n<font color=#00ffff size=3>null</font>\r\n\r\n<font color=gray size=5>gray</font>\r\n\r\n\r\n## <a name=\"link\"/>链接</a>\r\n### 链接外部URL\r\n[我的博客](http://wuxiumu.github.io/knowledge/)   语法如下：\r\n```\r\n[我的博客](http://wuxiumu.github.io/knowledge/)\r\n```\r\n### 链接的另一种写法\r\n[我的博客][id]  \r\n\r\n[id]:http://wuxiumu.github.io/knowledge/  \r\n语法如下：\r\n```\r\n我的博客\r\n【id】:http://wuxiumu.github.io/knowledge/\r\n```\r\n中括号[ ]里的id，可以是数字，字母等的组合。这两行可以不连着写，**一般把第二行的链接统一放在文章末尾**，id上下对应就行了。这样正文看起来会比较干净。\r\n\r\n### 链接本仓库里的URL\r\n[Book](./Book)\r\n语法如下：\r\n```\r\n[Book](./Book)\r\n```\r\n如果文件要引用的文件不存在，则待点击的文本为红色。引用的文件存在存在则文本为蓝色。\r\n###锚点\r\n我们可以使用HTML的锚点标签（`#`）来设置锚点：[回到目录](#index)  \r\n但其实呢，每一个标题都是一个锚点，不需要用标签来指定，比如我们 [回到顶部](#TEST)\r\n不过不幸的是，由于对中文支持的不好，所以中文标题貌似是不能视作标签的。\r\n\r\n## <a name=\"pic\"/>显示图片</a>\r\n### 来源于网络的图片\r\n![baidu](http://www.baidu.com/img/bdlogo.gif \"百度logo\")\r\n![](http://ms.meiyoufan.com/public/img/posts/zuzhilingyuluoji.jpg)\r\n\r\n### GitHub仓库中的图片\r\n![](https://raw.githubusercontent.com/wuxiumu/wuxiumu.github.io/master/img/tag-bg.jpg)\r\n\r\n### <a name=\"piclink\">给图片加上超链接</a>\r\n#### 第一种\r\n\r\n[![head]](http://ms.meiyoufan.com/)\r\n[head]:http://ms.meiyoufan.com/public/img/dsgo.gif \"点击图片进入我的博客\"\r\n\r\n#### 第二种\r\n[![内容任意](http://www.baidu.com/img/bdlogo.gif \"百度logo\")](http://www.baidu.com)\r\n\r\n\r\n\r\n\r\n## <a name=\"dot\"/>列表</a>\r\n### 圆点列表\r\n* 昵称：挨踢小子\r\n* 别名：隔壁泰山\r\n* 英文名：Wuxiumu\r\n\r\n### 更多圆点\r\n* 编程语言\r\n    * 脚本语言\r\n        * Python\r\n\r\n### 数字列表\r\n#### 一般效果\r\n就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。    \r\n面向对象的三个基本特征：\r\n\r\n1. 封装\r\n2. 继承\r\n3. 多态\r\n\r\n#### 数字列表自动排序\r\n也可以在第一行指定`1. `，而接下来的几行用星号`*`（或者继续用数字1. ）就可以了，它会自动显示成2、3、4……。    \r\n面向对象的七大原则：\r\n\r\n1. 开闭原则\r\n* 里氏转换原则\r\n* 依赖倒转原则\r\n* 接口隔离原则\r\n* 组合/聚合复用原则\r\n* “迪米特”法则\r\n* 单一直则原则\r\n\r\n#### 多级数字列表\r\n和圆点的列表一样，数字列表也有多级结构：  \r\n\r\n1. 这是一级的数字列表，数字1还是1\r\n   1. 这是二级的数字列表，阿拉伯数字在显示的时候变成了罗马数字\r\n      1. 这是三级的数字列表，数字在显示的时候变成了英文字母\r\n	    1. 四级的数字列表显示效果，就不再变化了，依旧是英文字母\r\n\r\n### 复选框列表\r\n\r\n- [x] C\r\n- [x] C++\r\n- [x] Java\r\n- [x] Qt\r\n- [x] Android\r\n- [ ] C#\r\n- [ ] .NET\r\n\r\n您可以使用这个功能来标注某个项目各项任务的完成情况。\r\n## <a name=\"blockquotes\"/>块引用</a>\r\n\r\n### 常用于引用文本\r\n#### 文本摘自《深入理解计算机系统》P27\r\n　令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。\r\n><b>“端”（endian）的起源</b><br>\r\n以下是Jonathan Swift在1726年关于大小端之争历史的描述：<br>\r\n“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。”\r\n\r\n### 块引用有多级结构\r\n>数据结构\r\n>>树\r\n>>>二叉树\r\n>>>>平衡二叉树\r\n>>>>>满二叉树\r\n\r\n## <a name=\"code\"/>代码高亮</a>\r\n```Java\r\npublic static void main(String[]args){} //Java\r\n```\r\n```c\r\nint main(int argc, char *argv[]) //C\r\n```\r\n```Bash\r\necho \"hello GitHub\"#Bash\r\n```\r\n```javascript\r\ndocument.getElementById(\"myH1\").innerHTML=\"Welcome to my Homepage\"; //javascipt\r\n```\r\n```cpp\r\nstring &operator+(const string& A,const string& B) //cpp\r\n```\r\n## <a name=\"table\"/>显示表格</a>\r\n表头1  | 表头2\r\n------------- | -------------\r\nContent Cell  | Content Cell\r\nContent Cell  | Content Cell\r\n\r\n| 表头1  | 表头2|\r\n| ------------- | ------------- |\r\n| Content Cell  | Content Cell  |\r\n| Content Cell  | Content Cell  |\r\n\r\n| 名字 | 描述          |\r\n| ------------- | ----------- |\r\n| Help      | Display the help window.|\r\n| Close     | Closes a window     |\r\n\r\n表格中也可以使用普通文本的删除线，斜体等效果\r\n\r\n| 名字 | 描述          |\r\n| ------------- | ----------- |\r\n| Help      | ~~Display the~~ help window.|\r\n| Close     | _Closes_ a window     |\r\n\r\n表格可以指定对齐方式\r\n\r\n| 左对齐 | 居中  | 右对齐 |\r\n| :------------ |:---------------:| -----:|\r\n| col 3 is      | some wordy text | $1600 |\r\n| col 2 is      | centered        |   $12 |\r\n| zebra stripes | are neat        |    $1 |\r\n\r\n表格中嵌入图片\r\n\r\n| 图片 | 描述 |\r\n| ---- | ---- |\r\n![baidu](http://www.baidu.com/img/bdlogo.gif \"百度logo\") | baidu\r\n\r\n##<a name=\"emoji\"/>添加表情</a>\r\nGithub的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。\r\n\r\n比如`:blush:`，可以显示:blush:。\r\n\r\n具体每一个表情的符号码，可以查询GitHub的官方网页[http://www.emoji-cheat-sheet.com](http://www.emoji-cheat-sheet.com)。\r\n\r\n', '1', '1', '2019-01-24 23:37:45', '2019-01-25 00:40:08');
INSERT INTO `posts` VALUES ('92', '13', '0-13', '2', '周四打卡（012523）', '感觉时间怎么那么不够用呢', '## PSR-4的示例实现\r\nhttp://ms.meiyoufan.com/index.php/index/postinfo/id/90\r\n## 企业应用架构模式-组织领域逻辑\r\nhttp://ms.meiyoufan.com/index.php/index/postinfo/id/89\r\n## Markdown 语法一\r\nhttp://ms.meiyoufan.com/index.php/index/postinfo/id/91', '1', '1', '2019-01-24 23:25:00', '2019-01-24 16:44:16');
INSERT INTO `posts` VALUES ('93', '14', '0-14', '2', '03-企业应用架构模式-映射到关系数据库', '我目前个人的看法就是，关系数据库是架构的核心', '关系数据库之所以取得成功，最重要的原因之一就是SQL的存在，它是数据库通信标准语言。\r\n\r\n## 1. 架构模式：\r\n#### 驱动领域逻辑访问数据的方式：\r\n\r\n#### SQL语句嵌入在程序设计语言中；\r\n\r\n#### 行数据入口、表数据入口：\r\n把SQL访问从领域逻辑中分离出来，并把它放到独立的类中（让它们以数据库中的表结构为基础，每一个数据表对应一个类），这些类为数据库建立了一个入口；\r\n\r\n#### 活动记录：\r\n领域模型简单时，每个领域对象负责对应数据库的表的存取过程\r\n\r\n#### 数据映射器：\r\n领域模型复杂时，处理数据库和领域模型之间的所有存取操作，并且允许双方都能独立变化\r\n\r\n#### 面向对象数据库：\r\n领域模型不管有多复杂，均可使用（因为风险，使用不多）。主要好处在于能够提高生产率！\r\n\r\n## 2. 行为问题：\r\n### 1）所谓行文问题，就是如何让个中对象从数据库中读取出来以及存到数据库中\r\n\r\n### 2）工作单元：\r\n充当数据库映射的控制器，会跟踪所有从数据库中读取的对象以及所有以任何形式修改过的对象，并将更新提交到数据库（用来解决内存对象和数据库中数据同步的问题）\r\n\r\n### 3）标识映射：\r\n在标识映射里记录读取的每一行，防止同一对象重复加载\r\n\r\n### 4）延迟加载：\r\n减少领域模型每次读取的数据\r\n\r\n## 3. 读取数据：\r\n### 1）查找器：\r\n读取数据的时候，可以把读取数据的方法看做一个查找器\r\n### 2）查找器对象：\r\n如果数据库交互类基于表，把插入和更新操作也绑定在查找器方法中；\r\n\r\n如果数据库交互基于行的类，创建独立的查找器对象（每个查找器类都有很多封装了SQL语句的方法，当执行查询操作时查找器对象返回一个适当的基于行的对象集合）\r\n### 3）读取数据性能经验法则：\r\n如果需要，尽量一次读取多行；\r\n\r\n需要多个表数据时，使用Join\r\n\r\n## 4. 结构映射模式：\r\n### 1）关系的映射：\r\n\r\n#### 解决关系表间关联关系和对象间引用关系的方法：\r\n通过对象中的一个标识域来保持每个对象的关系特性，并且通过查找这些值来保持对象引用和关系键之间的相互映射\r\n\r\n对于一些小的值对象（比如日期范围和钱），不需要用标识域来把对象间引用变为外键（不应该描述成数据库中它们自己的表），而应去除值对象中所有的域，以嵌入值方式把它们嵌入到关联对象中\r\n\r\n也可以通过序列化LOB将一组对象存储为表中的单个列\r\n### 2）继承：\r\n#### 单表继承：\r\n为继承体系层次中的所有类建立一个表（修改容易并且避免join，但每一行都必须为每种可能地子类博阿六一些列，浪费空间）\r\n#### 具体表继承：\r\n为继承体系层次中每个具体类均建立一个表（避免join操作，允许从一个表中获取一个对象，但改变起来比较困难，如对超类的任何改变都不得不改变所有的表和映射代码）\r\n\r\n#### 类表继承：\r\n为继承体系层次中每个类均建立一个表（需要多个join操作来载入一个对象，通常\r\n会损失性能）\r\n\r\n以上3种模式，需要考虑自己的环境和偏好（Martin倾向于：使用单表继承，用另外2个模式辅助来帮助解决不可避免的不相关和无用列问题）\r\n\r\n\r\n## 5. 建立映射：\r\n### 自己选择数据库方案：\r\n使用经典数据库设计技术围绕数据来设计表，使用行数据入口或者表数据入口把SQL从领域逻辑中剔除\r\n### 使用已存在数据库方案：\r\n简单的领域逻辑可创建行数据入口或者表数据入口类来模拟数据库，并在此之上创建领域逻辑。复杂的逐步建立领域模型并包含数据映射器\r\n### 对于多个数据源：\r\n建立多个映射层，每个数据源一个。 如果数据非常类似，可把数据从内存方案中转化到逻辑数据存储方案，映射从逻辑数据存储方案到实际物理存储方案（第二部包含区别）\r\n\r\n\r\n## 6. 使用元数据：\r\n元数据映射基于把映射浓缩到元数据文件的方法。元数据文件详细描述数据库中列如何映射到对象的域。如：\r\n![](/public/img/posts/syysj.png)\r\n\r\n## 7. 数据库连接：\r\n数据库连接池\r\n\r\n## 8. 其他问题：\r\n\r\nselect * from 的问题\r\n\r\n多使用预编译好的静态SQL\r\n\r\n', '1', '1', '2019-01-25 22:01:23', '2019-01-25 22:22:11');
INSERT INTO `posts` VALUES ('94', '3', '0-3', '2', ' docker部署httpd+php7.1', '/**仅记录自己的学习历程，为以后的自己留一个参考**/\r\ndocker更新的速度很快，一定要保持对新鲜事物的好奇心', '## 1 获取httpd环境docker镜像\r\n\r\n由于本人对CentOS环境比较熟悉，故不使用docker官方的httpd镜像，使用centos的httpd镜像：\r\n```\r\nsudo docker pull centos/httpd\r\n```\r\n\r\n## 2 创建并启动容器\r\n\r\n创建两个文件夹用于放置前后端代码和httpd日志：\r\n```\r\nsudo mkdir -p /docker/httpd/html\r\nsudo mkdir -p /docker/httpd/logs\r\n``` \r\n生成容器：\r\n```\r\nsudo docker run --name httpd -d --restart always -p 80:80 -p 443:443 -v /docker/httpd/html:/var/www/html -v /docker/httpd/logs:/etc/httpd/logs centos/httpd\r\n```\r\n其中，\r\n\r\n--name httpd：容器指定名称为mysql；\r\n\r\n-d：后台运行容器，并返回容器ID；\r\n\r\n--restart always：在容器退出时总是重启容器；\r\n\r\n-p 80:80 -p 443:443：将宿主机的80、443端口（前者）分别映射到容器的80、443端口（后者）；\r\n\r\n-v /docker/httpd/html:/var/www/html：将宿主机的目录/docker/httpd/html映射到容器的目录/var/www/html，用于存放前后端代码文件；\r\n\r\n-v /docker/httpd/logs:/etc/httpd/logs：将宿主机的目录/docker/httpd/logs映射到容器的目录/etc/httpd/logs，用于存放httpd产生的日志文件。\r\n\r\n此时在浏览器访问宿主机，即可看到Apache的环境界面，在宿主机目录/docker/httpd/html下部署上前后端的代码，即可访问了。\r\n\r\n## 3 在容器中部署php7.1环境\r\n\r\n本人图方便，使用yum来安装php。\r\n\r\n由于CentOS官方源的php版本太旧，故先配置yum源：\r\n```\r\nsudo docker exec httpd yum install -y epel-release\r\nsudo docker exec httpd rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm\r\nsudo docker exec httpd yum update -y\r\n```\r\n\r\n若以后需要自行编译PHP的扩展（如连接redis、mongodb的扩展），则最好安装如下包：\r\n```\r\nsudo docker exec httpd yum install -y gcc make openssl openssl-devel\r\n```\r\n\r\n安装PHP 7.1及常用的扩展：\r\n```\r\nsudo docker exec httpd yum install -y --enablerepo=remi --enablerepo=remi-php71 php php-devel php-mbstring php-mcrypt php-mysqlnd php-pdo php-gd\r\n```\r\n清理一下yum缓存：\r\n```\r\nsudo docker exec httpd yum clean all\r\nsudo docker exec httpd rm -rf /var/cache/yum\r\n```\r\n\r\n## 4 查看phpinfo\r\n\r\n先重启httpd服务，有两种方式：\r\n\r\n(1) 直接重启容器（推荐）：\r\n```\r\nsudo docker restart httpd\r\n```\r\n\r\n(2) 重启容器的httpd服务：\r\n```\r\nsudo docker exec httpd httpd -k restart\r\n```\r\n在宿主机目录/docker/httpd/html下新建文件index.php，内容如下：\r\n```\r\n<?php\r\n    phpinfo();\r\n```\r\n浏览器访问宿主机，即可看到PHP环境部署成功了： \r\n\r\n## 5 保存容器为镜像\r\n\r\n部署完成后，可以将容器创建为镜像，留待以后可以方便地创建httpd+php环境的容器：\r\n```\r\nsudo docker stop httpd\r\nsudo docker commit -m \"centos httpd+php7.1\" httpd httpd-php71:1.0\r\n```\r\n可以看到有一个新的镜像了： \r\n \r\n仿照步骤2，即可直接创建一个部署了httpd和php7.1环境的docker容器了：\r\n\r\n```\r\nsudo docker run --name httpd-php71 -d --restart always -p 80:80 -p 443:443 -v /docker/httpd/html:/var/www/html -v /docker/httpd/logs:/etc/httpd/logs httpd-php71:1.0\r\n```', '1', '1', '2019-01-26 13:04:52', '2019-01-26 13:22:17');
INSERT INTO `posts` VALUES ('95', '3', '0-3', '2', 'docker部署mysql服务', '每一次搭建mysql服务，都感觉自己懂得太少了。', '## 1 获取mysql官方最新docker镜像\r\n```\r\nsudo docker pull mysql:5.7\r\n```\r\n耐心等待下载，完成后可以通过以下命令查看下载的镜像：\r\n```\r\nsudo docker images\r\n```\r\n\r\n## 2 创建并启动mysql服务容器\r\n\r\n### 2.1 创建一个文件夹用于挂载mysql数据库文件\r\n```\r\nsudo mkdir /docker/mysql_data -p\r\n```\r\n\r\n### 2.2 生成mysql容器\r\n```\r\nsudo docker run --name mysql -d --restart always -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /docker/mysql_data:/var/lib/mysql mysql:5.7\r\n```\r\n其中，\r\n\r\n--name mysql：容器指定名称为mysql；\r\n\r\n-d：后台运行容器，并返回容器ID；\r\n\r\n--restart always：在容器退出时总是重启容器；\r\n\r\n-p 3306:3306：将宿主机的3306端口（前者）映射到容器的3306端口（后者）；\r\n\r\n-e MYSQL_ROOT_PASSWORD=123456：设置mysql的root密码为123456；\r\n\r\n-v /docker/mysql_data:/var/lib/mysql：将宿主机的目录/docker/mysql_data映射到容器的目录/var/lib/mysql，用于存放容器的mysql数据库文件。\r\n\r\n### 2.3 查看容器启动状态\r\n\r\n查看已经创建的容器：\r\n```\r\nsudo docker ps -a\r\n```\r\n查看已经启动的容器：\r\n```\r\nsudo docker ps -s\r\n```\r\n若容器未启动，则通过以下命令启动：\r\n```\r\nsudo docker start mysql\r\n```\r\n其中mysql是容器名称，也可以使用CONTAINER \r\n\r\n### 2.4 docker容器下命令行连接mysql数据库\r\n\r\n首先进入mysql容器的bash终端：\r\n```\r\nsudo docker exec -it mysql bash\r\n```\r\n连接mysql：\r\n```\r\nmysql -u root -p\r\n```\r\n输入步骤2.2设置的mysql root密码，之后就可以自由操作mysql了！\r\n\r\n### 2.5 通过宿主机命令行连接mysql\r\n\r\n首先在宿主机上安装mysql客户端：\r\n```\r\nsudo apt-get install -y mysql-client\r\n```\r\n尝试连接：\r\n```\r\nmysql -h 127.0.0.1 -u root -p\r\n```\r\n>Enter password: 123456', '1', '1', '2019-01-26 13:25:14', '2019-01-26 13:35:39');
INSERT INTO `posts` VALUES ('96', '3', '0-3', '2', 'Centos中安装python3.7 解决pip和yum问题', '最烦人的就是软件适配，这是新软件时代的特性，不升级你就OUT 啦', '## 首先不要让历史成为负担\r\n\r\n### 1、删除现有Python\r\n```\r\n[root@test ~]# rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps ##强制删除已安装程序及其关联\r\n[root@test ~]# whereis python |xargs rm -frv ##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令\r\n[root@test ~]# whereis python ##验证删除，返回无结果\r\n```\r\n### 2、删除现有的yum\r\n```\r\n[root@test ~]# rpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps\r\n[root@test ~]# whereis yum |xargs rm -frv\r\n```\r\n\r\n## 在先安装依赖包：\r\n```\r\nyum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make\r\n```\r\ncd到一个你想放在的地方，哪里都可以。接着找到python3.7的安装包：\r\n```\r\nwget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz\r\n```\r\n现在这个.tgz文件就下载到了你现在目录中，接着解压：\r\n```\r\ntar -zxvf Python-3.7.0.tgz\r\n```\r\n然后此目录下就多出了一个解压后的文件Python-3.7.0，下面进入文件夹中：\r\n```\r\ncd Python-3.7.0\r\n./configure\r\n```\r\n```\r\nmake&&make install\r\n```\r\n执行完make&&make install之后，可能会出现这种报错：\r\n```\r\n“ModuleNotFound：No module named \'_ctypes\'”\r\n```\r\n这里需要执行：\r\n```\r\nyum install libffi-devel -y\r\n```\r\n执行完继续\r\n```\r\nmake&&make install\r\n```\r\n这样，基本上python3.7我们就安装完成了，默认情况下，python3.7安装在/usr/local/bin/，这里为了使默认python变成python3，需要加一条软链接\r\n```\r\nln -s /usr/local/bin/python3.7 /usr/bin/python\r\n```', '1', '1', '2019-01-26 17:04:39', '2019-01-26 17:13:09');
INSERT INTO `posts` VALUES ('97', '14', '0-14', '40', '04-企业应用架构模式-WEB表现层', 'WEB表现层，常用的模式就是MVC', '## 构建web服务器上应用程序的2种方法：\r\n### 1）使用脚本：\r\nCGI、Java Servlet，通过write stream操作输出字符串；适合于解释请求消息\r\n### 2）使用服务器页面：\r\n把程序和返回文本也组合在一起，在html中编写返回页面（Asp、php、jsp等）；适合于格式化应答消息\r\n\r\n## 1. 视图模式：\r\n### 1）转换视图：\r\n特点：使用程序的一种转换风格（如XSLT)	\r\n### 2）模板视图：\r\n#### 特点：\r\n允许你在网页结构中编写表现层，并允许在网页中嵌入标签，用以知名网页中动态内容需要导向到哪里（如ASP、JSP、PHP等）\r\n　　　　\r\n#### 优点：\r\n提供强大功能、灵活\r\n　　　　\r\n#### 缺点：\r\n代码混乱以至于难以维护\r\n\r\n### 3）两步视图:\r\n2个阶段：由领域数据产生一个逻辑屏幕，然后把它发送到html网页中。（每一个屏幕都有一个第一阶段的视图，而整个程序中只有一个第二阶段的视图）\r\n\r\n优点：它可以决定把什么样的html网页用在一个地方，全局改变html变得容易\r\n\r\n缺点：当站点设计得过分精细时，通常不容易提取出很好的逻辑屏幕结构\r\n\r\n## 2. 输入控制器模式：\r\n### 1）输入控制器2个责任：\r\n处理http的请求消息；\r\n\r\n根据请求的消息来决定下一步做什么 \r\n### 2）2个模式：\r\n为每个页面准备一个输入控制器，输入控制器再创建适当的对象来完成处理，并实例化适当的视图来返回结果；\r\n\r\n单个对象处理所有请求消息，创建一个分离的对象来处理它（前端控制器）。【当站点行为结构有所改变时，可以避免重新配置web服务器】', '1', '1', '2019-01-26 21:36:32', '2019-01-26 21:42:11');
INSERT INTO `posts` VALUES ('98', '14', '0-14', '2', '05-企业应用架构模式-并发', '软件性能的瓶颈', '离线并发：多个数据库事务中支持多线程的各种应用服务器\r\n\r\n\r\n## 1. 并发问题：\r\n### 1）丢失更新（同时编辑文件，相继保存，最终丢失先保存者更新的内容）\r\n### 2）不一致性（读取期间，数据有更新）\r\n\r\n## 2. 执行语境：\r\n### 1）从与外界交互角度看的2个语境：\r\n请求：\r\n\r\n对应于软件工作的外部环境发出的单个调用，处理请求的软件会决定是否返回一个应答（过程大部分是在服务器端进行，而客户端则假设为在等待应答）\r\n\r\n会话：\r\n\r\n客户端和服务器端之间一次长时间的交互\r\n### 2）操作系统的2个语境：\r\n#### 进程：\r\n\r\n重量级的执行语境，将其正在处理的内部数据域外部隔离开（有效隔离，减少冲突，但需要消耗很多资源）\r\n\r\n#### 线程：\r\n\r\n轻量级的执行语境，一个单独的进程里可以存在多个线程（可以充分利用资源，但易导致并发问题）\r\n\r\n## 3. 隔离与不变性：\r\n企业应用2个解决方案：\r\n### 1）隔离：\r\n#### 方案1：\r\n\r\n划分数据，使得每一个片数据都只能被一个执行单元访问（操作系统为每个进程单独分配一片内存，并且只有这个进程可以对这片内存进行读写操作）\r\n\r\n#### 方案2：\r\n\r\n文件锁，一个人打开文件，其他人再无法打开或者只打开该文件只读拷贝并且不能修改（好的并发设计应该是：找到各种创建隔离区的办法，并且保证在每个隔离区里能够完成尽可能多的任务）\r\n### 2）不变性：\r\n#### 方案1：\r\n\r\n识别哪些是不变的数据（只有在共享数据可以修改的情况下，并发问题才会出现），不用考虑这些数据的并发问题二广泛地共享它们\r\n\r\n#### 方案2：\r\n\r\n把那些只读取数据的程序分开，让他们只是用拷贝的数据源\r\n\r\n## 4. 乐观并发控制和悲观并发控制：\r\n### 1）2种锁：\r\n#### 乐观锁：\r\n\r\n关于冲突检测的（仅当提交更新时才检查冲突）\r\n\r\n优点：并发性高，限制较少，使用起来比较自由\r\n\r\n缺点：业务数据比较复杂，难以自动合并，并且使用者难以发现差别时，只能丢弃原有数据，从头开始更新\r\n\r\n#### 悲观锁：\r\n\r\n关于冲突避免的（只要有人已是用当前数据或者文件，拒绝其他人使用当前数据或文件）\r\n\r\n优点：减少并发程度\r\n\r\n缺点：用户体验差\r\n\r\n两种策略选择标准：冲突的频率与严重性（冲突少或者冲突后果不严重时，选择乐观锁；否则选择悲观锁）\r\n### 2）避免不一致性：\r\n\r\n#### a. 检测不一致读：\r\n\r\n##### 悲观策略：\r\n\r\n通过读加锁（read lock，共享锁）和写加锁（write lock，排他锁），可以一次多个人对同一份数据加只读锁，但只要有人得到一个只读锁，其他人就都无法得到写锁；一旦有人得到一个写锁，其他人都不能得到两种所中任意一种\r\n\r\n\r\n##### 乐观策略：\r\n基于数据的某种版本标识（时间戳或者顺序计数器），核对将要更新数据的版本标识和共享数据的版本标识，如果两者一样，系统允许更新数据并更新共享数据的版本标识\r\n\r\n#### b. 时序读：\r\n\r\n每次读取数据时都是用某种时间戳或其他不变的标签作为约束条件，数据库根据时间或者标签返回数据（源代码控软件可以用，但数据库比较困难并且代价昂贵）\r\n\r\n### 3）死锁：\r\n处理死锁的方法：\r\n\r\na. 用软件来检测死锁的发生，选择一个牺牲者，放弃他的工作和他所加的锁；\r\n\r\nb. 给每个锁都加上时间限制，一旦达到时间限制，所加的锁就会失效，工作就会丢失；\r\n\r\n防止死锁的方法：\r\n\r\n强制人们在开始工作时就获得所有可能需要的锁，在此之后就不再允许得到更多的锁；\r\n\r\n可以硬性规定每个人获得锁的顺序（如按姓名字母顺序）\r\n\r\n## 5. 事务：\r\n### 1）ACID：\r\n原子性、一致性、隔离性、持久性\r\n\r\n### 2）事务资源：\r\n\r\n定义：可以进行事务处理的任何事物\r\n\r\n#### 事务控制方法：\r\n\r\n保证事务尽可能短（尽可能不让事务跨越多个请求，跨越多个请求的事务称为长事务）；\r\n\r\n尽可能晚打开事务\r\n\r\n### 3）减少事务隔离以提高灵活性：\r\n\r\n#### SQL的4种隔离级别：\r\n可串行化的、可重复读、读已提交、读未提交\r\n\r\n不必给所有的事务设置相同的隔离级别，而应该仔细观察每个事务并根据每个事务具体情况来决定如何权衡灵活性与正确性\r\n\r\n### 4）业务事务和系统事务：\r\n#### 系统事务：\r\n由关系数据库系统和事务监视器所支持的事务 （一般不用干预）\r\n#### 业务事务：\r\n简单办法：在单个系统事务中执行完整的业务事务（产生长系统事务）；\r\n\r\n复杂的，采用离线并发（通过工作单元来保存更新数据）\r\n\r\n## 6. 离线并发控制的模式：\r\n乐观离线锁、悲观离线锁\r\n\r\n## 7. 应用服务器并发：\r\n每会话一线程 VS 每会话一进程：线程节省资源，但创建和进入隔离区很重要', '1', '1', '2019-01-27 10:02:57', '2019-05-21 16:32:52');
INSERT INTO `posts` VALUES ('99', '3', '0-3', '40', 'PHP ORM框架与简单代码实现', ' 我想自己写一个ORM框架--基于注解和反射的ORM增删改查实现，查了一些质料备用', '对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。\r\n\r\nORM提供了所有SQL语句的生成，代码人员远离了数据库概念。从一个概念需求(例如一个HQL)映射为一个SQL语句，并不需要什么代价，连1%的性能损失都没有。真正的性能损失在映射过程中，更具体地讲，是在对象实例化的过程中。\r\n\r\n目前PHP 开源比较有名的 ORM 有以下几个：\r\n\r\n## 1、Propel\r\nPropel是一个适用于PHP5的ORM映射(Object Relational Mapping)框架，它基于Apache Torque提供对象持久层支持。它通过XML格式的模式定义文件和相应的配置文件来生成SQL和类，它允许你使用对象代替SQL来读写数据库表中的记录。Propel提供一个生成器来为你的数据模型创建SQL定义文件和PHP类。开发者也可以十分简单的定制生成的类，我们还可以通过XML, PHP类和Phing构建工具把Propel集成到已有的应用开发框架中去.例如PHP框架symfony的1.2以前的版本就是默认使用了精简版的Propel作为默认ORM框架。\r\n\r\n官方网站：http://www.propelorm.org/\r\n\r\n## 2、Doctrine\r\nDoctrine是一个PHP的ORM框架，它必须运行在>=php5.2.3版本上，它是一个功能强大的数据抽象层。\r\n\r\n它的一个主要特征就是使用面向对象的方式来实现数据库查询的封转，它底层通过一个类似 Hibernate HQL的DQL的查询语句进行数据库查询，这使得开发的灵活性更强，大大减小了重复代码。相比Propel，Doctrine的优点在于它支持支持全文检索，Doctrine的文档一直就比Propel要全面丰富，社区更活跃，而且使用起来更加自然、更易阅读、更接近原生SQL。性能方面也略微优于Propel。同样你也可以可以很方便的把Doctrine集成到现有的应用框架中去，比如PHP框架symfony的1.3以后的版本将Doctrine作为默认的ORM框架，同时也可以将Doctrine和Codeigniter整合起来。\r\n\r\n官方网站: http://www.doctrine-project.org/\r\n\r\n## 3、EZPDO\r\nEZPDO是一个十分轻量级的PHP ORM框架。EZPDO的作者的本意旨在降低复杂的ORM学习曲线，尽可能在ORM的运行效率和功能之间做一个平衡点，它是我至今用过的最简单的ORM框架，我目前还想将它集成到我的CoolPHP SDK中来，而且运行效率相当不错，功能也基本能满足需求，只不过ESPDO的更新比较缓慢。\r\n\r\n官方网站:http://www.ezpdo.net/blog/?p=2\r\n\r\n## 4、RedBean\r\nRedBean是一个易于使用，轻量级PHP ORM框架，提供对MySQL, SQLite&PostgreSQL的支持。RedBean架构非常灵活，核心也非常简约，开发者可以很方便的通过插件来扩展功能。\r\n\r\n官方网站：http://www.redbeanphp.com/\r\n\r\n## 5、其他\r\n国内的fleaphp开发框架基于TableDataGateway实现ORM实现；Zend Framework除了提供对 SQL 语句的封装以外，也同样实现了TableGateway、TableRowSet、TableRow的实现；还有一些类似Rails的ActiveRecord实现的解决方案。\r\n\r\n总的来说，一般ORM框架对付简单的应用系统来说都能满足基本需求，可以大大降低开发难度，提高开发效率，但是它在SQL优化方面，肯定是比纯SQL语言要差一些，对复杂关联、SQL内嵌表达式的处理可能不是很理想。也许这主要是由于PHP本身对象持久化的问题，导致ORM效率过低，普遍比纯SQL要慢。但是这些都是有办法解决的，最基本的解决性能的方案，我们可以通过缓存来提高效率，Hibernate来说，虽然配置比较繁杂，但是它通过灵活的使用二级缓存和查询缓存极大的缓解数据库的查询压力，极大的提升了系统的性能。\r\n\r\n如果你想自己实现一个PHP的ORM，下面的可以参考下：\r\n```\r\n<?php\r\nabstract class Model{\r\n   protected $pk = \'id\';\r\n   protected $_ID = null; \r\n   protected $_tableName;\r\n   protected $_arRelationMap;\r\n   protected $_modifyMap;\r\n   protected $is_load = false;\r\n   protected $_blForDeletion;\r\n   protected $_DB;\r\n\r\n   public function __consturct($id = null){\r\n       $this->_DB = mysql_connect(\'127.0.0.1\',\'root\',\'\') ;\r\n       $this->_tableName = $this->getTableName();\r\n       $this->_arRelationMap = $this->getRelationMap();\r\n       if(isset($id))$this->_ID = $id;\r\n   }\r\n   abstract protected function getTableName();\r\n   abstract protected function getRelationMap();\r\n\r\n   public function Load(){\r\n       if(isset($this->_ID)){\r\n           $sql = \"SELECT \";\r\n           foreach($this->_arRelationMap as $k => $v){\r\n               $sql .= \'`\'.$k.\'`,\';\r\n           }\r\n           $sql .= substr($sql,0,strlen($sql)-1);\r\n           $sql .= \"FROM \".$this->_tableName.\" WHERE \".$this->pk.\" = \".$this->_ID;\r\n           $result =$this->_DB->mysql_query($sql);\r\n           foreach($result[0] as $k1 => $v1){\r\n              $member = $this->_arRelationMap[$key];\r\n              if(property_exists($this,$member)){\r\n                 if(is_numeric($member)){\r\n                     eval(\'$this->\'.$member.\' = \'.$value.\';\');\r\n                 }else{\r\n                     eval(\'$this->\'.$member.\' = \"\'.$value.\'\";\');\r\n                 }\r\n              }\r\n           }\r\n       }\r\n       $this->is_load = true;\r\n   }\r\n   public function __call($method,$param){\r\n      $type   = substr($method,0,3);\r\n      $member = substr($method,3);\r\n      switch($type){\r\n         case \'get\':\r\n             return $this->getMember($member);\r\n             break;\r\n         case \'set\':\r\n             return $this->setMember($member,$param[0]);\r\n      }\r\n      return false;\r\n   }\r\n   public function setMember($key){\r\n       if(property_exists($this,$key)){\r\n          if(is_numeric($val)){\r\n             eval(\'$this->\'.$key.\' = \'.$val.\';\');\r\n          }else{\r\n             eval(\'$this->\'.$key.\' = \"\'.$val.\'\";\');\r\n          }\r\n          $this->_modifyMap[$key] = 1;\r\n       }else{\r\n          return false;\r\n       }\r\n   }\r\n   \r\n   public function getMember($key,$val){\r\n       if(!$this->is_load){\r\n          $this->Load();\r\n       }\r\n       if(property_exists($this,$key)){\r\n          eval(\'$res = $this->\'.$key.\';\' );\r\n          return $this->$key;\r\n       }\r\n       return false;\r\n   }\r\n\r\n   public function save(){\r\n      if(isset($this->_ID)){\r\n          $sql = \"UPDATE \".$this->_tableName.\" SET \";\r\n          foreach($this->arRelationMap as $k2 => $v2){\r\n              if(array_key_exists( $k2, $this->_modifyMap)){\r\n                  eval( \'$val = $this->\'.$v2.\';\');\r\n                  $sql_update .=  $v2.\" = \".$val;\r\n              }\r\n          }\r\n          $sql .= substr($sql_update,0,strlen($sql_update));\r\n          $sql .= \'WHERE \'.$this->pk.\' = \'.$this->_ID;\r\n      }else{\r\n          $sql = \"INSERT INTO \".$this->_tableName.\" (\";\r\n          foreach($this->arRelationMap as $k3 => $v3){\r\n              if(array_key_exists( $k3,$this->_modifyMap)){\r\n                  eval(\'$val = $this->\'.$v3.\';\');\r\n                  $field  .= \"`\".$v3.\"`,\"; \r\n                  $values .= $val;\r\n              }\r\n          }\r\n          $fields = substr($field,0,strlen($field)-1);\r\n          $vals   = substr($values,0,strlen($values)-1);\r\n          $sql .= $fields.\" ) VALUES (\".$vals.\")\";\r\n      }\r\n      echo $sql;\r\n      //$this->_DB->query($sql);\r\n   }\r\n   public function __destory(){\r\n      if(isset($this->ID)){\r\n         $sql = \"DELETE FROM \".$this->_tableName.\" WHERE \".$this->pk.\" = \".$this->_ID;\r\n        // $this->_DB_query($sql);\r\n      }\r\n   }\r\n}\r\n\r\nclass User extends Model{\r\n    protected  function getTableName(){\r\n       return \"test_user\";\r\n    }\r\n    protected function getRelationMap(){\r\n        return array( \r\n                      \'id\'       => USER_ID,\r\n                      \'user_name\'=> USER_NAME,\r\n                      \'user_age\' => USER_AGE\r\n                    );\r\n    }\r\n    public function getDB(){\r\n       return $this->_DB;\r\n    }\r\n}\r\n\r\n$UserIns = new User();\r\nprint_r($UserIns);\r\n\r\n?>\r\n```', '1', '1', '2019-01-27 11:15:42', '2019-01-27 11:23:04');
INSERT INTO `posts` VALUES ('100', '3', '0-3', '40', 'PHP面向对象(OOP):抽象方法和抽象类（abstract）', '来自官方文档和部分网络摘抄', 'PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。\r\n\r\n继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。\r\n\r\n## Example #1 抽象类示例\r\n```\r\n<?php\r\nabstract class AbstractClass\r\n{\r\n // 强制要求子类定义这些方法\r\n    abstract protected function getValue();\r\n    abstract protected function prefixValue($prefix);\r\n\r\n    // 普通方法（非抽象方法）\r\n    public function printOut() {\r\n        print $this->getValue() . \"\\n\";\r\n    }\r\n}\r\n\r\nclass ConcreteClass1 extends AbstractClass\r\n{\r\n    protected function getValue() {\r\n        return \"ConcreteClass1\";\r\n    }\r\n\r\n    public function prefixValue($prefix) {\r\n        return \"{$prefix}ConcreteClass1\";\r\n    }\r\n}\r\n\r\nclass ConcreteClass2 extends AbstractClass\r\n{\r\n    public function getValue() {\r\n        return \"ConcreteClass2\";\r\n    }\r\n\r\n    public function prefixValue($prefix) {\r\n        return \"{$prefix}ConcreteClass2\";\r\n    }\r\n}\r\n\r\n$class1 = new ConcreteClass1;\r\n$class1->printOut();\r\necho $class1->prefixValue(\'FOO_\') .\"\\n\";\r\n\r\n$class2 = new ConcreteClass2;\r\n$class2->printOut();\r\necho $class2->prefixValue(\'FOO_\') .\"\\n\";\r\n?>\r\n```\r\n以上例程会输出：\r\n```\r\nConcreteClass1\r\nFOO_ConcreteClass1\r\nConcreteClass2\r\nFOO_ConcreteClass2\r\n```\r\n## Example #2 抽象类示例\r\n```\r\n<?php\r\nabstract class AbstractClass\r\n{\r\n    // 我们的抽象方法仅需要定义需要的参数\r\n    abstract protected function prefixName($name);\r\n\r\n}\r\n\r\nclass ConcreteClass extends AbstractClass\r\n{\r\n\r\n    // 我们的子类可以定义父类签名中不存在的可选参数\r\n    public function prefixName($name, $separator = \".\") {\r\n        if ($name == \"Pacman\") {\r\n            $prefix = \"Mr\";\r\n        } elseif ($name == \"Pacwoman\") {\r\n            $prefix = \"Mrs\";\r\n        } else {\r\n            $prefix = \"\";\r\n        }\r\n        return \"{$prefix}{$separator} {$name}\";\r\n    }\r\n}\r\n\r\n$class = new ConcreteClass;\r\necho $class->prefixName(\"Pacman\"), \"\\n\";\r\necho $class->prefixName(\"Pacwoman\"), \"\\n\";\r\n?>\r\n```\r\n以上例程会输出：\r\n```\r\nMr. Pacman\r\nMrs. Pacwoman\r\n```\r\n老代码中如果没有自定义类或函数被命名为“abstract”，则应该能不加修改地正常运行。\r\n\r\n___\r\n\r\n在OOP语言中，一个类可以有一个或多个子类，而每个类都有至少一个公有方法做为外部代码访问其的接口。而抽象方法就是为了方便继承而引入的，我们先来看一下抽象类和抽象方法的定义再说明它的用途。\r\n\r\n什么是抽象方法？我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰；\r\n\r\n```\r\nabstract function fun1();\r\nabstract function fun2();\r\n```\r\n上例是就是“abstract”修饰的没有方法体的抽象方法“fun1()”和“fun2()”，不要忘记抽象方法后面还要有一个分号；那么什么是抽象类呢？只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。\r\n\r\n```\r\nabstract class Demo\r\n{\r\n\r\n    var $test;\r\n\r\n    abstract function fun1();\r\n    abstract function fun2();\r\n\r\n    function fun3(){\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n上例中定义了一个抽象类“Demo”使用了”abstract”来修饰， 在这个类里面定义了一个成员属性“$test”，和两个抽象方法“fun1”和“fun2”，还有一个非抽象的方法fun3()；\r\n\r\n那么抽象类我们怎么使用呢？\r\n\r\n最重要的一点就是抽象类不能产生实例对象， 所以也不能直接使用，前面我们多次提到过类不能直接使用，我们使用的是通过类实例化出来的对象，那么抽象类不能产生实例对象我们声明抽象类有什么用呢？\r\n\r\n我们是将抽象方法是做为子类重载的模板使用的，定义抽象类就相当于定义了一种规范，这种规范要求子类去遵守，子类继承抽象类之后，把抽象类里面的抽象方法按 照子类的需要实现。子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，那么子类还是抽象类，还是不能实例化类；为什么我们非要从抽象类中继承呢？因为有的时候我们要实现一些功能就必须从抽象类中继承，否则这些功能你就实现不了，如果继承了抽象类，就要实现类其中的抽象方法；\r\n\r\n```\r\n<?php\r\nabstract class Demo\r\n{\r\n    var $test;\r\n\r\n    abstract function fun1();\r\n    abstract function fun2();\r\n\r\n    function fun3() {\r\n        ...\r\n    }\r\n}\r\n\r\n$demo=new Demo(); //抽象类不能产生实例对象，所以这样做是错的，实例化对象交给子类\r\n\r\nclass Test extends Demo\r\n{\r\n    function fun1() {\r\n        ...\r\n    }\r\n\r\n    function fun2() {\r\n        ...\r\n    }\r\n}\r\n\r\n$test = new Test(); //子类可以实例化对象，因为实现了父类中所有抽象方法\r\n?>\r\n```\r\n ', '1', '1', '2019-01-27 11:43:58', '2019-01-27 11:50:53');
INSERT INTO `posts` VALUES ('101', '3', '0-3', '40', 'PHP Predefined Interfaces 预定义接口 6个迭代器接口介绍', '这个对理解开发php很重要', '官方地址 http://www.php.net/manual/en/class.iterator.php\r\n\r\n## SPL提供了6个迭代器接口：\r\n\r\n名称|解释\r\n---|--- \r\nTraversable	|遍历接口（检测一个类是否可以使用 foreach 进行遍历的接口）\r\nIterator	|迭代器接口（可在内部迭代自己的外部迭代器或类的接口）\r\nIteratorAggregate|	聚合式迭代器接口（创建外部迭代器的接口）\r\nOuterIterator	|迭代器嵌套接口（将一个或多个迭代器包裹在另一个迭代器中）\r\nRecursiveIterator|	递归迭代访问接口（提供递归访问功能）\r\nSeekableIterator|	可索引迭代访问接口（实现查找功能）\r\n\r\n下面对各种迭代器接口简单介绍一下：\r\n\r\n### 1. Traversable\r\nTraversable接口实际上不是一个接口，在实际写php代码中不能用。因为只有内部的PHP类（用C写的类）才可以直接实现Traversable接口。可以说这是个特性级别的东西。实际的PHP编程中我们使用Iterator接口或者IteratorAggregate接口来实现遍历。\r\n```\r\nTraversable {\r\n}\r\n```\r\nTraversable 接口不能直接实现（implements）.Traversable 重要的一个用处就是判断一个类是否可以遍历：\r\n```\r\nif($class instanceof Traversable)\r\n{\r\n     //foreach...\r\n}\r\n```\r\n下面是官方例子：\r\n```\r\n<?php\r\n    if( !is_array( $items ) && !$items instanceof Traversable )\r\n        //Throw exception here\r\n?>\r\n```\r\n### 2. Iterator\r\nIterator接口的主要用途是允许一个类实现一个基本的迭代功能，从而使它可以被循环访问，根据键值访问以及回滚。Iterator接口摘要如下：\r\n```\r\nIterator extends Traversable  \r\n{  \r\n    //返回当前索引游标指向的元素  \r\n    abstract public mixed current(void)  \r\n    //返回当前索引游标指向的元素的键名  \r\n    abstract public scalar key(void)  \r\n    //移动当前索引游标指向下一元素  \r\n    abstract public void next(void)  \r\n    //重置索引游标的指向第一个元素  \r\n    abstract public void rewind(void)  \r\n    //判断当前索引游标指向的是否是一个元素，常常在调用 rewind()或 next()使用  \r\n    abstract public boolean valid(void)  \r\n} \r\n```\r\n外部迭代器接口，实现该接口的对象可以迭代自己内部的数据。\r\n\r\nIterator 的例子这里就不再列举了，本专题前面部分以后后续有很多例子，具体请自行查看。\r\n\r\n### 3. IteratorAggregate\r\n又叫聚合式迭代器。创建外部迭代器的接口，其摘要如下：\r\n```\r\nIteratorAggregate extends Traversable {  \r\n	//实现该方法时，必须返回一个实现了Iterator接口的类的实例  \r\n	abstract public Traversable getIterator ( void )  \r\n} \r\n```\r\n其中getIterator 方法返回值必须是能遍历或实现Iterator接口（must be traversable or implement interface Iterator）。SPL还提供了一些专门用来与IteratorAggregate接口一起使用的内置迭代器。使用这些迭代器意味着只需要实现一个方法并实例化一个类就可以使对象可以迭代访问了。\r\n\r\n实例：\r\n```\r\n/**\r\n* @author 简明现代魔法 http://www.nowamagic.net\r\n*/\r\nclass myData implements IteratorAggregate  \r\n{  \r\n    public $property1 = \"公共属性1\";  \r\n    public $property2 = \"公共属性2\";  \r\n    public $property3 = \"公共属性3\";  \r\n  \r\n    public function __construct()  \r\n    {  \r\n        $this->property4 = \"最后一个公共属性\";  \r\n    }  \r\n  \r\n    public function getIterator()  \r\n    {  \r\n        return new ArrayIterator($this);  \r\n    }  \r\n}  \r\n  \r\n$obj = new myData;  \r\nforeach ($obj as $key => $value) {  \r\n    echo \"键名：{$key}  值：{$value}\\n\";  \r\n} \r\n```\r\n程序输出：\r\n```\r\n键名：property1  值：公共属性1\r\n键名：property2  值：公共属性2\r\n键名：property3  值：公共属性3\r\n键名：property4  值：最后一个公共属性\r\n```\r\n \r\n### 4. ArrayAccess\r\n数组式访问接口。实现该接口的对象能像数组一样使用：\r\n```\r\nArrayAccess {\r\n	/* Methods */\r\n	abstract public boolean offsetExists ( mixed $offset )\r\n	abstract public mixed offsetGet ( mixed $offset )\r\n	abstract public void offsetSet ( mixed $offset , mixed $value )\r\n	abstract public void offsetUnset ( mixed $offset )\r\n}\r\n```\r\n \r\n- ArrayAccess::offsetExists — 检查一个偏移位置是否存在\r\n- ArrayAccess::offsetGet — 获取一个偏移位置的值\r\n- ArrayAccess::offsetSet — 设置一个偏移位置的值\r\n- ArrayAccess::offsetUnset — 复位一个偏移位置的值\r\n\r\n举个栗子：\r\n```\r\n/**\r\n* @author 简明现代魔法 http://www.nowamagic.net\r\n*/\r\nclass obj implements arrayaccess {\r\n    private $container = array();\r\n    public function __construct() {\r\n        $this->container = array(\r\n            \"one\"   => 1,\r\n            \"two\"   => 2,\r\n            \"three\" => 3,\r\n        );\r\n    }\r\n    public function offsetSet($offset, $value) {\r\n        if (is_null($offset)) {\r\n            $this->container[] = $value;\r\n        } else {\r\n            $this->container[$offset] = $value;\r\n        }\r\n    }\r\n    public function offsetExists($offset) {\r\n        return isset($this->container[$offset]);\r\n    }\r\n    public function offsetUnset($offset) {\r\n        unset($this->container[$offset]);\r\n    }\r\n    public function offsetGet($offset) {\r\n        return isset($this->container[$offset]) ? $this->container[$offset] : null;\r\n    }\r\n}\r\n\r\n$obj = new obj;\r\n\r\nvar_dump(isset($obj[\"two\"]));\r\nvar_dump($obj[\"two\"]);\r\nunset($obj[\"two\"]);\r\nvar_dump(isset($obj[\"two\"]));\r\n$obj[\"two\"] = \"A value\";\r\nvar_dump($obj[\"two\"]);\r\n$obj[] = \'Append 1\';\r\n$obj[] = \'Append 2\';\r\n$obj[] = \'Append 3\';\r\nprint_r($obj);\r\n```\r\n\r\n### 5. Serializable\r\n序列化接口。实现该接口的类不能使用\\__sleep() 和\\__wakeup().在serialize时不执行\\__destruct()，在unserialize不执行\\__construct()。\r\n```\r\nSerializable {\r\n	/* Methods */\r\n	abstract public string serialize ( void )\r\n	abstract public mixed unserialize ( string $serialized )\r\n}\r\n```\r\n实现此接口的类将不再支持 \\__sleep() 和 \\__wakeup()。\r\n\r\n不论何时，只要有实例需要被序列化，serialize 方法都将被调用。\r\n\r\n它将不会调用 \\__destruct() 或有其他影响，除非程序化地调用此方法。\r\n\r\n当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 \\__construct()。\r\n\r\n如果需要执行标准的构造器，你应该在这个方法中进行处理。\r\n\r\n- Serializable::serialize — 对象的字符串表示\r\n\r\n- Serializable::unserialize — 构造对象\r\n\r\n```\r\nSerializable {\r\n	/* Methods */\r\n	abstract public string serialize ( void )\r\n	abstract public mixed unserialize ( string $serialized )\r\n}\r\n```\r\n \r\n例子：\r\n```\r\nclass obj implements Serializable {\r\n    private $data;\r\n    public function __construct() {\r\n        $this->data = \"My private data\";\r\n    }\r\n    public function serialize() {\r\n        return serialize($this->data);\r\n    }\r\n    public function unserialize($data) {\r\n        $this->data = unserialize($data);\r\n    }\r\n    public function getData() {\r\n        return $this->data;\r\n    }\r\n}\r\n\r\n$obj = new obj;\r\n$ser = serialize($obj);\r\n\r\n$newobj = unserialize($ser);\r\n\r\nvar_dump($newobj->getData());\r\n```\r\n\r\n### 6. Closure\r\n```\r\nClosure {\r\n	/* 方法 */\r\n	__construct ( void )\r\n	public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = \'static\' ] )\r\n	public Closure bindTo ( object $newthis [, mixed $newscope = \'static\' ] )\r\n}\r\n```\r\n\r\n官方文档：http://www.php.net/manual/en/reserved.interfaces.php\r\n\r\n', '1', '1', '2019-01-27 12:12:31', '2019-01-27 12:25:34');
INSERT INTO `posts` VALUES ('102', '13', '0-13', '2', '周一打卡（012815）', '这几天也没有闲着，博文和代码持续更新中。', '>上联：敲一夜代码，流下两三行泪水，掏空四肢五体，六杯咖啡七桶泡面，还有八个测试九层审批，可谓十分艰难；\r\n\r\n>下联：经十年苦读，面过九八家公司，渐忘七情六欲，五年相亲四个对象，乃知三番加班两次约会，新年一鸣惊人。\r\n\r\n## 横批：谁能懂我', '1', '1', '2019-01-28 15:52:49', '2019-01-28 15:55:26');
INSERT INTO `posts` VALUES ('103', '14', '0-14', '2', '06-企业应用架构模式-会话状态', '简单的说当客户端第一次访问某个站点的时候，将会在服务端生成一个唯一的Key，然后发送给客户端，在服务器端通过Key来取得相应的数据。通常，我们将这个key称为SessionID。\r\n大家都知道HTTP是无状态的，那么这个sessionID保存到客户端的什么地方呢？想想客户端“我们知道web网站在客户端存储数据有三种形式：\r\n1. Cookie  \r\n2. hidden（隐藏域） \r\n3.QueryString”   ，这三个你觉得那个更有可能，没错是cookice，当然当客户端禁用cookice的情况先就', '## 1. 无状态的价值：\r\n无状态可以仅用很少的对象就可以处理很多的用户，空闲状态的用户越多，无状态服务器就越有用\r\n\r\n## 2. 会话状态：\r\n相关性：会话状态只与当前会话有关，它存在于业务事务中，与其他会话及他们的业务事务是分开的；\r\n\r\n与记录数据信息的区别：记录数据时长期保存在数据库中的持久化数据，它对所有会话可见，会话状态需要提交成为数据库中的记录；\r\n\r\n最大问题：出现在处理隔离性的时候（同时操作，或者相关联操作）\r\n\r\n不能把会话中所有数据都看成是会话状态\r\n\r\n## 3. 存储会话状态的方法：\r\n### 1）存储会话状态的3种方法：\r\n\r\n客户会话状态：在客户端保存数据（在web中可用url、cookie、hidden域等）\r\n\r\n适用场景：会话数据较少、用户经常取消会话（如B2C用户直接关闭站点消失）\r\n\r\n问题：安全性、完整性\r\n\r\n服务器会话状态：在服务器内存、文件系统、一张简单的数据库表（以会话标识号为key、以已序列化对象为值）\r\n\r\n优点：容易直接访问会话状态\r\n\r\n数据库会话状态：在服务器端存储（将数据分解为多个表和域）\r\n\r\n优点：状态持久化不易丢失\r\n\r\n问题：隔离性差（需要将会话数据与记录数据相隔离）\r\n\r\n以上3种模式并不相互排斥，可以混合使用。使用时，还需要注意：客户机崩溃、服务器死掉、网络连接断掉	\r\n### 2）会话扩容：\r\n\r\n会话迁移：允许一次会话从一台服务器转移到另一台服务器，从而可以有一台服务器处理一个请求，其他服务器处理其他请求\r\n\r\n优点：可均衡服务器\r\n\r\n缺点：难以找到会话状态，难以支持会话迁移\r\n\r\n服务器亲和：某次特定会话的所有请求只能由一台服务器处理	\r\n\r\n缺点：当客户端有使用代理是，可能会有大量负载集中在某台服务器上', '1', '1', '2019-01-29 13:00:54', '2019-01-29 13:10:45');
INSERT INTO `posts` VALUES ('104', '14', '0-14', '2', '07-企业应用架构模式-分布策略', '没怎么懂，多查查资料和看后期的介绍', '## 1. 分布对象的诱惑：\r\n中间件的对象分布对上层透明崔然非常有用，但跨进程、跨机器（还有网络）调用，影响性能！\r\n\r\n## 2. 远程接口和本地接口：\r\n　　1）远程访问的对象需要使用粗粒度接口，而本地访问的对象需要使用细粒度接口（优化性能时，本地接扣可以提供粗粒度对象）\r\n\r\n　　2）基于1），就不能把在单进程中设计的类原封不动地搬到分布模型环境中\r\n\r\n　　3）分布对象设计第一定律：不要分布使用对象！\r\n\r\n　　4）怎样有效利用多处理器资源：使用集群系统（在每个处理器上都部署所有对象，每个处理器上的对象都只需要用到本地调用 -> 运行更快，还可以使用细粒度接口设计对象模型）\r\n\r\n## 3. 必须使用分布的情况 \r\n　　1）传统客户机/服务器架构\r\n\r\n　　2）应用软件与数据库\r\n\r\n　　3）web服务器和应用服务器（指的是web service么？ 没搞懂！）\r\n\r\n　　4）不同厂商的软件包\r\n\r\n## 4. 关于分布边界\r\n\r\n　　1）远程外观：进程内使用细粒度对象，分布边界上放置粗粒度对象\r\n\r\n　　2）数据传输对象：一般只引用其他数据传输对象和一些如字符串等原始类型对象\r\n\r\n　　3）代理：用延迟加载来传递对象\r\n\r\n## 5. 分布接口\r\n\r\n　　1）如果两个系统使用相同的平台构建，使用系统自己的远程调用机制高效得多！（web service虽跨平台，但传输数据来回转换增加不少开销）\r\n\r\n　　2）使用http协议和远程面向对象API（没弄明白怎么玩）\r\n\r\n　　3）异步、基于消息的处理方式\r\n', '1', '1', '2019-01-29 23:19:48', '2019-01-29 23:37:33');
INSERT INTO `posts` VALUES ('105', '3', '0-3', '2', '错误：14090086：SSL例程：SSL3_GET_SERVER_CERTIFICATE：证书验证', '在项目目录中创建了我的composer.json文件\r\n从包含composer.json的目录执行\'composer install\'', '## 我收到以下错误：\r\n```\r\n  - Installing symfony/class-loader (v3.4.4): Downloading (failed)\r\nDownloading (failed)\r\nDownloading (failed)    Failed to download symfony/class-loader from dist: The \"https://files.phpcomposer.com/files/symfony/class-loader/e63c12699822bb3b667e7216ba07fbcc3a3e203e.zip\" file could not be downloaded: SSL operation failed with code 1. OpenSSL Error messages:\r\nerror:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure\r\nFailed to enable crypto\r\nfailed to open stream: operation failed\r\n    Now trying to download from source\r\n\r\n``` \r\n解决方案可查看Github：https://github.com/composer/composer/issues/3346\r\n\r\n## 最后我找到了答案:)\r\n首先：检查将在default_cert_file密钥中的证书文件位置，您将在openssl_get_cert_locations（）中找到它的php openssl函数：\r\n```\r\n$ php -r \"print_r(openssl_get_cert_locations());\"\r\n```\r\n```\r\nArray\r\n(\r\n    [default_cert_file] => /opt/lampp/share/openssl/cert.pem\r\n    [default_cert_file_env] => SSL_CERT_FILE\r\n    [default_cert_dir] => /opt/lampp/share/openssl/certs\r\n    [default_cert_dir_env] => SSL_CERT_DIR\r\n    [default_private_dir] => /opt/lampp/share/openssl/private\r\n    [default_default_cert_area] => /opt/lampp/share/openssl\r\n    [ini_cafile] => \r\n    [ini_capath] => \r\n)\r\n```\r\n第二：下载http://curl.haxx.se/ca/cacert.pem：\r\n```\r\n$ wget http://curl.haxx.se/ca/cacert.pem\r\n```\r\n第三步：将证书PEM文件复制到default_cert_file位置：\r\n\r\n$ sudo mv cacert.pem /opt/lampp/share/openssl/cert.pem\r\n我的php-cli在XAMPP下，default_cert_file可能指向某个与此不同的地方。', '1', '1', '2019-01-30 09:33:32', '2019-01-30 09:38:18');
INSERT INTO `posts` VALUES ('106', '14', '0-14', '2', '08-企业应用架构模式-通盘考虑', '持续集成、驱动测试开发和重构', '>思考三个方面的技术实践：持续集成、驱动测试开发和重构\r\n\r\n## 1. 从领域层开始\r\n1）事务脚本模式最简单，适合于在关系数据库之上构建；领域模型需要非常专业的技术，还有鱼数据库的连接；表模块模式折中，在.Net这类有非常强大记录集支持的环境非常合适\r\n\r\n2）理论上，可以根据架构来选取工具；实践中，可以让架构和工具相匹配\r\n\r\n## 2. 深入到数据源层\r\n\r\n1）事务脚本的数据源：\r\n\r\n可供选择的数据库模式为：行数据入口和表数据入口，两者之间选哪个取决于实现平台的方便以及系统未来的发展方向（如：开发平台所包含的工具，比如支持记录集合工具）\r\n\r\n2）表模块的数据源：\r\n\r\n有一个良好的记录集框架 -> 与表数据入口模式配合得天衣无缝\r\n\r\n3）领域模型的数据源：\r\n\r\n如果模型相当简单（如只有十几个与数据库相关的类），则活动记录即可；\r\n\r\n如果希望耦合更松一些，可以用表数据集入口或行数据入口；\r\n\r\n当更复杂性时，可以考虑使用数据映射器（工作单元模式取作用）\r\n\r\n## 3. 表现层\r\n\r\n1）如果情况允许，尽可能使用html而不是胖客户界面；\r\n\r\n2）如果走html路线，使用mvc；\r\n\r\n3）.net使用页面控制器 + 模板视图，Java使用前端控制器 + 模板视图；\r\n\r\n4）站点面向文档，使用页面控制器，复杂情况下可考虑使用前端控制器；\r\n\r\n5）视图选择：模板视图（服务器页面）、转换视图（XSLT）	\r\n\r\n## 4. 一些关于具体技术的建议	\r\n\r\n## 5. 其他分层方式\r\n\r\n', '1', '1', '2019-01-30 22:28:58', '2019-01-30 22:32:36');
INSERT INTO `posts` VALUES ('107', '14', '0-14', '2', '09-企业应用架构模式-领域逻辑模式', '', '## 1. 事务脚本\r\n### 1）调用数据库：\r\n事务脚本将所有逻辑组成单个过程，在过程中直接调用数据库，或者只通过一个简单的数据库封存器。\r\n### 2）脚本处理：\r\n每个事务都有自己的事务脚本，尽管事务间的公共子任务可以被分解成多个子程序。\r\n### 3）运行机制：\r\na.事务脚本应该置于与其他处理表现层和数据源层的类相独立的类中，把事务脚本组织成类的两种方法：\r\n\r\na. 将数个事务脚本放在一个类中，每个类围绕一个主题将相关的事务脚本组织在一起；\r\n\r\nb. 使用Command模式，每一个事务脚本对应一个类 (command)\r\n### 4）使用时机: \r\n业务逻辑简单场景（同时注意谨慎提取公共子程序以减少代码冗余），当业务复杂时则需要建立领域模型\r\n### 5）优点：\r\n当问题本身是简单的时，使用事务脚本可以加快开发速度，而且运行更快\r\n### 6）示例：\r\n假如有如下需求：\r\n![](/public/img/posts/wentione.png)\r\n数据库设计为：\r\n![](/public/img/posts/shejione.png)\r\n其中，RevenueRecognition表引用Contract表的Id作为外键。根据需求和数据库设计，事务脚本类图设计为：\r\n![](/public/img/posts/shiwujiaobensheji.png)\r\n\r\n这里，Gateway为数据库访问封存器，RecognitionServices为事务脚本类。CalculateRevenueRecognitions方法用于计算并保存需入账信息（合同编号、时间、收费金额），RecognizedRevenue用于按照合同编号、指定日期查询已收费用。应用程序只需要分别单个调取这2个方法即可。\r\n\r\n## 2. 领域模型\r\n### 1）运行机制\r\n领域模型与数据库模型的区别：领域模型混合数据和处理过程，拥有多值属性和复杂的关联网，并且使用继承、策略、设计模式，是一张由互联的细粒度对象组成的复杂网络；\r\n\r\n使用领域逻辑的一个常见问题: 领域对象过于臃肿，可能会产生冗余代码\r\n\r\n数据库映射：简单领域模型可以使用活动记录，而复杂领域模型需要使用数据映射器。\r\n\r\n领域模型应当使用细粒度的对象，这些对象应有细粒度的接口。\r\n### 2）使用时机\r\n当业务规则复杂多变，涉及到校验、计算、衍生时。\r\n\r\n数据库交互方式：首选数据映射器\r\n### 3）示例：\r\n\r\n对于上文中需求，设计类图如下：\r\n![](/public/img/posts/lingyumonxing.png)　　　　\r\n\r\n可以看到，这里收费方式使用了策略模式。\r\n\r\n## 3. 表模块\r\n表模块以一个类对应数据库中的一个表来组织领域逻辑，而且使用单一的类实例来包含将对数据进行的各种操作程序。\r\n\r\n表模块与领域逻辑的区别：如果有多个订单，领域模型对每个订单都有一个对象，而表模块则只用一个对象来处理所有订单（表模块没有标识符来标出它所代表的实体对象）。\r\n### 1）运行机制\r\n长处：允许你将数据与行为封装在一起，同时有可以充分利用关系数据库的优点\r\n\r\n### 2）使用时机\r\n当使用记录集存取表数据时使用（表模块很大程度上依赖于以表方式组织的数据）\r\n　　\r\n### 3）示例：\r\n\r\n\r\n设计类图如下：\r\n![](/public/img/posts/cheluemoshi.png)　　\r\n　　　　\r\n\r\n\r\n## 4. 服务层\r\n服务层定义了应用的边界和从接口客户层角度所能看到的可用操作集。它封装了应用的业务逻辑、事务控制及其操作实现中的响应协调。\r\n　　\r\n### 1）运行机制\r\n\r\n业务逻辑分类：领域逻辑、应用逻辑\r\n\r\n两种基本的实现方法：\r\n\r\n- 领域外观方法：\r\n\r\n服务层以领域模型之上的瘦外观集合方式实现（负责实现外观的类不包含任何业务逻辑，所有业务逻辑均由领域模型实现）\r\n\r\n- 操作脚本方法：\r\n\r\n服务层由一组相对复杂的类组成，这些类直接实现应用逻辑，但将领域逻辑委托给封装好的领域对象类\r\n\r\n服务层接口时粗粒度的，必要时候可以远程调用（在服务层之上增加远程外观或者直接让服务层实现远程接口）\r\n　　\r\n### 2）使用时机\r\n\r\n#### 服务层优点：\r\n\r\n它定义了一个公共的应用操作集合，这个集合可被各种客户使用，而且服务层在每个操作中都会协调应用的响应。\r\n\r\n当业务逻辑有多种客户，或者用例响应中的多个事务性资源，则需要服务层\r\n\r\n', '1', '1', '2019-01-31 15:03:52', '2019-01-31 15:28:41');
INSERT INTO `posts` VALUES ('108', '14', '0-14', '2', '10-企业应用架构模式-数据源架构模式', '', '## 1. 表数据入口\r\n　　充当数据库表访问入口的对象，一个实例处理表中所有的行。\r\n\r\n### 1）运行机制：\r\n\r\n　　　　表数据入口包含了用于访问单个表或试图的所有SQL，如选择、插入、更新、删除等。其他代码调用它的方法来实现所有与数据库的交互。\r\n　　　　表数据入口可以和表模块一起使用，它产生一个记录集数据结构由表模块处理\r\n\r\n### 2）使用时机：\r\n\r\n　　　　数据入口特别适用于事务脚本，行数据入口和表数据入口间的选择归结于如何处理多数据行，当结果集的表现便于事务脚本处理时，用表数据入口。\r\n### 3）示例：\r\n\r\n　　　　如下2图分别是普通情况下、充分利用.net特征下的表数据入口实现：\r\n![](/public/img/posts/shujujiagoumoshi01.png)\r\n![](/public/img/posts/shujujiagoumoshi02.png)　　　　  \r\n\r\n　　　　\r\n\r\n## 2. 行数据入口\r\n\r\n　　充当数据源中单条记录入口的对象，每行一个实例。\r\n\r\n### 1）运行机制：\r\n\r\n　　　　特征：行数据入口是和单条记录及其相似的对象，如数据库中的一行（该对象中数据库中的每一列变成了一个域）\r\n\r\n　　　　问题：在哪里存放产生该模式的查找操作？鉴于选择静态查找方法不支持为不同数据源提供不同查找方法的多态，需要设置单独的查找方法对象（这样关系数据库每一张表都一个查找方法类和入口来获得结果）\r\n\r\n　　　　行数据入口和活动记录之间的区别：是否存在任何领域逻辑，如果存在，则是活动记录\r\n\r\n### 2）使用时机：\r\n\r\n　　　　事务脚本（关于表数据入口和行数据入口之间的选择，参考表数据入口）\r\n\r\n　　　　行数据入口可以和数据映射器一起配合使用：行数据入口从元数据自动生成，数据映射器由手动实现\r\n\r\n### 3）实例：\r\n　　　　![](/public/img/posts/shujujiagoumoshi03.png)\r\n\r\n## 3. 活动记录\r\n\r\n　　一个对象，它包含数据库表或视图中的某一行，封装数据库访问，并在这些数据上增加了领域逻辑\r\n\r\n### 1）运行机制：\r\n\r\n　　　　活动记录的本质是一个领域模型，这个领域模型中的类和基数据库中记录结构十分吻合。\r\n\r\n　　　　活动记录通常具有如下方法：\r\n\r\n　　　　　　由SQL结果集中的一行构造一个活动记录实例；\r\n\r\n　　　　　　为将来对表的插入构造一个新的实例；\r\n\r\n　　　　　　用静态查找方法来包装常用的SQL查询和返回活动记录（也可以分离为一个单独的类）；\r\n\r\n　　　　　　更新数据库并将活动记录中的数据插入数据库；\r\n\r\n　　　　　　获取或设置域；\r\n\r\n　　　　　　实现部分业务逻辑。\r\n\r\n### 2）使用时机：\r\n\r\n　　　　适合于创建、读、更新、删除等不太复杂的领域逻辑；\r\n\r\n　　　　优点：简单，容易创建，易于理解；\r\n\r\n　　　　缺点：要求对象的设计和数据库的设计紧耦合，项目中难以进一步重构；当业务逻辑复杂，对象间有引用、集合和继承等关心时，难以映射到活动记录\r\n\r\n### 3）示例：\r\n　　　　![](/public/img/posts/shujujiagoumoshi04.png)\r\n\r\n　　　　其中，标圈的是领域逻辑实现。\r\n\r\n## 4. 数据映射器\r\n\r\n　　在保持对象和数据库（以及映射器本身）彼此独立的情况下在二者之间移动数据的一个映射器层，如下：\r\n　　　　![](/public/img/posts/shujujiagoumoshi05.png)\r\n### 1）运行机制：\r\n\r\n　　　　主要功能：分离领域和数据源\r\n\r\n　　　　延时加载\r\n\r\n　　　　基于元数据的映射\r\n\r\n### 2）使用时机：\r\n\r\n　　　　业务逻辑复杂，数据库方案和对象模型需要彼此独立演变时\r\n\r\n### 3）实例：\r\n　　　　![](/public/img/posts/shujujiagoumoshi06.png)\r\n 　　　　其中，DataMapper实现了IPersonFinder接口，用于查找方法实现。\r\n\r\n ', '1', '1', '2019-02-01 13:19:07', '2019-02-01 13:33:32');
INSERT INTO `posts` VALUES ('109', '14', '0-14', '2', '11-企业应用架构模式-对象-关系行为模式', '', '## 1. 工作单元\r\n用于维护受业务事务影响的对象列表，并协调变化的写入和并发问题的解决。如下：\r\n\r\n![](/public/img/posts/guanxixinweimoshi1.png)\r\n\r\n### 1）运行机制：\r\n#### 关键：\r\n是提交时，决定要做什么。它打开一个事务，做所有的并发检查（使用悲观离线锁或乐观离线锁）并向数据库写入所做的修改。（开发人员根本不用显示调用数据库更新方法）\r\n\r\n#### 记录对象更新的方法：\r\n调用者注册方式：用户如果改变了某个对象就必须将他注册到工作单元，任何没有注册的对象提交时都不会写入数据库。\r\n\r\n![](/public/img/posts/guanxixinweimoshi2.png)　\r\n　　　　　　\r\n\r\n对象注册方式：注册方法置于对象中，从数据库加载对象会将加载的对象注册为“干净”的，setting方法将要设置的对象注册为“脏”的。\r\n\r\n![](/public/img/posts/guanxixinweimoshi3.png)　\r\n　　　　　　　\r\n\r\n工作单元控制器：工作单元控制所有数据库的读操作，一旦对象被读取，将将它注册为“干净”的对象。工作单元在读操作时将产生一个拷贝，在提交时比较当前对象和拷贝对象（这种的办法是指发生改变的对象），看对象是否发生了改变。\r\n\r\n![](/public/img/posts/guanxixinweimoshi4.png)　\r\n　　　　　　　\r\n\r\n用途：数据库（使用引用完整性时保证更新顺序、批量更新）、事务资源（调整消息队列、事务监控）\r\n\r\n.Net环境工作单元实现：使用无连接的数据集，每一行都有版本（当前版本、原始版本、建议版本）、状态（不变、增加、删除、修改）概念\r\n\r\n### 2）使用时机：\r\n基本目的：记录操作过的各种对象，以便知道为了使内存中数据与数据库同步需要考虑哪些对象。\r\n\r\n##2. 标识映射\r\n通过在映射中保存每个已经加载的对象，确保每个对象只加载一次。当要访问对象时，通过映射来查找它们。\r\n\r\n![](/public/img/posts/guanxixinweimoshi5.png)\r\n　　\r\n### 1）运行机制：\r\n键选择：\r\n\r\n数据表主键（或其他简单的数据类型）\r\n\r\n显示的还是通用的（如findPerson(1)，还是find(\"Person\", 1)？）：当所有对象键类型相同时使用通用的，其他情况下使用显示的\r\n\r\n数量（单映射、多映射）：（没看明白）\r\n\r\n标识映射存放位置：有工作单元时，放在工作单元；没有工作单元时，捆绑到会话的注册表\r\n\r\n### 2）使用时机：\r\n\r\n一般来说，用一个标识映射来管理所有修改了的数据库读出数据；\r\n\r\n作为数据库读取操作的告诉缓存。\r\n\r\n## 3. 延迟加载\r\n一个对象，它虽然不包含所需要的所有数据，但是知道怎么获取这些数据\r\n### 1）运行机制：\r\n\r\n#### 4种实现方法：\r\n\r\n延迟初始化：\r\n\r\n实现思想：每次访问属性域都要先检查该域是否为空。如果为空，在返回域值之前计算出这个域的值（注意这个域需要自封装，即便是类的内部也只能通过它来访问）\r\n\r\n优缺点：简单，但往往会在对象和数据库间强加依赖关系\r\n\r\n适用场景：活动记录、表数据库入口、行数据入口\r\n\r\n虚代理：\r\n\r\n定义：虚代理是这样一个对象，它看起来应该是域中的一个对象，但实际上它并不包含任何东西。只有当他的一个方法被调用时，它才从数据库加载适当的对象\r\n\r\n优缺点：看上去完全就是需要的对象，但并不真的是那个对象，容易陷入标识问题；同一个实对象，可能有多个不同对象特征的虚代理（需要覆盖Equals方法，而不用标识方法）\r\n\r\n适用场景：数据映射器\r\n\r\n值保持器：\r\n\r\n实现思想：要想获取某对象，可以访问值保持器得到它的值，但只有第一次访问值保持器时它才真正从数据库读取数据\r\n\r\n优缺点：可避免标识问题；类需要知道值保持器的存在，丧失强数据类型显式性；\r\n\r\n重影：\r\n\r\n实现思想：当从数据库加载对象时，它只包含其ID。当每次要访问某个域时，它就会加载其完全状态（可以把域数据分为不同组，按需加载）\r\n\r\n延迟加载的问题：\r\n\r\n继承（虚代理、重影，需要知道要创建什么类型的重影或虚对象）；\r\n\r\n波动加载（产生超出需要的数据库访问），影响应用程序性能（解决办法：不适用延迟加载集合中的项，但集合整体可以延迟加载）\r\n\r\n适用场景：面向方面的程序（将延迟加载置于一个单独的方面，能独立改变延迟加载策略）\r\n\r\n### 2）使用时机：\r\n\r\n最佳时机：需要额外的调用，并且当使用主对象时所调用的数据没有到的时候（取决于加载一个对象时需要从数据库读取多少数据和数据库调用的次数）', '1', '1', '2019-02-02 16:56:32', '2019-02-02 17:16:02');
INSERT INTO `posts` VALUES ('110', '3', '0-3', '2', '预定义接口 ', '', '## 预定义接口 \r\n\r\n### 遍历\r\n>Traversable（遍历）接口\r\n\r\n```\r\n检测一个类是否可以使用 foreach 进行遍历的接口。\r\n\r\n无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。\r\n\r\n\r\n实现此接口的内建类可以使用 foreach 进行遍历而无需实现 IteratorAggregate 或 Iterator 接口。\r\n\r\n\r\n这是一个无法在 PHP 脚本中实现的内部引擎接口。IteratorAggregate 或 Iterator 接口可以用来代替它。\r\n\r\n接口摘要\r\n\r\nTraversable {\r\n\r\n}\r\n\r\n这个接口没有任何方法，它的作用仅仅是作为所有可遍历类的基本接口。\r\n```\r\n\r\n### 迭代器\r\n>Iterator（迭代器）接口 \r\n\r\n#### 简介 \r\n可在内部迭代自己的外部迭代器或类的接口。\r\n\r\n#### 接口摘要 \r\n```\r\nIterator extends Traversable {\r\n/* 方法 */\r\nabstract public current ( void ) : mixed\r\nabstract public key ( void ) : scalar\r\nabstract public next ( void ) : void\r\nabstract public rewind ( void ) : void\r\nabstract public valid ( void ) : bool\r\n}\r\n```\r\n\r\n预定义迭代器 \r\n\r\nPHP 已经提供了一些用于日常任务的迭代器。 详细列表参见 SPL 迭代器。http://php.net/manual/zh/spl.iterators.php\r\n\r\n### 聚合式迭代器\r\n>IteratorAggregate（聚合式迭代器）接口 \r\n\r\n#### 简介 \r\n创建外部迭代器的接口。\r\n\r\n#### 接口摘要 \r\n```\r\nIteratorAggregate extends Traversable {\r\n/* 方法 */\r\nabstract public getIterator ( void ) : Traversable\r\n}\r\n```\r\nExample #1 基本用法\r\n```\r\n<?php\r\nclass myData implements IteratorAggregate {\r\n    public $property1 = \"Public property one\";\r\n    public $property2 = \"Public property two\";\r\n    public $property3 = \"Public property three\";\r\n\r\n    public function __construct() {\r\n        $this->property4 = \"last property\";\r\n    }\r\n\r\n    public function getIterator() {\r\n        return new ArrayIterator($this);\r\n    }\r\n}\r\n\r\n$obj = new myData;\r\n\r\nforeach($obj as $key => $value) {\r\n    var_dump($key, $value);\r\n    echo \"\\n\";\r\n}\r\n?>\r\n```\r\n以上例程的输出类似于：\r\n```\r\nstring(9) \"property1\"\r\nstring(19) \"Public property one\"\r\n\r\nstring(9) \"property2\"\r\nstring(19) \"Public property two\"\r\n\r\nstring(9) \"property3\"\r\nstring(21) \"Public property three\"\r\n\r\nstring(9) \"property4\"\r\nstring(13) \"last property\"\r\n```\r\n\r\n### 数组式访问\r\n>ArrayAccess（数组式访问）接口 ¶\r\n\r\n#### 简介 \r\n提供像访问数组一样访问对象的能力的接口。\r\n\r\n#### 接口摘要  \r\n```\r\nArrayAccess {\r\n/* 方法 */\r\nabstract public offsetExists ( mixed $offset ) : boolean\r\nabstract public offsetGet ( mixed $offset ) : mixed\r\nabstract public offsetSet ( mixed $offset , mixed $value ) : void\r\nabstract public offsetUnset ( mixed $offset ) : void\r\n}\r\n```\r\nExample #1 Basic usage\r\n```\r\n<?php\r\nclass obj implements arrayaccess {\r\n    private $container = array();\r\n    public function __construct() {\r\n        $this->container = array(\r\n            \"one\"   => 1,\r\n            \"two\"   => 2,\r\n            \"three\" => 3,\r\n        );\r\n    }\r\n    public function offsetSet($offset, $value) {\r\n        if (is_null($offset)) {\r\n            $this->container[] = $value;\r\n        } else {\r\n            $this->container[$offset] = $value;\r\n        }\r\n    }\r\n    public function offsetExists($offset) {\r\n        return isset($this->container[$offset]);\r\n    }\r\n    public function offsetUnset($offset) {\r\n        unset($this->container[$offset]);\r\n    }\r\n    public function offsetGet($offset) {\r\n        return isset($this->container[$offset]) ? $this->container[$offset] : null;\r\n    }\r\n}\r\n\r\n$obj = new obj;\r\n\r\nvar_dump(isset($obj[\"two\"]));\r\nvar_dump($obj[\"two\"]);\r\nunset($obj[\"two\"]);\r\nvar_dump(isset($obj[\"two\"]));\r\n$obj[\"two\"] = \"A value\";\r\nvar_dump($obj[\"two\"]);\r\n$obj[] = \'Append 1\';\r\n$obj[] = \'Append 2\';\r\n$obj[] = \'Append 3\';\r\nprint_r($obj);\r\n?>\r\n```\r\n以上例程的输出类似于：\r\n```\r\nbool(true)\r\nint(2)\r\nbool(false)\r\nstring(7) \"A value\"\r\nobj Object\r\n(\r\n    [container:obj:private] => Array\r\n        (\r\n            [one] => 1\r\n            [three] => 3\r\n            [two] => A value\r\n            [0] => Append 1\r\n            [1] => Append 2\r\n            [2] => Append 3\r\n        )\r\n\r\n)\r\n```\r\n\r\n### 序列化\r\n#### 简介 \r\n自定义序列化的接口。\r\n\r\n实现此接口的类将不再支持 __sleep() 和 __wakeup()。不论何时，只要有实例需要被序列化，serialize 方法都将被调用。它将不会调用 __destruct() 或有其他影响，除非程序化地调用此方法。当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 __construct()。如果需要执行标准的构造器，你应该在这个方法中进行处理。\r\n\r\n#### 接口摘要 \r\n```\r\nSerializable {\r\n/* 方法 */\r\nabstract public serialize ( void ) : string\r\nabstract public unserialize ( string $serialized ) : mixed\r\n}\r\n```\r\nExample #1 Basic usage\r\n```\r\n<?php\r\nclass obj implements Serializable {\r\n    private $data;\r\n    public function __construct() {\r\n        $this->data = \"My private data\";\r\n    }\r\n    public function serialize() {\r\n        return serialize($this->data);\r\n    }\r\n    public function unserialize($data) {\r\n        $this->data = unserialize($data);\r\n    }\r\n    public function getData() {\r\n        return $this->data;\r\n    }\r\n}\r\n\r\n$obj = new obj;\r\n$ser = serialize($obj);\r\n\r\n$newobj = unserialize($ser);\r\n\r\nvar_dump($newobj->getData());\r\n?>\r\n```\r\n以上例程的输出类似于：\r\n```\r\nstring(15) \"My private data\"\r\n```\r\n### Closure\r\n#### 简介 \r\n用于代表 匿名函数 的类.\r\n\r\n匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象。在过去，这个类被认为是一个实现细节，但现在可以依赖它做一些事情。自 PHP 5.4 起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。\r\n\r\n除了此处列出的方法，还有一个 __invoke 方法。这是为了与其他实现了 __invoke()魔术方法 的对象保持一致性，但调用匿名函数的过程与它无关。\r\n\r\n类摘要 \r\n```\r\nClosure {\r\n/* 方法 */\r\n__construct ( void )\r\npublic static bind ( Closure $closure , object $newthis [, mixed $newscope = \'static\' ] ) : Closure\r\npublic bindTo ( object $newthis [, mixed $newscope = \'static\' ] ) : Closure\r\n}\r\n```\r\n\r\n### 生成器\r\n#### 简介 \r\nGenerator 对象是从 generators返回的.\r\n\r\nCaution\r\n\r\nGenerator 对象不能通过 new 实例化.\r\n\r\n类摘要 \r\n```\r\nGenerator implements Iterator {\r\n/* 方法 */\r\npublic current ( void ) : mixed\r\npublic key ( void ) : mixed\r\npublic next ( void ) : void\r\npublic rewind ( void ) : void\r\npublic send ( mixed $value ) : mixed\r\npublic throw ( Exception $exception ) : void\r\npublic valid ( void ) : bool\r\npublic __wakeup ( void ) : void\r\n}\r\n```\r\n\r\n参见 SPL 接口http://php.net/manual/zh/spl.interfaces.php\r\n\r\n 和 预定义类http://php.net/manual/zh/reserved.classes.php', '1', '1', '2019-02-12 13:57:16', '2019-02-12 14:10:43');
INSERT INTO `posts` VALUES ('111', '14', '0-14', '2', '12-企业应用架构模式-对象-关系结构模式', '标识域（Identity Field）', '标识域（Identity Field）', '1', '1', '2019-02-14 23:59:33', '2019-02-15 00:00:08');
INSERT INTO `posts` VALUES ('112', '3', '0-3', '2', 'mkdir(): Permission denied', 'mkdir(): Permission denied', 'chmod -R 777 ./runtime', '1', '1', '2019-02-16 19:40:02', '2019-02-16 19:40:32');
INSERT INTO `posts` VALUES ('113', '14', '0-14', '2', '13-企业应用架构模式-对象-关系源数据映射模式', '', '## 元数据映射\r\n（Metadata Mapping）\r\n\r\n## 查询对象\r\n（Query Object）\r\n\r\n## 资源库\r\n（Repository）', '1', '1', '2019-02-16 21:23:52', '2019-02-20 07:31:00');
INSERT INTO `posts` VALUES ('114', '4', '0-4', '2', 'docker-compose.yml 语法说明', '', '>YAML 模板文件语法\r\n\r\n默认的模板文件是 docker-compose.yml，其中定义的每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）来自动构建。\r\n\r\n其它大部分指令都跟 docker run 中的类似。\r\n\r\n如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。\r\n\r\n## image\r\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉去这个镜像。\r\n例如：\r\n```\r\nimage: ubuntu\r\nimage: orchardup/postgresql\r\nimage: a4bc65fd\r\n```\r\n## build\r\n指定 Dockerfile 所在文件夹的路径。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。\r\n```\r\nbuild: /path/to/build/dir\r\n```\r\n\r\n## command\r\n覆盖容器启动后默认执行的命令。\r\n```\r\ncommand: bundle exec thin -p 3000\r\n```\r\n\r\n## links\r\n链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名 （SERVICE:ALIAS） 格式都可以。\r\n```\r\nlinks:\r\n- db\r\n- db:database\r\n- redis\r\n```\r\n使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：\r\n```\r\n172.17.2.186 db\r\n```\r\n相应的环境变量也将被创建。\r\n\r\n## external_links\r\n链接到 docker-compose.yml 外部的容器，甚至 并非 Compose 管理的容器。参数格式跟 links 类似。\r\n```\r\nexternal_links:\r\n- redis_1\r\n- project_db_1:mysql\r\n- project_db_1:postgresql\r\n```\r\n\r\n## ports\r\n暴露端口信息。\r\n使用宿主：容器 （HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\r\n```\r\nports:\r\n- \"3000\"\r\n- \"8000:8000\"\r\n- \"127.0.0.1:8001:8001\"\r\n```\r\n注：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。\r\n\r\n## expose\r\n暴露端口，但不映射到宿主机，只被连接的服务访问。\r\n仅可以指定内部端口为参数\r\n```\r\nexpose:\r\n- \"3000\"\r\n- \"8000\"\r\n```\r\n\r\n## volumes\r\n卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。\r\n```\r\nvolumes:\r\n- /var/lib/mysql\r\n- cache/:/tmp/cache\r\n- ~/configs:/etc/configs/:ro\r\n```\r\n\r\n## volumes_from\r\n从另一个服务或容器挂载它的所有卷。\r\n```\r\nvolumes_from:\r\n- service_name\r\n- container_name\r\n```\r\n\r\n## environment\r\n设置环境变量。你可以使用数组或字典两种格式。\r\n只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。\r\n```\r\nenvironment:\r\n- RACK_ENV=development\r\n- SESSION_SECRET\r\n```\r\n## env_file\r\n从文件中获取环境变量，可以为单独的文件路径或列表。\r\n如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。\r\n如果有变量名称与 environment 指令冲突，则以后者为准。\r\n```\r\nenv_file: .env\r\nenv_file:\r\n- ./common.env\r\n- ./apps/web.env\r\n- /opt/secrets.env\r\n```\r\n环境变量文件中每一行必须符合格式，支持 # 开头的注释行。\r\n```\r\n# common.env: Set Rails/Rack environment\r\nRACK_ENV=development\r\n```\r\n\r\n## extends\r\n基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 common.yml。\r\n```\r\n# common.yml\r\nwebapp:\r\nbuild: ./webapp\r\nenvironment:\r\n - DEBUG=false\r\n - SEND_EMAILS=false\r\n```\r\n编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展。\r\n\r\ndevelopment.yml\r\n```\r\nweb:\r\nextends:\r\nfile: common.yml\r\nservice: webapp\r\nports:\r\n - \"8000:8000\"\r\nlinks:\r\n  - db\r\nenvironment:\r\n- DEBUG=true\r\ndb:\r\nimage: postgres\r\n```\r\n后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。\r\n\r\n## net\r\n设置网络模式。使用和 docker client 的 --net 参数一样的值。\r\n```\r\nnet: \"bridge\"\r\nnet: \"none\"\r\nnet: \"container:[name or id]\"\r\nnet: \"host\"\r\n```\r\n\r\n## pid\r\n跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。\r\n```\r\npid: \"host\"\r\n```\r\n\r\n## dns\r\n配置 DNS 服务器。可以是一个值，也可以是一个列表。\r\n```\r\ndns: 8.8.8.8\r\ndns:\r\n- 8.8.8.8\r\n- 9.9.9.9\r\n```\r\n\r\n## cap_add, cap_drop\r\n添加或放弃容器的 Linux 能力（Capabiliity）。\r\n```\r\ncap_add:\r\n- ALL\r\ncap_drop:\r\n- NET_ADMIN\r\n- SYS_ADMIN\r\n```\r\n\r\n## dns_search\r\n配置 DNS 搜索域。可以是一个值，也可以是一个列表。\r\n```\r\ndns_search: example.com\r\ndns_search:\r\n- domain1.example.com\r\n - domain2.example.com\r\nworking_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares\r\n```\r\n\r\n这些都是和 docker run 支持的选项类似。\r\n```\r\ncpu_shares: 73\r\nworking_dir: /code\r\nentrypoint: /code/entrypoint.sh\r\nuser: postgresql\r\nhostname: foo\r\ndomainname: foo.com\r\nmem_limit: 1000000000\r\nprivileged: true\r\nrestart: always\r\nstdin_open: true\r\ntty: true\r\n```', '1', '1', '2019-02-16 21:42:10', '2019-02-16 21:47:29');
INSERT INTO `posts` VALUES ('115', '0', '0', '2', '你好！华为云', '', '## 01. Java\r\n\r\n环境: JDK1.7\r\n\r\n```\r\n\r\nC:\\>java -version   \r\n\r\njava version \"1.7.0_51\"  \r\n\r\nJava(TM) SE Runtime Environment (build 1.7.0_51-b13)  \r\n\r\nJava HotSpot(TM) Client VM (build 24.51-b03, mixed mode, sharing)\r\n\r\n```\r\n\r\n代码: \r\n\r\n#FileName: HelloWorld.java  \r\npublic class HelloWorld   #如果有 public 类的话，类名必须和文件同名，注意大小写  \r\n{  \r\n  #Java 入口程序，程序从此入口  \r\n  public static void main(String[] args)  \r\n  {  \r\n  #向控制台打印一条语句  \r\n    System.out.println(\"你好，华为云社区！\");  \r\n  }  \r\n}\r\n说明：\r\n\r\n```\r\n\r\nD:\\HelloWorld>javac HelloWorld.java    #用 javac 编译成字节码文件（HelloWorld.class）  \r\n\r\nD:\\HelloWorld>java HelloWorld          #用 java 解释执行成特定平台的机器码  \r\n\r\n你好，华为云社区！\r\n\r\n```\r\n\r\n\r\n\r\n## 02. C\r\n\r\n环境: MinGW 或各种 C/C++ 编译器\r\n\r\n```\r\n\r\nD:\\HelloWorld>gcc -v  \r\n\r\nReading specs from C:/Perl/site/lib/auto/MinGW/bin/../lib/gcc/mingw32/3.4.5/specs  \r\n\r\nConfigured with: ../gcc-3.4.5-20060117-3/configure --with-gcc --with-gnu-ld --with-gnu-as --host=min  \r\n\r\ngw32 --target=mingw32 --prefix=/mingw --enable-threads --disable-nls --enable-languages=c,c++,f77,ad  \r\n\r\na,objc,java --disable-win32-registry --disable-shared --enable-sjlj-exceptions --enable-libgcj --dis  \r\n\r\nable-java-awt --without-x --enable-java-gc=boehm --disable-libgcj-debug --enable-interpreter --enabl  \r\n\r\ne-hash-synchronization --enable-libstdcxx-debug  \r\n\r\nThread model: win32  \r\n\r\ngcc version 3.4.5 (mingw-vista special r3)  \r\n\r\n```\r\n\r\n代码: \r\n\r\n#include <stdio.h>  \r\nint main()                #main 入口函数  \r\n{  \r\n  printf(\"你好，华为云社区！\"); #printf 函数打印  \r\n  return 1;               #函数返回值  \r\n}\r\n说明：\r\n\r\n```\r\n\r\nD:\\HelloWorld>gcc HelloWorld.c -o output   #文件名 HelloWorld.c，-o 输出文件名 output  \r\n\r\nHelloWorld.c:6:2: warning: no newline at end of file  \r\n\r\n  \r\n\r\nD:\\HelloWorld>output                       #直接运行输出文件               \r\n\r\n你好，华为云社区！\r\n\r\n```\r\n\r\n#如果未安装 GCC，那么必须安装 GCC。  \r\n\r\n#为了在 Windows 上安装 GCC，需要安装 MinGW。\r\n\r\n#为了安装 MinGW，请访问 MinGW 的主页 XXXXX，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。  \r\n\r\n#当安装 MinWG 时，至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。    \r\n\r\n#添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。    \r\n\r\n#当完成安装时，就可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。\r\n\r\n\r\n\r\n## 03. C++\r\n\r\n环境: MinGW 或各种 C++ 编译器\r\n\r\n\r\n\r\n头文件后缀名：.h、.hpp、.hxx\r\n\r\n源文件后缀名：.cpp、.c++、.cxx、.cc、.C\r\n\r\n\r\n\r\n代码:\r\n\r\n#include <iostream>               //std::cout 要用到的头文件  \r\n#include <stdio.h>                //标准输入输出头文件  \r\n  \r\nint main()  \r\n{  \r\n  printf(\"Hello,World!--Way 1\\n\");    //printf 语句打印  \r\n  puts(\"Hello,World!--Way 2\");        //puts 语句  \r\n  puts(\"Hello,\" \" \" \"World!--Way 3\"); //字符串拼接  \r\n  std::cout << \"Hello,World!--Way 4\" << std::endl; //C++ 教科书上写法  \r\n  return 1;                                        //作为注释  \r\n}\r\n说明：\r\n\r\n```\r\n\r\nD:\\HelloWorld>g++ HelloWorld.c++ -o output   //源文件后缀也可为 .cpp、.C  \r\n\r\n  \r\n\r\nD:\\HelloWorld>output  \r\n\r\nHello,World!--Way 1  \r\n\r\nHello,World!--Way 2  \r\n\r\nHello,World!--Way 3  \r\n\r\nHello,World!--Way 4\r\n\r\n```\r\n\r\n\r\n\r\n## 04. Python\r\n\r\n环境: Python 2.x 或 Python 3.x\r\n\r\n```\r\n\r\nD:\\HelloWorld>python  \r\n\r\nPython 2.7.4 (default, Apr  6 2013, 19:55:15) [MSC v.1500 64 bit (AMD64)] on win32  \r\n\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.  \r\n\r\n```\r\n\r\n代码：\r\n\r\n```\r\n\r\n>>>> print \"Hello,World!\"   #Python 2.x  \r\n\r\nHello,World!  \r\n\r\n>>> print(\"Hello,World!\")  #Python 3.x    \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明:\r\n\r\n\r\n\r\n1. 在 Python 3.x 中，print 语句是函数，所以为 print()。\r\n\r\n2. 也可以写在 .py 文件中，同样执行。\r\n\r\n3. python2.6 及以上版本和 python3.x 基本相同，也同样可以使用 print() 来打印。\r\n\r\n\r\n\r\n## 05. C#\r\n\r\n环境：Windows\r\n\r\n```\r\n\r\nd:\\HelloWorld>csc -v  \r\n\r\nMicrosoft (R) Visual C# 2005 Compiler version 8.00.50727.4927  \r\n\r\nfor Microsoft (R) Windows (R) 2005 Framework version 2.0.50727  \r\n\r\nCopyright (C) Microsoft Corporation 2001-2005. All rights reserved. \r\n\r\n``` \r\n\r\n代码：\r\n\r\n//FileName: HelloWorld.cs  \r\nusing System;  \r\nclass TestApp  \r\n{  \r\n  public static void Main()  \r\n  {  \r\n    Console.WriteLine(\"Hello,World!\");  \r\n    Console.ReadKey();  \r\n  }  \r\n}\r\n//执行如下:  \r\n\r\n```\r\n\r\nd:\\HelloWorld>csc HelloWorld.cs  \r\n\r\nMicrosoft (R) Visual C# 2005 Compiler version 8.00.50727.4927  \r\n\r\nfor Microsoft (R) Windows (R) 2005 Framework version 2.0.50727  \r\n\r\nCopyright (C) Microsoft Corporation 2001-2005. All rights reserved.  \r\n\r\n  \r\n\r\nd:\\HelloWorld>HelloWorld.exe  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\nC# 其实和 Java 非常相像，刚才用的是命令行方式，需要设置环境变量，\r\n\r\n如果是直接下载 Microsoft Visual Studio 的话，就可以在 IDE 中用快捷键编译、运行。\r\n\r\n\r\n\r\n## 06. PHP\r\n\r\n代码：\r\n\r\n<!DOCTYPE html>  \r\n<body>  \r\n<?php  \r\necho \"Hello,World!\";            //打印语句  \r\necho \"The first php program!\";  //打印语句  \r\necho phpinfo();                 //phpinfo()系统函数,输出环境信息  \r\n?>  \r\n</body>  \r\n</html>\r\n\r\n\r\n\r\n\r\n说明：\r\n\r\n\r\n\r\n#PHP（Hypertext Preprocessor）。  \r\n\r\n#PHP 是一种 HTML 内嵌式的语言，PHP 与微软的 ASP 颇有几分相似，都是一种在服务器端执行的嵌入 HTML 文档的脚本语言。  \r\n\r\n#PHP 语言的风格类似于 C 语言，现在被很多的网站编程人员广泛地运用。  \r\n\r\n#PHP 独特的语法混合了 C、Java、Perl 以及 PHP 自创新的语法。它可以比 CGI 或者 Perl 更快速地执行动态网页。  \r\n\r\n#与其他的编程语言相比，PHP 是将程序嵌入到 HTML 文档中去执行，执行效率比完全生成 HTML 标记的 CGI 要高许多。  \r\n\r\n#与同样是嵌入 HTML 文档的脚本语言 JavaScript 相比，PHP 在服务器端执行，充分利用了服务器的性能。  \r\n\r\n#PHP 执行引擎还会将用户经常访问的 PHP 程序驻留在内存中，其他用户再一次访问这个程序时就不需要重新编译程序了，只要直接执行内存中的代码就可以了，这也是 PHP 高效率的体现之一。  \r\n\r\n#PHP 具有非常强大的功能，所有的 CGI 或者 JavaScript 的功能，PHP 都能实现，而且几乎支持所有流行的数据库以及操作系统。   \r\n\r\n\r\n\r\n## 07. JavaScript\r\n\r\n环境: node.js 或 jaxer\r\n\r\n\r\n\r\n```\r\n\r\nD:\\>node -v      \r\n\r\nv0.10.33  \r\n\r\n```\r\n\r\n代码：\r\n\r\nvar sys = require(\"sys\");    #导入需要的 sys 模块  \r\nsys.puts(\"Hello,World!\");    #调用里面的 puts 函数来打印字符串\r\n说明：\r\n\r\n```\r\n\r\nD:\\>node HelloWorld.js       #node + *.js，执行  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n#JavaScript 是 Web 的编程语言。  \r\n\r\n#所有现代的 HTML 页面都使用 JavaScript。  \r\n\r\n#JavaScript 非常容易学。  \r\n\r\n\r\n\r\n## 08. Ruby\r\n\r\n环境: ruby 1.9.3\r\n\r\n```\r\n\r\nD:\\HelloWorld>ruby -v  \r\n\r\nruby 1.9.3p429 (2013-05-15) [i386-mingw32]\r\n\r\n```\r\n\r\n代码：\r\n\r\n#可用 print 语句打印  \r\nprint \"Hello,World!\\n\"   \r\n#可用 puts 语句打印  \r\nputs  \"Hello,World!\\n\"   \r\n#可以先声明一个变量，然后再用 puts 语句  \r\na = \"Hello,World!\\n\"     \r\nputs a  \r\n#可以先写个函数再调用  \r\ndef say(name)  \r\n   \"Hello,#{name}\"  \r\nend  \r\nputs say(\"World!\")\r\n说明：\r\n\r\n```\r\n\r\nD:\\HelloWorld>ruby HelloWorld.rb     #运行方式类似 Python、Perl  \r\n\r\nHello,World!  \r\n\r\nHello,World!  \r\n\r\nHello,World!  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n\r\n\r\n## 09. R\r\n\r\n环境：R-3.1.2-win（适用于32、64位），分别有相应的 GUI\r\n\r\n```\r\n\r\nC:\\>R                  #安装好了之后，输入 R 后显示  \r\n\r\n  \r\n\r\nR version 3.1.2 (2014-10-31) -- \"Pumpkin Helmet\"  \r\n\r\nCopyright (C) 2014 The R Foundation for Statistical Computing  \r\n\r\nPlatform: i386-w64-mingw32/i386 (32-bit)  \r\n\r\n  \r\n\r\nR  \r\n\r\n  \r\n\r\n\'license()\'\'licence()\'  \r\n\r\n  \r\n\r\nR.  \r\n\r\n\'contributors()\'  \r\n\r\n\'citation()\'RR  \r\n\r\n  \r\n\r\n\'demo()\'\'help()\'  \r\n\r\n\'help.start()\'HTML  \r\n\r\n\'q()\'R.  \r\n\r\n```\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\nprint(\"Hello,World!\")\r\n\r\n```\r\n\r\n\r\n\r\n说明：\r\n\r\n\r\n\r\nR 语言，一种自由软件编程语言与操作环境，主要用于统计分析、绘图、数据挖掘。\r\n\r\n\r\n\r\n## 10. SQL\r\n\r\n环境： ORACLE SQL/PLUS\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\nSQL> select \'Hello,World!\' from dual;  \r\n\r\n  \r\n\r\n\'HELLO,WORLD  \r\n\r\n------------  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\n还可以建一个表，插入，再查询，最后删除该表。\r\n\r\n```\r\n\r\nSQL> CREATE TABLE MESSAGE (TEXT CHAR(15));            #创建表  \r\n\r\nINSERT INTO MESSAGE (TEXT) VALUES (\'Hello, world!\');  #插入表  \r\n\r\nSELECT TEXT FROM MESSAGE;                             #查询表  \r\n\r\nDROP TABLE MESSAGE;                                   #删除表               \r\n\r\nTable created.  \r\n\r\n  \r\n\r\nSQL>  \r\n\r\n1 row created.  \r\n\r\n  \r\n\r\nSQL>  \r\n\r\nTEXT  \r\n\r\n---------------  \r\n\r\nHello, world!  \r\n\r\n```\r\n\r\n\r\n\r\n## 11. Perl\r\n\r\n环境：Perl 5.16 或 MinGW\r\n\r\n\r\n\r\n```\r\n\r\nD:\\HelloWorld>perl -v  \r\n\r\n  \r\n\r\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x86-multi-thread  \r\n\r\n(with 1 registered patch, see perl -V for more detail)  \r\n\r\n  \r\n\r\nCopyright 1987-2012, Larry Wall  \r\n\r\n  \r\n\r\nBinary build 1603 [296746] provided by ActiveState xxxx  \r\n\r\nBuilt Mar 13 2013 11:29:21  \r\n\r\n  \r\n\r\nPerl may be copied only under the terms of either the Artistic License or the  \r\n\r\nGNU General Public License, which may be found in the Perl 5 source kit.  \r\n\r\n  \r\n\r\nComplete documentation for Perl, including FAQ lists, should be found on  \r\n\r\nthis system using \"man perl\" or \"perldoc perl\".  If you have access to the  \r\n\r\nInternet, point your browser at XXXXX, the Perl Home Page. \r\n\r\n```\r\n\r\n代码：\r\n\r\n```\r\n\r\n#!C:\\Perl\\bin                    #Windows 平台下  \r\n\r\n#!/usr/bin/env perl              #Linux 环境下  \r\n\r\nprint \"Hello,World!\\n\";          #print(\"Hello,World\") 也可   \r\n\r\n```\r\n\r\n输出结果：\r\n\r\n```\r\n\r\nD:\\HelloWorld>perl HelloWorld.pl #类似于 python file.py  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\n#Perl 5.10 及以上的版本可以用  \r\n\r\nuse 5.010;  \r\n\r\nsay \"Hello,World!\";  \r\n\r\n\r\n\r\n## 12. HTML\r\n\r\n环境：HTML 或 HTML 5.0\r\n\r\n\r\n\r\n代码：\r\n\r\n<!DOCTYPE html>  \r\n<html>  \r\n<body>  \r\n<h1>This is the first program!</h1>  \r\n<p>Hello,World!</p>  \r\n</body>  \r\n</html>\r\n说明：\r\n\r\n\r\n\r\n大多数主流浏览器都支持 HTML4.0，有些浏览器只支持 HTML5.0 的部分功能。\r\n\r\n\r\n\r\n## 13. VB\r\n\r\n环境：\r\n\r\n```\r\n\r\nVBC version 8.0.5\r\n\r\nD:\\Learn\\C>vbc -v  \r\n\r\nMicrosoft (R) Visual Basic Compiler version 8.0.50727.5483  \r\n\r\nfor Microsoft (R) .NET Framework version 2.0.50727.5485  \r\n\r\nCopyright (c) Microsoft Corporation.  All rights reserved.  \r\n\r\n  \r\n\r\nvbc : Command line warning BC2007 : unrecognized option \'v\'; ignored  \r\n\r\nvbc : Command line error BC2008 : no input sources specified  \r\n\r\n```\r\n\r\n代码：\r\n\r\n\'FileName: HelloWorld.rb  rb 作为 VB 源文件的后缀  \r\nModule Hello    \r\n  Sub Main()               \'程序人口函数  \r\n    MsgBox(\"Hello,World!\") \'计算机屏幕上显示信息  \r\n  End Sub                  \'End 作为程序块结尾  \r\nEnd Module                 \'单引号作为注释\r\n说明：\r\n\r\n```\r\n\r\nD:\\>vbc HelloWorld.vb      #vbs 来编译，生成 HelloWorld.exe 可执行文件  \r\n\r\nMicrosoft (R) Visual Basic Compiler version 8.0.50727.5483  \r\n\r\nfor Microsoft (R) .NET Framework version 2.0.50727.5485  \r\n\r\nCopyright (c) Microsoft Corporation.  All rights reserved.  \r\n\r\nD:\\>HelloWorld \r\n\r\n```\r\n\r\n## 14. Scala\r\n\r\n环境：scala-2.11.4.msi 编译器\r\n\r\n```\r\n\r\nd:\\>scala  \r\n\r\nWelcome to Scala version 2.11.4 (Java HotSpot(TM) Client VM, Java 1.7.0_51).  \r\n\r\nType in expressions to have them evaluated.  \r\n\r\nType :help for more information.  \r\n\r\n  \r\n\r\nscala> println(\"Hello,World!\");   #可在交互式界面执行 println 语句，很像 java  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n代码：\r\n\r\n```\r\n\r\nobject HelloWorld  \r\n\r\n{  \r\n\r\n  def main(args:Array[String])   \r\n\r\n  {  \r\n\r\n     println(\"Hello,World!\");  \r\n\r\n  }  \r\n\r\n}  \r\n\r\n//编译  \r\n\r\nd:\\HelloWorld>scala HelloWorld.scala  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\nScala 是一门把面向对象和函数式编程思想加入静态类型中的编程语言，志在以简练、优雅及类型安全的方式来表达常用编程模式。它平滑地集成了面向对象和函数语言的特性，使 Java 和其他语言的程序员使用 Scala 时更富有成效。\r\n\r\n\r\n\r\n## 15. Shell\r\n\r\n环境：Linux/Unix 平台，或安装了 MinGW 和 MSYS 的 Windows 平台\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\n#安装了MinGW和MSYS的Windows平台  \r\n\r\nD:\\HelloWorld>echo \"Hello,World!\"  \r\n\r\n\"Hello,World!\"  \r\n\r\n#Linux平台下  \r\n\r\n#echo \"Hello,World!\"   或 printf \"Hello,World!\"  \r\n\r\n#如果是写在文件中:  \r\n\r\nchmod +x  HelloWorld.sh  \r\n\r\n./HelloWorld.sh\r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\n#Shell 诞生于 Unix，是与 Linux/Unix 交互的工具，单独地学习 Shell 是没有意义的，必须先学习 Linux/Unix。  \r\n\r\n#Shell 虽然是 Unix 的第一个脚本语言，但它是相当优秀的。它结合了延展性与效率，持续保有独具的特色，并不断的被改良，功能更加强大。  \r\n\r\n#缺点：Shell 需要依赖其他程序才能完成大部分的工作，优点：简洁的脚本语言标记方式，比 C 语言编写的程序执行更快、更有效率。\r\n\r\n\r\n\r\n## 16. Delphi\r\n\r\n环境：Delphi 7\r\n\r\n\r\n\r\n代码:\r\n\r\n```\r\n\r\n[File|New|Application]-->拖一个Button、一个Label-->双击Button，编码如下：\r\n\r\n\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);  \r\n\r\nbegin  \r\n\r\n  label1.Caption := \'Hello,World!\';  \r\n\r\nend;  \r\n\r\n  \r\n\r\nprocedure TForm1.FormCreate(Sender: TObject);  \r\n\r\nbegin  \r\n\r\n  \r\n\r\nend;  \r\n\r\n  \r\n\r\nend.\r\n\r\n```  \r\n\r\n说明：\r\n\r\n\r\n\r\nDelphi，是 Windows 平台下著名的快速应用程序开发工具（Rapid Application Development，简称 RAD）。\r\n\r\n似乎很多人都觉得 Delphi 已经没落了、过时了（我身边有好多同事都没听过 Delphi）。\r\n\r\n但我不这么认为，\"真正的程序员用 C，聪明的程序员用 Delphi\"，经典无需多言，尤其是开发GUI程序，拖一下就 OK 了！！！\r\n\r\n\r\n\r\n## 17. Fortran\r\n\r\n环境：Linux 或者安装了 MinGW 的 Windows 平台\r\n\r\n```\r\n\r\nD:\\HelloWorld>gfortran -v  \r\n\r\nUsing built-in specs.  \r\n\r\nCOLLECT_GCC=gfortran  \r\n\r\nCOLLECT_LTO_WRAPPER=c:/mingw/bin/../libexec/gcc/mingw32/4.8.1/lto-wrapper.exe  \r\n\r\nTarget: mingw32  \r\n\r\nConfigured with: ../gcc-4.8.1/configure --prefix=/mingw --host=mingw32 --build=mingw32 --without-pic  \r\n\r\n --enable-shared --enable-static --with-gnu-ld --enable-lto --enable-libssp --disable-multilib --ena  \r\n\r\nble-languages=c,c++,fortran,objc,obj-c++,ada --disable-sjlj-exceptions --with-dwarf2 --disable-win32  \r\n\r\n-registry --enable-libstdcxx-debug --enable-version-specific-runtime-libs --with-gmp=/usr/src/pkg/gm  \r\n\r\np-5.1.2-1-mingw32-src/bld --with-mpc=/usr/src/pkg/mpc-1.0.1-1-mingw32-src/bld --with-mpfr= --with-sy  \r\n\r\nstem-zlib --with-gnu-as --enable-decimal-float=yes --enable-libgomp --enable-threads --with-libiconv  \r\n\r\n-prefix=/mingw32 --with-libintl-prefix=/mingw --disable-bootstrap LDFLAGS=-s CFLAGS=-D_USE_32BIT_TIM  \r\n\r\nE_T  \r\n\r\nThread model: win32  \r\n\r\ngcc version 4.8.1 (GCC)  \r\n\r\n```\r\n\r\n代码：\r\n\r\n```\r\n\r\nprogram hello  \r\n\r\nprint *,\"Hello World!\"  \r\n\r\nend program hello  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\nFortran 是最早出现的计算机语言，主要用于科学及工程计算领域，这一点和 Python 相同。\r\n\r\n```\r\n\r\nD:\\HelloWorld>gfortran -ffree-form HelloWorld.f -o out.exe  #-ffree-form 自由格式 -o 后面是输出文件  \r\n\r\n#后缀名可以为.f, .F, .f90, .fpp. 如果是 .f90 结尾的文件，可以不用 -ffree-form，因为该后缀结尾的文件默认是自由格式  \r\n\r\nD:\\HelloWorld>out      #如果是 .f 结尾的话，必须要加上，否则报错  \r\n\r\nHello World!  \r\n\r\n```\r\n\r\n\r\n\r\n## 18. TCL\r\n\r\n环境：Linux 或带有 WinGW 的 Windows 平台\r\n\r\n代码：\r\n\r\n```\r\n\r\n#命令行交互方式  \r\n\r\nD:\\>tclsh  \r\n\r\n% puts \"Hello,World!\"  \r\n\r\nHello,World!  \r\n\r\n% exit  \r\n\r\nD:>  \r\n\r\n#文件方式运行  \r\n\r\n#!/usr/local/bin/tcl  \r\n\r\nputs \"Hello, world!\"  \r\n\r\nD:\\>tclsh HelloWorld.tcl  \r\n\r\nHello,World!  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\n1. 文件名后缀 .tcl 编译器为 tclsh（命令方式显示）或 wish（GUI方式显示）。\r\n\r\n2. TCL（Tool Command Language）一种通用的脚本语言，几乎在所有平台都能运行，功能非常强。\r\n\r\n\r\n\r\n## 19. FoxPro\r\n\r\n环境：VFP9.0\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\n?\"Hello,World!\"  \r\n\r\n```\r\n\r\n\r\n\r\n说明：\r\n\r\n\r\n\r\n尽管编译、运行都通过了，GUI 界面仍然不知道如何显示编译后的结果，还是在命令行界面里运行 .FXP 文件才显示的结果。\r\n\r\nVisual FoxPro 原名 FoxBase，最初是由美国 Fox Software 公司于 1988 年推出的数据库产品，在 DOS 上运行，与 xBase 系列兼容。FoxPro 是 FoxBase 的加强版，最高版本曾出过 2.6。之后于 1992 年，Fox Software 公司被 Microsoft 收购，加以发展，使其可以在 Windows 上运行，并且更名为 Visual FoxPro。FoxPro 比 FoxBASE 在功能和性能上又有了很大的改进，主要是引入了窗口、按纽、列表框和文本框等控件，进一步提高了系统的开发能力。\r\n\r\n\r\n\r\n## 20. Ada\r\n\r\n环境：ADA95 的 gnat 编译器\r\n\r\n```\r\n\r\nd:\\HelloWorld>gnat  \r\n\r\nGNAT 4.8.1  \r\n\r\nCopyright 1996-2013, Free Software Foundation, Inc.  \r\n\r\n  \r\n\r\nList of available commands  \r\n\r\n  \r\n\r\ngnat bind               gnatbind  \r\n\r\ngnat chop               gnatchop  \r\n\r\ngnat clean              gnatclean  \r\n\r\ngnat compile            gnatmake -f -u -c  \r\n\r\ngnat check              gnatcheck  \r\n\r\ngnat elim               gnatelim  \r\n\r\ngnat find               gnatfind  \r\n\r\ngnat krunch             gnatkr  \r\n\r\ngnat link               gnatlink  \r\n\r\ngnat list               gnatls  \r\n\r\ngnat make               gnatmake  \r\n\r\ngnat metric             gnatmetric  \r\n\r\ngnat name               gnatname  \r\n\r\ngnat preprocess         gnatprep  \r\n\r\ngnat pretty             gnatpp  \r\n\r\ngnat stack              gnatstack  \r\n\r\ngnat stub               gnatstub  \r\n\r\ngnat test               gnattest  \r\n\r\ngnat xref               gnatxref  \r\n\r\n```\r\n\r\n代码：\r\n\r\n\r\n\r\n说明：\r\n\r\n\r\n\r\nAda 是一种表现能力很强的通用程序设计语言，它是美国国防部为克服软件开发危机而研发的。在经过除去 # 行获得最终处理过的文件后即可交由 GNAT 编译。\r\n\r\n\r\n\r\n## 21. AWK\r\n\r\n环境：Linux/Unix 平台，或安装了 MinGW 和 MSYS 的 Windows 平台\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\n[root@Linux ~]# echo | awk \'{print \"Hello,World!\"}\'  \r\n\r\nHello,World!  \r\n\r\n[root@Linux ~]# echo | awk \'BEGIN {print \"Hello,World!\"}\'\r\n\r\nHello,World!  \r\n\r\n[root@Linux ~]# awk \'BEGIN {print \"Hello,World!\"}\'  \r\n\r\nHello,World!  \r\n\r\n[root@Linux ~]# echo \"hello world\" | awk \'{print}\'  \r\n\r\nhello world  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\n#AWK 是一种优良的文本处理工具。它不仅是 Linux 中也是任何环境中现有的功能最强大的数据处理引擎之一。<br />\r\n\r\n#AWK 名称得自于它的创始人，分别是 Alfred Aho、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。<br />\r\n\r\n#AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。\r\n\r\n\r\n\r\n## 22. Sed\r\n\r\n环境：Linux/Unix\r\n\r\n\r\n\r\n代码：\r\n\r\n```\r\n\r\n# sed -ne \'1s/.*/Hello, world!/p\'  \r\n\r\nHello,World!                     #第一行为输入  \r\n\r\nHello, world!                    #  \r\n\r\n```\r\n\r\n说明：\r\n\r\n\r\n\r\nsed 流编辑器，和 awk、正则表达式等一起，是编写 Linux 脚本中非常有用的工具。\r\n\r\n\r\n\r\n## 23. Pascal\r\n\r\n环境：Free Pacal IDE\r\n\r\n\r\n\r\n代码：\r\n\r\n\r\n\r\nProgram HelloWorld(output);  \r\n\r\nbegin  \r\n\r\n  writeln(\'Hello, world!\') \r\n\r\n\r\n\r\n {程序块的最后一条语句后不需要\";\" - 如果添加一个\";\"，会在程序中增加一个“空语句”}  \r\n\r\nend.\r\n\r\n说明：\r\n\r\n\r\n\r\nPascal 程序开始于外部文件描述符作为参数的 program 关键字；然后跟着 begin 和 end 关键字封装的主要块。分号分区语句，句点终结整个程序（或单元）。Pascal 源代码是大小写不敏感的。这里是一个非常简单的\"Hello world\"程序示例的源代码，在实际编程中，通常可以省略第一行的output。从语法整理上来看，很像 Delphi，基本上是一个等级的。另外，FPC 编译器安装后，居然显示是乱码，看来还是要下载（Turbo Pascal）更经典些，不过听说 Turbo Pascal 下载比较难，再说，能不能在 WIN*64 位的平台编译也不知道，就下了个 FPC 用用。\r\n\r\n\r\n\r\n## 24. Prolog\r\n\r\n环境：SWI-PrologPortable 编译器\r\n\r\n\r\n\r\n代码：\r\n\r\n\r\n\r\nwrite(\"Hello,World!\").    \r\n\r\n#注意，句末有点号 \r\n\r\n\r\n\r\n\r\n\r\n说明：\r\n\r\n\r\n\r\nProlog（Programming in Logic）是一种逻辑编程语言。它建立在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现已广泛地应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。\r\n\r\n\r\n\r\n', '1', '1', '2019-02-17 01:01:10', '2019-02-17 01:01:39');
INSERT INTO `posts` VALUES ('116', '14', '0-14', '2', '14-企业应用架构模式-Web表现模式', '', '## 模型－视图－控制器（Ｍｏｄｅｌ　Ｖｉｅｗ　Ｃｏｎｔｒｏｌｌｅｒ）\r\n\r\n## 页面控制器（Page Controller）\r\n\r\n## 前端控制器(Front Controller)\r\n\r\n## 模板试图（Template View）\r\n\r\n## 转换试图（Transform View）\r\n\r\n## 两步试图（Two Step View）\r\n\r\n## 应用控制器（Appliacction Controller）', '1', '1', '2019-02-20 07:14:54', '2019-02-20 07:19:46');
INSERT INTO `posts` VALUES ('117', '3', '0-3', '2', 'Linux下安装SVN服务端小白教程', '', '\r\n> 安装\r\n\r\n使用yum安装非常简单：\r\n```\r\nyum install subversion\r\n```\r\n> 配置\r\n\r\n## 2.1. 创建仓库\r\n我们这里在/home下建立一个名为svn的仓库（repository），以后所有代码都放在这个下面，创建成功后在svn下面多了几个文件夹。\r\n```\r\n[root@localhost /]# cd /home\r\n[root@localhost home]# mkdir svn\r\n[root@localhost home]# svnadmin create /home/svn\r\n[root@localhost home]# ls svn\r\nconf  db  format  hooks  locks  README.txt\r\n```\r\n我们这里特别关注一下conf文件夹，这个是存放配置文件的\r\n```\r\n[root@localhost home]# cd svn/conf\r\n[root@localhost conf]# ls\r\nauthz  passwd  svnserve.conf\r\n```\r\n其中：\r\n\r\nauthz 是权限控制文件\r\n\r\npasswd 是帐号密码文件\r\n\r\nsvnserve.conf 是SVN服务配置文件\r\n\r\n接下来我们依次修改这3个文件。\r\n\r\n## 2.2. 配置passwd\r\n```\r\n[root@localhost conf]# vi passwd \r\n[users]\r\ntest1=123456\r\ntest2=123456\r\n```\r\n上面的例子中我们创建了2个用户，一个test1，一个test2\r\n\r\n\r\n\r\n## 2.3. 配置authz\r\n```\r\n[root@localhost conf]# vi authz \r\n[/]\r\nmeiyoufan=rw\r\ntest1=r\r\ntest2=r\r\n*=\r\n```\r\n上面配置的含义是，meiyoufan对/home/svn/下所有文件具有可读可写权限，test只有只读权限，除此之外，其它用户均无任何权限，最后一行*=很重要不能少。\r\n\r\n## 2.3.1. 拓展：使用用户分组\r\n这个我一般不用，但是记录下来。\r\n\r\n还是这个文件：\r\n```\r\n[root@localhost conf]# vi authz\r\n[groups]\r\ngroup1 = meiyoufan\r\ngroup2 = test1,test2\r\n[/]\r\n@group1 = rw\r\n@group2 = r\r\n* =\r\n```\r\n上面配置中创建了2个分组，分组1的用户可读可写，分组2的用户只读。\r\n\r\n格式说明：\r\n\r\n版本库目录格式：\r\n```\r\n[<版本库>:/项目/目录]\r\n@<用户组名> = <权限>\r\n<用户名> = <权限>\r\n```\r\n\r\n## 2.4. 配置svnserve.conf\r\n```\r\n[root@localhost conf]# vi svnserve.conf \r\n```\r\n打开下面的5个注释\r\n```\r\nanon-access = read #匿名用户可读\r\nauth-access = write #授权用户可写\r\npassword-db = passwd #使用哪个文件作为账号文件\r\nauthz-db = authz #使用哪个文件作为权限文件\r\nrealm = /home/svn # 认证空间名，版本库所在目录\r\n```\r\n> 2点注意：\r\n\r\n最后一行的realm记得改成你的svn目录\r\n\r\n打开注释时切记前面不要留有空格，否则可能有问题（网上说的，我没有亲测）\r\n\r\n**启动与停止**\r\n```\r\n[root@localhost conf]# svnserve -d -r /home/svn（启动）\r\n[root@localhost conf]#killall svnserve（停止）\r\n```\r\n上述启动命令中，-d表示守护进程， -r 表示在后台执行。停止还可以采用杀死进程的方式：\r\n```\r\n[root@localhost conf]# ps -ef|grep svnserve\r\nroot      4908     1  0 21:32 ?        00:00:00 svnserve -d -r /home/svn\r\nroot      4949  4822  0 22:05 pts/0    00:00:00 grep svnserve\r\n[root@localhost conf]# kill -9 4908\r\n```\r\n\r\n> 客户端连接\r\n\r\n这里使用TortoiseSVN，输入地址svn://你的IP 即可，不出意外输入用户名和密码就能连接成功了。\r\n\r\n默认端口3690，如果你修改了端口，那么要记得加上端口号。\r\n\r\n\r\n> 总结\r\n\r\n总的来说，如果你不需要杂七杂八的权限配置只是自己一个人用的话，安装配置还是比较简单的，并不像网上说的那么麻烦，我按照网上的方法一次性成功了。', '1', '1', '2019-02-20 22:49:17', '2019-02-20 22:52:58');
INSERT INTO `posts` VALUES ('118', '14', '0-14', '2', '15-企业应用架构模式-分布模式', '', '## 1.远程外观\r\n（Remote Facade）\r\n### 1.1运行机制\r\n### 1.2使用时机\r\n\r\n## 2.数据传输对象\r\n（Data Transfer Object）\r\n### 2.1 运行机制\r\n### 2.2 使用时机\r\n### 2.3 进一步阅读\r\n', '1', '1', '2019-02-20 23:48:04', '2019-02-20 23:51:32');
INSERT INTO `posts` VALUES ('119', '14', '0-14', '2', '16-企业应用架构模式-离线并发模式', '', '## 1.乐观离线锁\r\n（Optimistic Offline Lock）\r\n### 运行机制\r\n### 使用时机\r\n### 例：领域层与数据层数据映射器\r\n\r\n## 2.悲观离线锁\r\n（Pessimistic Offline Lock）\r\n### 运行机制\r\n### 使用时机\r\n### 例：简单锁管理对象\r\n\r\n## 3.粗粒度锁\r\n（Coarse-Grained Lock）\r\n### 运行机制\r\n### 使用时机\r\n### 例：共享的乐观离线锁\r\n### 例：共享的悲观离线锁\r\n### 例：根对象乐观离线锁\r\n\r\n## 4.隐含锁\r\n（Implicit Lock）\r\n### 运行机制\r\n### 使用时机\r\n### 例：隐含的悲观离线锁', '1', '1', '2019-02-22 07:48:15', '2019-02-22 07:54:19');
INSERT INTO `posts` VALUES ('120', '3', '0-3', '2', 'Apache三种工作模式介绍与配置', '', '## 一、Apache的三种工作模式介绍及相关查看方法\r\n### 1、Apache三种工作模式简介\r\nApache目前一共有三种稳定的MPM（Multi-Processing Module，多进程处理模块）模式。它们分别是prefork，worker和event，它们同时也代表这Apache的演变和发展。\r\n\r\nApache在configure配置编译参数的时候，可以使用 --with-mpm=prefork|worker|event 来指定编译为那一种MPM，当然也可以用编译为三种都支持：--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM。\r\n\r\n \r\n\r\n### 2、Apache工作模式查看方法\r\n在Linux中，我们yum安装的Apache可以用httpd –l，编译安装的Apache可以使用Apache安装路径下面的bin/apachectl -l 查看安装的模块是prefork模式还是worker模式（默认是prefork模式）。\r\n\r\n方法1：可查看Apache工作模式（这里使用的是prefork模式）\r\n```\r\n[root@localhost ~]# /usr/local/apache2/bin/apachectl -l\r\n\r\nCompiled in modules:\r\n\r\n  core.c\r\n\r\n  mod_so.c\r\n\r\n  http_core.c\r\n\r\n  prefork.c\r\n```\r\n方法2：可查看Apache版本信息及工作模式（这里使用的是worker模式）\r\n```\r\n[root@localhost ~]# /usr/local/apache2/bin/apachectl -V\r\n\r\nServer version: Apache/2.4.7 (Unix)\r\n\r\nServer built:   Apr 17 2018 11:12:53\r\n\r\nServer\'s Module Magic Number: 20120211:27\r\n\r\nServer loaded:  APR 1.6.3, APR-UTIL 1.6.1\r\n\r\nCompiled using: APR 1.6.3, APR-UTIL 1.6.1\r\n\r\nArchitecture:   64-bit\r\n\r\nServer MPM:     worker\r\n\r\n  threaded:     yes (fixed thread count)\r\n\r\n    forked:     yes (variable process count)\r\n```\r\n3、查看Apache编译安装的参数\r\n```\r\n[root@localhost ~]# cat  /usr/local/apache2/build/config.nice\r\n\r\n#! /bin/sh\r\n\r\n#\r\n\r\n# Created by configure\r\n\r\n\"./configure\" \\\r\n\r\n\"--prefix=/usr/local/apache2\" \\\r\n\r\n\"--with-apr=/usr/local/apr\" \\\r\n\r\n\"--with-apr-util=/usr/local/apr-util\" \\\r\n\r\n\"--enable-deflate\" \\\r\n\r\n\"--enable-expires\" \\\r\n\r\n\"--enable-headers\" \\\r\n\r\n\"--enable-modules=most\" \\\r\n\r\n\"--enable-so\" \\\r\n\r\n\"--with-mpm=worker\" \\\r\n\r\n\"--enable-rewrite\" \\\r\n\r\n\"--enable-charset-lite\" \\\r\n\r\n\"--enable-cgid\" \\\r\n\r\n\"--enable-cgi\" \\\r\n\r\n\"$@\"\r\n```\r\n\r\n## 二、Apache的prefork工作模式原理及相关介绍\r\n### 1、Apache的prefork模式工作原理\r\nprefork模式（默认模式）是很古老但是非常稳定的模式。使用的是多个子进程，Apache在启动之初，控制进程会建立若干个子进程，然后等待请求进来，并且总是视图保持一些备用的子进程。为了不在请求到来时再生成子进程，所以要根据需求不断的创建新的子进程，最大可以达到每秒32个直到满足需求为止。之所以这样做，是为了减少频繁创建和销毁进程的开销。每个子进程中只有一个线程，在一个时间点内，只能处理一个请求。\r\n\r\n在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。\r\n\r\n### 2、Apache的prefork模式安装方法\r\n在编译安装Apache的过程中，加入参数--with-mpm=prefork即可，如果不加也可以，因为Apache默认会采用prefork模式进行编译安装。也可以使用--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM即可。\r\n\r\n### 3、Apache的prefork模式优缺点\r\n优点：成熟，兼容所有新老模块。进程之间完全独立，使得它非常稳定。同时，不需要担心线程安全的问题。（我们常用的mod_php，PHP的拓展不需要支持线程安全）\r\n\r\n缺点：一个进程相对占用更多的系统资源，消耗更多的内存。而且，它并不擅长处理高并发请求，在这种场景下，它会将请求放进队列中，一直等到有可用进程，请求才会被处理。\r\n\r\n### 4、Apache的prefork模式配置参数说明\r\n```\r\n[root@localhost ~]# vim /usr/local/apache2/conf/extra/ httpd-mpm.conf\r\n```\r\n```\r\n<IfModule mpm_prefork_module>\r\n\r\n    StartServers             5       服务启动时初始的进程数，默认5\r\n\r\n    MinSpareServers          5      最小的空闲子进程数，默认5\r\n\r\n    MaxSpareServers         10      最大的空闲子进程数，默认10\r\n\r\nMaxRequestWorkers      250    \r\n\r\n限定同一时间内客户端最大接入的请求数量，默认是250  \r\n\r\nMaxConnectionsPerChild   0      \r\n\r\n每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。\r\n\r\n</IfModule>\r\n```\r\n\r\n## 三、Apache的worker模式工作原理及相关介绍\r\n### 1、Apache的worker模式工作原理\r\nworker模式和prefork模式相比，worker模式使用了多进程和多线程的混合模式，worker模式也同样会先预派生一些子进程，然后每个子进程创建一些线程，同时包括一个监听线程，每个请求过来会被分配到一个线程来服务。线程比起进程会更轻量，因为线程是通过共享父进程的内存空间，因此，内存的占用会减少一些，在高并发的场景下会比prefork有更多可用的线程，表现会更优秀一些。\r\n\r\n另外，如果一个线程出现了问题也会导致同一进程下的线程出现问题，如果是多个线程出现问题，也只是影响Apache的一部分，而不是全部。由于用到多进程多线程，需要考虑到线程的安全了，在使用keep-alive长连接的时候，某个线程会一直被占用，即使中间没有请求，需要等待到超时才会被释放（该问题在prefork模式下也存在）。\r\n\r\nApache总是试图维持一个备用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予他较少的特权。另外，除非使用了suexec ，否则，这些指令配置的权限将被CGI脚本所继承。\r\n\r\n### 2、Apache的worker模式安装方法\r\n在编译安装Apache的过程中，加入参数--with-mpm=worker即可进行编译安装。也可以使用--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM即可。\r\n\r\n### 3、Apache的worker模式优缺点\r\n优点：占据更少的内存，高并发下表现更优秀。\r\n\r\n缺点：必须考虑线程安全的问题，因为多个子线程是共享父进程的内存地址的。如果使用keep-alive的长连接方式，也许中间几乎没有请求，这时就会发生阻塞，线程被挂起，需要一直等待到超时才会被释放。如果过多的线程，被这样占据，也会导致在高并发场景下的无服务线程可用。（该问题在prefork模式下，同样会发生）。\r\n\r\n \r\n\r\n说明：http1.1的keep-alive的长连接方式，是为了让下一次的socket通信复用之前创建的连接，从而，减少连接的创建和销毁的系统开销。保持连接，会让某个进程或者线程一直处于等待状态，即使没有数据过来。\r\n\r\n### 4、Apache的worker模式配置参数说明\r\n```\r\n<IfModule mpm_worker_module>\r\n\r\n    StartServers             3       服务启动时初始的进程数，默认3\r\n\r\n    MinSpareThreads         75     最小的空闲子进程数，默认75\r\n\r\n    MaxSpareThreads        250      最大的空闲子进程数，默认250\r\n\r\n    ThreadsPerChild         25      每个子进程产生的线程数量，默认是25\r\n\r\nMaxRequestWorkers      400   \r\n\r\n限定同一时间内客户端最大接入的请求数量，默认是400\r\n\r\n \r\n\r\nMaxConnectionsPerChild   0\r\n\r\n每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。\r\n\r\n</IfModule>\r\n```\r\nWorker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild 值决定的，应该大于等于MaxRequestWorkers。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时 也需要显式声明ServerLimit（最大值是20000）。需要注意的是，如果显式声明了ServerLimit，那么它乘以 ThreadsPerChild的值必须大于等于MaxRequestWorkers，而且MaxRequestWorkers必须是ThreadsPerChild的整数倍，否则 Apache将会自动调节到一个相应值。\r\n\r\n## 四、Apache的event模式工作原理及相关介绍\r\n### 1、Apache的event模式工作原理\r\nevent是Apache最新的工作模式，它和worker模式很像，不同的是在于它解决了keep-alive长连接的时候占用线程资源被浪费的问题（某些线程因为被keep-alive，挂在那里等待，中间几乎没有请求过来，一直等到超时）。\r\n\r\n在event工作模式中，会有一些专门的线程用来管理这些keep-alive类型的线程，当有真实请求过来的时候，将请求传递给服务器的线程，执行完毕后，又允许它释放。这样，一个线程就能处理几个请求了，实现了异步非阻塞。这增强了在高并发场景下的请求处理。\r\n\r\nevent工作模式在遇到某些不兼容的模块时，会失效，将会回退到worker模式，一个工作线程处理一个请求。官方自带的模块，全部是支持event工作模式的。\r\n\r\nevent工作模式需要Linux系统（Linux 2.6+）对epoll的支持，才能启用。需要补充的是HTTPS的连接（SSL），它的运行模式仍然是类似worker的方式，线程会被一直占用，知道连接关闭。部分比较老的资料里，说event MPM不支持SSL，那个说法是几年前的说法，现在已经支持了。\r\n\r\n### 2、Apache的event模式安装方法\r\n在编译安装Apache的过程中，加入参数--with-mpm=event即可进行编译安装。也可以使用--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM即可。\r\n\r\n### 3、Apache的worker模式配置参数说明\r\n```\r\n<IfModule mpm_event_module>\r\n\r\n    StartServers             3    服务启动时初始的进程数，默认3\r\n\r\n    MinSpareThreads         75  最小的空闲子进程数，默认75\r\n\r\n    MaxSpareThreads        250  最大的空闲子进程数，默认250\r\n\r\n    ThreadsPerChild         25   每个子进程产生的线程数量，默认是25\r\n\r\nMaxRequestWorkers      400  \r\n\r\n限定同一时间内客户端最大接入的请求数量，默认是400\r\n\r\n \r\n\r\nMaxConnectionsPerChild   0\r\n\r\n每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。\r\n\r\n</IfModule>\r\n```\r\n \r\n\r\n## 五、工作模式与web应用的选择\r\nApache能更好的为有特殊要求的站点定制。例如，要求 更高伸缩性的站点可以选择使用线程的 MPM，即 worker 或 event； 需要可靠性或者与旧软件兼容的站点可以使用 prefork。就使用PHP而言，fastCGI和php-fpm是更推荐的使用模式。\r\n\r\n现在的最新浏览器，在单个域名下的连接数变得越来越多（通常都是使用keep-alive），主流浏览器是2-6个（还有继续增长趋势，为了加快页面的并发下载速度）。高并发场景，会越来越成为Web系统的一种常态。Apache很成熟，同时也背负了比较重的历史代码和模块，因此，在Web系统比较方面，Nginx在不少场景下，表现比起Apache更为出色。', '1', '1', '2019-02-22 23:52:35', '2019-02-22 23:56:39');
INSERT INTO `posts` VALUES ('121', '14', '0-14', '2', '17-企业应用架构模式-会话状态模式', '', '##　１．客户会话状态\r\n（Client Session State）\r\n### 1.运行机制\r\n### 2.使用时机\r\n\r\n## 2.服务器会话状态\r\n（Server Session State）\r\n### 1.运行机制\r\n### 2.使用时机\r\n\r\n## 3.数据库会话状态\r\n（Database Session State）\r\n### 1.运行机制\r\n### 2.使用时机\r\n', '1', '1', '2019-02-23 07:57:47', '2019-02-25 08:22:14');
INSERT INTO `posts` VALUES ('122', '3', '0-3', '2', '隐藏入口文件', '', '```\r\nserver {\r\n        listen       80;\r\n        server_name  oneweb.cn www.oneweb.cn;\r\n        root   \"D:\\WWW\\Ci_vote\";\r\n        location / {\r\n            index  index.html index.htm index.php;\r\n            autoindex  on;\r\n			if (!-e $request_filename) {\r\n			   rewrite  ^(.*)$  /index.php?s=$1  last;\r\n			   break;\r\n			}\r\n        }\r\n        location ~ \\.php(.*)$ {\r\n            fastcgi_pass   127.0.0.1:9000;\r\n            fastcgi_index  index.php;\r\n            fastcgi_split_path_info  ^((?U).+\\.php)(/?.+)$;\r\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n            fastcgi_param  PATH_INFO  $fastcgi_path_info;\r\n            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;\r\n            include        fastcgi_params;\r\n        }\r\n}\r\n```\r\nadd\r\n```\r\nif (!-e $request_filename) {\r\n  rewrite  ^(.*)$  /index.php?s=$1  last;\r\n  break;\r\n}\r\n```', '1', '1', '2019-02-23 21:18:46', '2019-02-23 21:19:38');
INSERT INTO `posts` VALUES ('123', '14', '0-14', '2', '18-企业应用架构模式-基本模式', '', '## 1.入口\r\n（Gateway）\r\n### 1.运行机制\r\n### 2.使用时机\r\n\r\n## 2.映射器\r\n（Mapper）\r\n### 1.运行机制\r\n### 2.使用时机\r\n\r\n## 3.层超类型\r\n（Layer Supertype）\r\n### 1.运行机制\r\n### 2.使用时机\r\n\r\n## 4.分离接口\r\n（ Separated Interface）\r\n\r\n## 5.注册表\r\n（Registry）\r\n\r\n## 6.值对象\r\n（Value Object）\r\n\r\n## 7.货币\r\n（Money）\r\n\r\n## 8.特殊情况\r\n（Special Case）\r\n\r\n## 9.插件\r\n（Plugin）\r\n\r\n## 10.服务桩\r\n（Service Stub）\r\n\r\n## 11.记录集\r\n（Record Set）', '1', '1', '2019-02-25 08:15:57', '2019-02-25 08:22:03');
INSERT INTO `posts` VALUES ('124', '3', '0-3', '2', 'php56版本部分ajax错误HTTP_RAW_POST_DATA已被弃用头部错误原因', '', '不推荐使用：自动填充$ HTTP_RAW_POST_DATA已弃用，将在以后的版本中删除。\r\n\r\n要避免此警告，请在php.ini中将\'always_populate_raw_post_data\'设置为\'-1\'，然后使用php：//输入流。\r\n\r\n在第0行的未知中警告：无法修改标题信息 - 已在第0行的未知中发送的标题\r\n\r\n\r\n解决方案：\r\n\r\n打开php.ini的配置文件，找到以下代码\r\n```\r\n; Always populate the $HTTP_RAW_POST_DATA variable. PHP\'s default behavior is\r\n; to disable this feature and it will be removed in a future version.\r\n; If post reading is disabled through enable_post_data_reading,\r\n; $HTTP_RAW_POST_DATA is *NOT* populated.\r\n; http://php.net/always-populate-raw-post-data\r\n; always_populate_raw_post_data = -1\r\n```\r\n\r\n将\r\n```\r\n;always_populate_raw_post_data = -1\r\n```\r\n改成\r\n```\r\nalways_populate_raw_post_data = -1\r\n```', '1', '1', '2019-02-25 11:40:00', '2019-02-25 11:41:11');
INSERT INTO `posts` VALUES ('125', '3', '0-3', '2', '三个数比较大小——C语言经典题目', '', '这道题是每一位初学C的小伙伴们的必经之路，其经典性简直如同Hello World！\r\n\r\n下面写一下几种不同的解法。\r\n\r\n使用if语句\r\n```\r\n#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a, b, c, max;//逗号,(大/中/普通)括号，右端需有空白字符\r\n	\r\n	scanf(\"%d%d%d\", &a, &b, &c);\r\n	\r\n	if( a>b)    max = a;//为了代码可视性高，操作符需被空白字符包围\r\n	else        max = b;\r\n	if( c>max)  max = c;\r\n	\r\n	printf(\"max=%d\", max);\r\n	\r\n	return 0;\r\n}\r\n``` \r\n\r\n## 使用三目运算符\r\n？：条件运算符，使用方法是<表达式1> ？<表达式2> ：<表达式3>，意思是满足表达式1就执行表达式2，否则执行表达式3。\r\n```\r\n#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a, b, c, max;\r\n	\r\n	scanf(\"%d%d%d\", &a, &b, &c);\r\n	\r\n	max = a>b ? a:b;\r\n	max = c>max ? c:max;\r\n	\r\n	printf(\"max=%d\", max);\r\n	\r\n	return 0;\r\n}\r\n```\r\n\r\n```\r\na>b ? (max = a) : (max = b); c>max ? (max = c) : max ;\r\n\r\nmax = ( (a>b ? a:b) > c) ? (a>b ? a:b) : c;\r\n```\r\n以上三种方法均可以比较出三个数的最大值，区别在于例子中的方法是使用的赋值语句，而替代方法1是运用的标准条件运算，后面的替代方法2则是以赋值语句为主的两重（条件运算的）嵌套。\r\n\r\n补充：替代方法2不能写成max = ( (a>b?a:b) > c ) ? ():c;。\r\n因为在三目运算符?的前置条件中(a>b?a:b)的运算结果是没有分配储存地址的，只是开辟了临时地址（理解成缓存也行，程序结束便清空），这就导致后面的()根本无法从前面取得值，所以得再写一次表达式。\r\n\r\n## 使用max函数——if语句\r\n```\r\n#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a, b, c, max;\r\n	int Max( int x, int y, int z);//声明自定义函数Max\r\n	\r\n	scanf(\"%d%d%d\", &a, &b, &c);\r\n	\r\n	max = Max( a,b,c);\r\n	\r\n	printf(\"max=%d\", max);\r\n	return 0;\r\n}\r\n\r\nint Max(int x, int y, int z)\r\n{\r\n	int max;//不同的函数中可以使用同名（局部）变量\r\n	\r\n	if( x>y)    max = x;\r\n	else        max = y;\r\n	if( z>max)  max = z;\r\n	\r\n	return max;\r\n}\r\n```\r\n\r\n## 使用max函数——三目运算符\r\n```\r\n#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a, b, c;\r\n	int Max( int x, int y);\r\n	\r\n	scanf(\"%d%d%d\", &a, &b, &c);\r\n	printf(\"max=%d\", Max(Max(a,b),c) );//调用两重Max函数嵌套\r\n	\r\n	return 0;\r\n}\r\n\r\nint Max(int x, int y)\r\n{\r\n	return x>y?x:y;\r\n}\r\n```\r\n \r\n其中printf语句里的两重函数嵌套不能写成Max( (a,b) ,c)，因为这个(a,b)并不符合自定义Max函数的传参要求。\r\n\r\n自定义Max函数int Max(int x, int y)的形参为整型变量int x, int y，所以在调用Max函数时，需要传入符合定义要求的int型参数，那么显然这个(a,b)并不是int型参数，它是一个不属于任何类型的不完整表达式，其没有实际意义。\r\n\r\n不过，两重Max函数嵌套写成Max( Max(a,b) ,c)是符合要求的，因为Max(a,b)的函数返回值符合int x的传参要求，究其原因是其内部return语句中返回的x>y?x:y是一个int型值。\r\n\r\n使用指针\r\n```\r\n#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a, b, c;\r\n	int Max( int x, int y);\r\n	int (*p)(int, int) = &Max;//对指针p赋初值为Max的地址，&可省略\r\n	\r\n	scanf(\"%d%d%d\", &a, &b, &c);\r\n	printf(\"max=%d\", p(p(a,b) ,c) );\r\n	\r\n	return 0;\r\n}\r\n\r\nint Max(int x, int y)\r\n{\r\n	return x>y?x:y;\r\n}\r\n```\r\n \r\n这个有关于数字比较之类的问题，在C语言中是非常经典的一块，于是写了几种方法来开拓一下自己思路。也希望可以通过对这个题目的不同解法，来为之后像回溯和指针之类的知识稍微做一下铺垫，嘿，大家一起来感受一下。\r\n ', '1', '1', '2019-03-03 16:17:55', '2019-03-03 16:21:27');
INSERT INTO `posts` VALUES ('126', '3', '0-3', '2', 'MySQL命名、设计及使用规范', '', '## 数据库环境\r\n- dev：开发环境，开发可读写，可修改表结构。开发人员可以修改表结构，可以随意修改其中的数据但是需要保证不影响其他开发同事。\r\n\r\n- qa：测试环境，开发可读写，开发人员可以通过工具修改表结构。\r\n\r\n- sim：模拟环境，开发可读写，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用。\r\n\r\n- real：生产数据库从库（准实时同步），只读环境，不允许修改数据，不允许修改表结构，供线上问题查找，数据查询等使用。\r\n\r\n- online：线上环境，开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找DBA进行操作并进行相应记录，禁止进行压力测试。\r\n\r\n这些环境的机器，一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_account，r_ account 分别代表读、写账号，account是读写账号。\r\n\r\n## 命名规范\r\n\r\n### 基本命名原则\r\n\r\n- 使用有意义的英文词汇，词汇中间以下划线分隔。（不要用拼音）\r\n- 只能使用英文字母，数字，下划线，并以英文字母开头。\r\n- 库、表、字段全部采用小写，不要使用驼峰式命名。\r\n- 避免用ORACLE、MySQL的保留字，如desc，关键字如index。\r\n- 命名禁止超过32个字符，须见名之意，建议使用名词不是动词\r\n- 数据库，数据表一律使用前缀\r\n- 临时库、表名必须以tmp为前缀，并以日期为后缀\r\n- 备份库、表必须以bak为前缀，并以日期为后缀\r\n\r\n>为什么库、表、字段全部采用小写？\r\n在 MySQL 中，数据库和表对就于那些目录下的目录和文件。\r\n因而，操作系统的敏感性决定数据库和表命名的大小写敏感。\r\n\r\n>Windows下是不区分大小写的。\r\n\r\n>Linux下大小写规则：\r\n\r\n>数据库名与表名是严格区分大小写的；\r\n\r\n>表的别名是严格区分大小写的；\r\n\r\n>列名与列的别名在所有的情况下均是忽略大小写的；\r\n\r\n>变量名也是严格区分大小写的；\r\n\r\n>如果已经设置了驼峰式的命名如何解决？需要在MySQL的配置文件my.ini中增加 lower_case_table_names = 1即可。\r\n\r\n### 表命名\r\n\r\n- 同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。所有日志表均以 log_ 开头\r\n\r\n### 字段命名\r\n\r\n- 表达其实际含义的英文单词或简写。布尔意义的字段以“is_”作为前缀，后接动词过去分词。\r\n- 各表之间相同意义的字段应同名。各表之间相同意义的字段，以去掉模块前缀的表名_字段名命名。\r\n- 外键字段用表名_字段名表示其关联关系。\r\n- 表的主键一般都约定成为id，自增类型，是别的表的外键均使用xxx_id的方式来表明。\r\n\r\n### 索引命名\r\n\r\n- 非唯一索引必须按照“idx_字段名称_字段名称[_字段名]”进行命名\r\n- 唯一索引必须按照“uniq_字段名称_字段名称[_字段名]”进行命名\r\n\r\n### 约束命名\r\n\r\n- 主键约束：pk_表名称。\r\n- 唯一约束：uk_表名称_字段名。（应用中需要同时有唯一性检查逻辑。）\r\n\r\n### 触发器命名\r\n\r\n-  trg_表名_操作。\r\n\r\n### 函数过程命名\r\n\r\n- 采用动词+名词的形式表达其含义。\r\n\r\n### 序列命名\r\n\r\n- seq_表名\r\n\r\n## 表设计规范\r\n1、表引擎取决于实际应用场景；日志及报表类表建议用myisam，与交易，审核，金额相关的表建议用innodb引擎。如无说明，建表时一律采用innodb引擎。myisam与innodb的区别\r\n\r\n2、默认使用utf8mb4字符集，数据库排序规则使用utf8mb4_general_ci，（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上）。\r\n\r\n>为什么字符集不选择utf8，排序规则不使用utf8_general_ci？\r\n\r\n>采用utf8编码的MySQL无法保存占位是4个字节的Emoji表情。为了使后端的项目，全面支持客户端输入的Emoji表情，升级编码为utf8mb4是最佳解决方案。对于JDBC连接串设置了characterEncoding为utf8或者做了上述配置仍旧无法正常插入emoji数据的情况，需要在代码中指定连接的字符集为utf8mb4。\r\n\r\n3、所有表、字段均应用 comment 列属性来描述此表、字段所代表的真正含义，如枚举值则建议将该字段中使用的内容都定义出来。\r\n\r\n4、如无说明，表中的第一个id字段一定是主键且为自动增长，禁止在非事务内作为上下文作为条件进行数据传递。禁止使用varchar类型作为主键语句设计。\r\n\r\n5、如无说明，表必须包含create_time和modify_time字段，即表必须包含记录创建时间和修改时间的字段\r\n\r\n6、如无说明，表必须包含is_del，用来标示数据是否被删除，原则上数据库数据不允许物理删除。\r\n\r\n7、用尽量少的存储空间来存数一个字段的数据\r\n\r\n- 能用int的就不用char或者varchar\r\n- 能用tinyint的就不用int\r\n- 使用UNSIGNED存储非负数值。\r\n- 不建议使用ENUM、SET类型，使用TINYINT来代替\r\n- 使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED\r\n- 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE\r\n- 时间字段，除特殊情况一律采用int来记录unix_timestamp\r\n  - 存储年使用YEAR类型。\r\n  - 存储日期使用DATE类型。\r\n  - 存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。\r\n- 建议使用INT UNSIGNED存储IPV4。\r\n- 尽可能不使用TEXT、BLOB类型\r\n- 禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。建议使用其他方式存储（TFS/SFS），MySQL只保存指针信息。\r\n-单条记录大小禁止超过8k（列长度(中文)*3(UTF8)+列长度(英文)*1）\r\n\r\n>datetime与timestamp有什么不同？\r\n\r\n相同点：\r\n\r\nTIMESTAMP列的显示格式与DATETIME列相同。显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。\r\n\r\n不同点：\r\n\r\n- TIMESTAMP\r\n  - 4个字节储存，时间范围：1970-01-01 08:00:01 ~ 2038-01-19 11:14:07\r\n  - 值以UTC格式保存，涉及时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。\r\n- datetime\r\n  -8个字节储存，时间范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\r\n  - 实际格式储存，与时区无关\r\n\r\n>如何使用TIMESTAMP的自动赋值属性？\r\n\r\n- 将当前时间作为ts的默认值：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP。\r\n- 当行更新时，更新ts的值：ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP。\r\n- 可以将1和2结合起来：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。\r\n\r\n>如何使用INT UNSIGNED存储ip？\r\n\r\n- 使用INT UNSIGNED而不是char(15)来存储ipv4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。\r\n- Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。\r\n\r\n8、如无备注，所有字段都设置NOT NULL，并设置默认值；\r\n\r\n9、禁止在数据库中存储明文密码\r\n\r\n10、如无备注，所有的布尔值字段，如is_hot、is_deleted，都必须设置一个默认值，并设为0；\r\n\r\n11、如无备注，排序字段order_id在程序中默认使用降序排列；\r\n\r\n12、整形定义中不添加长度，比如使用INT，而不是INT[4]\r\n\r\n>INT[M]，M值代表什么含义？\r\n\r\n>注意数值类型括号后面的数字只是表示宽度而跟存储范围没有关系。很多人他们认为INT(4)和INT(10)其取值范围分别是 (-9999到9999)和(-9999999999到9999999999)，这种理解是错误的。其实对整型中的 M值与 ZEROFILL 属性结合使用时可以实现列值等宽。不管INT[M]中M值是多少，其取值范围还是 (-2147483648到2147483647 有符号时)，(0到4294967295无符号时)。\r\n\r\n>显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。当结合可选扩展属性ZEROFILL使用时默认补充的空格用零代替。例如：对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度，如果为一个数值列指定ZEROFILL, MySQL自动为该列添加UNSIGNED属性。\r\n\r\n13、使用VARBINARY存储大小写敏感的变长字符串\r\n\r\n> ### 什么时候用CHAR，什么时候用VARCHAR？\r\n\r\n>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR(30)可以占用30个字符。\r\n\r\n> - CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。\r\n- VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。\r\n同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。\r\n\r\n>char适合存储用户密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar,因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。char(1)字符串对于单字节字符集只会占用一个字节，但是varchar(1)则会占用2个字节，因为1个字节用来存储长度信息。\r\n\r\n## 索引设计规范\r\nMySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。\r\n\r\n合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。\r\n\r\nMySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。\r\n\r\n当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。\r\n\r\n索引的用途：去重、加速定位、避免排序、覆盖索引。\r\n\r\n## 什么是覆盖索引？\r\n\r\nInnoDB存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。\r\n\r\n如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。\r\n\r\n覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。\r\n\r\n合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。\r\n\r\n比如SELECT email,uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升。\r\n\r\n## 索引的基本规范\r\n\r\n### 1、索引数量控制，单张表中索引数量不超过5个，单个索引中的字段数不超过5个。\r\n\r\n- 综合评估数据密度和分布\r\n- 考虑查询和更新比例\r\n\r\n>为什么一张表中不能存在过多的索引？\r\n\r\n>InnoDB的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。\r\n\r\n### 2、对字符串使用前缀索引，前缀索引长度不超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引。\r\n\r\n- 不要索引blob/text等字段,不要索引大型字段,这样做会让索引占用太多的存储空间\r\n\r\n>什么是前缀索引？\r\n\r\n>前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。 \r\n>前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。\r\n\r\n>建立前缀索引的语法：ALTER TABLE table_name ADD KEY(column_name(prefix_length));\r\n\r\n### 3、主键准则\r\n\r\n- 表必须有主键\r\n- 不使用更新频繁的列\r\n- 尽量不选择字符串列\r\n- 不使用UUID MD5 HASH\r\n- 默认使用非空的唯一键\r\n- 建议选择自增或发号器\r\n\r\n### 4、 重要的SQL必须被索引，核心SQL优先考虑覆盖索索引\r\n\r\n- UPDATE、DELETE语句的WHERE条件列\r\n- ORDER BY、GROUP BY、DISTINCT的字段\r\n- 多表JOIN的字段\r\n\r\n### 5、区分度最大的字段放在前面\r\n\r\n- 选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面\r\n- 索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引,(a,c)作为条件的时候只能使用到a列索引,所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理,(b,c)则不能走索引\r\n- 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)\r\n\r\n### 6、索引禁忌\r\n\r\n- 不在低基数列上建立索引，例如“性别”\r\n- 不在索引列进行数学运算和函数运算\r\n- 不要索引常用的小型表\r\n\r\n### 7、 尽量不使用外键\r\n\r\n- 外键用来保护参照完整性，可在业务端实现\r\n- 对父表和子表的操作会相互影响，降低可用性\r\n- INNODB本身对online DDL的限制\r\n\r\n### MYSQL 中索引的限制\r\n\r\n- MYISAM 存储引擎索引长度的总和不能超过 1000 字节\r\n- BLOB 和 TEXT 类型的列只能创建前缀索引\r\n- MYSQL 目前不支持函数索引\r\n- 使用不等于 (!= 或者 <>) 的时候, MYSQL 无法使用索引。\r\n- 过滤字段使用函数运算 (如 abs (column)) 后, MYSQL无法使用索引。\r\n- join语句中join条件字段类型不一致的时候MYSQL无法使用索引\r\n- 使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引。\r\n- 使用非等值查询的时候, MYSQL 无法使用 Hash 索引。\r\n\r\n### 语句设计规范\r\n1、使用预编译语句\r\n\r\n- 只传参数，比传递SQL语句更高效\r\n- 一次解析，多次使用\r\n- 降低SQL注入概率\r\n\r\n2、避免隐式转换\r\n\r\n- 会导致索引失效\r\n\r\n3、充分利用前缀索引\r\n\r\n- 必须是最左前缀\r\n- 不可能同时用到两个范围条件\r\n- 不使用%前导的查询，如like “%ab”\r\n\r\n4、不使用负向查询，如not in/like\r\n\r\n- 无法使用索引，导致全表扫描\r\n- 全表扫描导致buffer pool利用率降低\r\n\r\n5、避免使用存储过程、触发器、UDF、events等\r\n\r\n- 让数据库做最擅长的事\r\n- 降低业务耦合度，为sacle out、sharding留有余地\r\n- 避开BUG\r\n\r\n6、避免使用大表的JOIN\r\n\r\n- MySQL最擅长的是单表的主键/二级索引查询\r\n- JOIN消耗较多内存，产生临时表\r\n\r\n7、避免在数据库中进行数学运算\r\n\r\n- MySQL不擅长数学运算和逻辑判断\r\n- 无法使用索引\r\n- 减少与数据库的交互次数\r\n\r\n```\r\nINSERT … ON DUPLICATE KEY UPDATE\r\nREPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),()\r\nUPDATE … WHERE ID IN(10,20,50,…)\r\n```\r\n8、合理的使用分页\r\n\r\n- 限制分页展示的页数\r\n- 只能点击上一页、下一页\r\n- 采用延迟关联\r\n\r\n>如何正确的使用分页？\r\n\r\n>假如有类似下面分页语句：SELECT * FROM table  ORDER BY id LIMIT 10000, 10\r\n\r\n>由于MySQL里对LIMIT OFFSET的处理方式是取出OFFSET+LIMIT的所有数据，然后去掉OFFSET，返回底部的LIMIT。所以，在OFFSET数值较大时，MySQL的查询性能会非常低。可以使用id > n 的方式进行解决：\r\n\r\n>使用id > n 的方式有局限性，对于id不连续的问题，可以通过翻页的时候同时传入最后一个id方式来解决:\r\n\r\n```\r\n\r\n//输出时，找出当前结果集中的最大最小id\r\n\r\n//下一页\r\n\r\nhttp://example.com/page.php?last=100\r\n\r\nselect * from table where id<100 order by id desc limit 10\r\n\r\n//上一页\r\n\r\nhttp://example.com/page.php?first=110\r\n\r\nselect * from table where id>110 order by id desc limit 10\r\n```\r\n\r\n>这种方式比较大的缺点是，如果在浏览中有插入/删除操作，翻页不会更新，而总页数可能仍然是根据新的count(*) 来计算，最终可能会产生某些记录访问不到。为了修补这个问题，可以继续引入当前页码以及在上次翻页以后是否有插入/删除等影响总记录数的操作并进行缓存\r\n\r\n>其他变种方式：\r\n```\r\nselect * from table where id >= (select id from table order by id limit #offset#, 1)\r\n```\r\n \r\n\r\n9、拒绝大SQL，拆分成小SQL\r\n\r\n- 充分利用QUERY CACHE\r\n- 充分利用多核CPU\r\n\r\n10、使用in代替or，in的值不超过1000个\r\n\r\n11、禁止使用order by rand()\r\n\r\n12、使用EXPLAIN诊断，避免生成临时表\r\n\r\nEXPLAIN语句（在MySQL客户端中执行）可以获得MySQL如何执行SELECT语句的信息。通过对SELECT语句执行EXPLAIN，可以知晓MySQL执行该SELECT语句时是否使用了索引、全表扫描、临时表、排序等信息。尽量避免MySQL进行全表扫描、使用临时表、排序等。详见官方文档。\r\n\r\n13、用union all而不是union\r\n\r\n>union all与 union有什么区别？\r\n\r\n>union和union all关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。\r\n\r\n>union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。如：\r\n\r\n```\r\nselect * from test_union1\r\n\r\nunion\r\n\r\nselect * from test_union2\r\n```\r\n这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。\r\n\r\n而union all只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。\r\n\r\n从效率上说，union all要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用union all，如下：\r\n\r\n \r\n```\r\n\r\nselect * from test_union1\r\n\r\nunion all\r\n\r\nselect * from test_union2\r\n```\r\n \r\n\r\n14、程序应有捕获SQL异常的处理机制\r\n\r\n15、禁止单条SQL语句同时更新多个表\r\n\r\n16、不使用select * ，SELECT语句只获取需要的字段\r\n\r\n- 消耗CPU和IO、消耗网络带宽\r\n- 无法使用覆盖索引\r\n- 减少表结构变更带来的影响\r\n- 因为大，select/join 可能生成临时表\r\n\r\n17、UPDATE、DELETE语句不使用LIMIT\r\n\r\n18、INSERT语句必须显式的指明字段名称，不使用INSERT INTO table()\r\n\r\n19、INSERT语句使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不超过500\r\n\r\n20、统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1) 备注：仅针对Myisam\r\n\r\n21、数据更新建议使用二级索引先查询出主键，再根据主键进行数据更新\r\n\r\n22、禁止使用跨库查询\r\n\r\n23、禁止使用子查询，建议将子查询转换成关联查询\r\n\r\n24、针对varchar类型字段的程序处理，请验证用户输入，不要超出其预设的长度；\r\n\r\n### 分表规范\r\n\r\n单表一到两年内数据量超过500w或数据容量超过10G考虑分表，需提前考虑历史数据迁移或应用自行删除历史数据，采用等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略\r\n\r\n- 用HASH进行散表，表名后缀使用十进制数，下标从0开始\r\n- 按日期时间分表需符合YYYY[MM][DD][HH]格式\r\n- 采用合适的分库分表策略。例如千库十表、十库百表等\r\n- 禁止使用分区表，分区表对分区键有严格要，分区表在表变大后执行DDL、SHARDING、单表恢复等都变得更加困难。\r\n- 拆分大字段和访问频率低的字段，分离冷热数据\r\n\r\n### 行为规范\r\n- 批量导入、导出数据必须提前通知DBA协助观察\r\n- 禁止在线上从库执行后台管理和统计类查询\r\n- 禁止有super权限的应用程序账号存在\r\n- 产品出现非数据库导致的故障时及时通知DBA协助排查\r\n- 推广活动或上线新功能必须提前通知DBA进行流量评估\r\n- 数据库数据丢失，及时联系DBA进行恢复\r\n- 对单表的多次alter操作必须合并为一次操作\r\n- 不在MySQL数据库中存放业务逻辑\r\n- 重大项目的数据库方案选型和设计必须提前通知DBA参与\r\n- 对特别重要的库表，提前与DBA沟通确定维护和备份优先级\r\n- 不在业务高峰期批量更新、查询数据库其他规范\r\n- 提交线上建表改表需求，必须详细注明所有相关SQL语句\r\n\r\n### 其他规范\r\n日志类数据不建议存储在MySQL上，优先考虑Hbase或OceanBase，如需要存储请找DBA评估使用压缩表存储。\r\n\r\n原文地址：http://www.biaodianfu.com/mysql-best-practices.html', '1', '1', '2019-03-04 19:00:15', '2019-03-04 19:35:11');
INSERT INTO `posts` VALUES ('127', '3', '0-3', '2', ' C语言程序设计教程（第三版）课后习题8.2---求方程 的根，用三个函数分别求当b^2-4ac大于', '', '## 题目描述\r\n>求方程 的根，用三个函数分别求当b^2-4ac大于0、等于0、和小于0时的根，并输出结果。从主函数输入a、b、c的值。\r\n\r\n### 输入\r\n```\r\na b c\r\n```\r\n### 输出\r\n```\r\nx1=? x2=?\r\n```\r\n### 样例输入\r\n```\r\n4 1 1\r\n```\r\n### 样例输出\r\n```\r\nx1=-0.125+0.484i x2=-0.125-0.484i\r\n```\r\n### 提示\r\n \r\n#### 第一种方法：由于oj采用黑箱测试，所以我们可以不用定义函数。\r\n```\r\n#include<stdio.h>\r\n#include<math.h>\r\n \r\nint main()\r\n{\r\n    double a,b,c,d,x1,x2,dr,xr,xv;\r\n    //dr代表d的根，xr代表根的实数部分，xv代表根的虚数部分。\r\n    scanf(\"%lf%lf%lf\",&a,&b,&c);\r\n    d=b*b-4*a*c;\r\n    if(d>=0)\r\n        dr=sqrt(d);\r\n    else\r\n        dr=sqrt(-d);\r\n    if(d==0)\r\n    {\r\n        x1=x2=-b/(2*a);\r\n        printf(\"x1=%.3lf x2=%.3lf\",x1,x2);\r\n    }\r\n    else if(d>0)\r\n    {\r\n        x1=(-b+dr)/(2*a);\r\n        x2=(-b-dr)/(2*a);\r\n        printf(\"x1=%.3lf x2=%.3lf\",x1,x2);\r\n    }\r\n    else\r\n    {\r\n        xr=-b/(2*a);\r\n        xv=dr/(2*a);\r\n        printf(\"x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi\",xr,xv,xr,xv);\r\n    }\r\n}\r\n```\r\n\r\n#### 第二种方法：按照题目要求，定义三个函数。\r\n```\r\n#include<stdio.h>\r\n#include<math.h>\r\n \r\ndouble a,b,c,d,x1,x2,dr,xr,xv;//宏定义变量，在所有的方法中均能使用。dr代表d的根，xr代表根的实数部分，xv代表根的虚数部分。\r\n \r\nint main()\r\n{\r\n    scanf(\"%lf%lf%lf\",&a,&b,&c);\r\n    d=b*b-4*a*c;\r\n    double delta_is_greater_than_zero(double d);\r\n    double delta_is_less_than_zero(double d);\r\n    double delta_is_equal_to_zero(double d);\r\n    if(d>0)\r\n    {\r\n        delta_is_greater_than_zero(d);\r\n    }\r\n    else if(d<0)\r\n    {\r\n        delta_is_less_than_zero(d);\r\n    }\r\n    else\r\n    {\r\n        delta_is_equal_to_zero(d);\r\n    }\r\n}\r\ndouble delta_is_greater_than_zero(double d)\r\n{\r\n    dr=sqrt(d);\r\n    x1=(-b+dr)/(2*a);\r\n    x2=(-b-dr)/(2*a);\r\n    printf(\"x1=%.3lf x2=%.3lf\",x1,x2);\r\n}\r\ndouble delta_is_less_than_zero(double d)\r\n{\r\n    d=-d;\r\n    dr=sqrt(d);\r\n    xr=-b/(2*a);\r\n    xv=dr/(2*a);\r\n    printf(\"x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi\",xr,xv,xr,xv);\r\n}\r\ndouble delta_is_equal_to_zero(double d)\r\n{\r\n    dr=sqrt(d);\r\n    x2=x1=(-b+dr)/(2*a);\r\n    printf(\"x1=%.3lf x2=%.3lf\",x1,x2);\r\n}\r\n```\r\n', '1', '1', '2019-03-10 15:10:44', '2019-03-10 15:13:16');
INSERT INTO `posts` VALUES ('128', '4', '0-4', '2', 'MySQL表结构（含数据类型、字段备注注释）导出成Excel', '', '像我们使用的数据库图形化工具Navicat Premium、Navicat for XXX、SQLyog、DataGrip等等都可以导出表结构SQL脚本，但是当我们要将数据库整理成文档时导出表结构的sql脚本肯定是不方便的，在这里要说的是，将表结构（含注释）导出到Excel中的方法\r\n\r\n但是 不支持将表结构导出成以上的那些格式，这个比较悲痛。\r\n\r\n这里就提供一种如果使用的工具不支持表结构导出成Excel或者HTML等格式的方法；\r\n\r\n \r\n以下用的是Navicat Premium，可以换成任意图形化客户端\r\n\r\n```\r\nSELECT\r\n  COLUMN_NAME 列名,\r\n  COLUMN_TYPE 数据类型,\r\n    DATA_TYPE 字段类型,\r\n  CHARACTER_MAXIMUM_LENGTH 长度,\r\n  IS_NULLABLE 是否为空,\r\n  COLUMN_DEFAULT 默认值,\r\n  COLUMN_COMMENT 备注 \r\nFROM\r\n INFORMATION_SCHEMA.COLUMNS\r\nwhere\r\n-- developerclub为数据库名称，到时候只需要修改成你要导出表结构的数据库即可\r\ntable_schema =\'developerclub\'\r\nAND\r\n-- article为表名，到时候换成你要导出的表的名称\r\n-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称\r\ntable_name  = \'article\'\r\n```\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n  ', '1', '1', '2019-03-19 16:47:59', '2019-03-19 16:49:24');
INSERT INTO `posts` VALUES ('129', '3', '0-3', '2', 'php返回json,xml,JSONP等格式的数据', 'php返回json,xml,JSONP等格式的数据', 'php返回json,xml,JSONP等格式的数据\r\n\r\n返回json数据：\r\n```\r\nheader(\'Content-Type:application/json; charset=utf-8\');\r\n$arr = array(\'a\'=>1,\'b\'=>2);\r\nexit(json_encode($data));\r\n```\r\n注意：如果不加header直接输出json_encode的值的话，返回的是字符串不是对象，js那边就需要先\r\n```\r\neval(\'(\'+data+\')\')\r\n```\r\n转化为对象，在取值\r\n\r\n \r\n\r\n返回xml数据：\r\n```\r\nheader(\'Content-Type:text/xml; charset=utf-8\');\r\nexit($xml);\r\n``` \r\n\r\n返回jsonp数据：\r\n```\r\n$arr = array(\'a\'=>1, \'b\'=>2, \'c\'=>3);\r\n$json = json_encode($arr);\r\n$callback = $_GET[\'callback\'];\r\nexit($callback.\"($json)\");\r\n\r\n//注意callback是js传过来的参数名称\r\n```\r\n\r\n顺便说下thinkphp如何返回各种数据：\r\n```\r\n$this->ajaxReturn (json_encode($arr),\'JSON\');\r\n\r\n$this->ajaxReturn (json_encode($arr),\'JSONP\');\r\n\r\n$this->ajaxReturn (json_encode($arr),\'XML\');\r\n```\r\n \r\n\r\njson_encode有个参数禁止unicode编码\r\n\r\nJSON_UNESCAPED_UNICODE\r\n\r\njson_encode(\'中文\',JSON_UNESCAPED_UNICODE);\r\n\r\n \r\n\r\n默认中文编码\r\n```\r\nheader(\'Content-Type:application/json; charset=gbk\');\r\n\r\n$data = $db->select($sql);\r\n$data = json_encode($data);\r\n$data=preg_replace(\"#\\\\\\u([0-9a-f]{4})#ie\", \"iconv(\'UCS-2BE\', \'gbk\', pack(\'H4\', \'\\\\1\'))\", $data);\r\n\r\nexit($data);\r\n```\r\n☜☞梦想总是要有的，万一实现了呢☜☞', '1', '1', '2019-03-27 09:41:30', '2019-03-27 09:43:41');
INSERT INTO `posts` VALUES ('130', '3', '0-3', '2', 'nginx: [error] invalid PID number \"\" in \"/run/ngin', '', '在重启云主机（系统）之后，执行 nginx -t 是OK的，然而在执行 \r\n```\r\nnginx -s reload 的时候报错\r\n```\r\n```\r\nnginx: [error] invalid PID number “” in “/run/nginx.pid”\r\n```\r\n经过查找，找到http://www.cnblogs.com/yuqianwen/p/4285686.html\r\n\r\n需要先执行\r\n```\r\nnginx -c /etc/nginx/nginx.conf\r\n```\r\nnginx.conf文件的路径可以从nginx -t的返回中找到。\r\n```\r\nnginx -s reload\r\n```', '1', '1', '2019-03-30 09:31:12', '2019-03-30 09:33:29');
INSERT INTO `posts` VALUES ('131', '3', '0-3', '2', 'SUSE的软件管理工具——zypper（一）', '', '### [原文链接](http://www.vuln.cn/2732)\r\n```\r\nzypper se xxxxx 是搜索软件包\r\nzypper in xxxxx 跟你的apt-get install xxxx等价\r\nzypper rm xxxx  删除\r\nzypper up xxxx 更新软件\r\n```\r\n \r\n\r\n以前接触red hat或者debian一类的linux比较常用的在线软件安装的工具就是yum或者apt-get 命令，但是第一次接触SUSE系统发现竟然都没有，本以为要自己装，后来在网上发现一个更为好用的工具：zypper\r\n\r\n尤其是添加源一个命令就可以搞定。这里给大家简单介绍下zypper命令的使用，另外提供几个可用的源（网上能用的不多）\r\n\r\n\r\n\r\n## 安装源操作：zypper+ 参数\r\n```\r\nrepos, lr 列出所有定义的安装源。\r\naddrepo, ar 添加一个新的安装源。\r\nremoverepo, rr 删除指定的安装源。\r\nrenamerepo, nr 重命名指定的安装源。\r\nmodifyrepo, mr 修改指定的安装源。\r\nrefresh, ref 刷新所有安装源。\r\n\r\nclean 清除本地缓存。\r\n```\r\n\r\n### suse官方源\r\n\r\n```\r\nzypper ar http://ftp5.gwdg.de/pub/opensuse/discontinued/distribution/11.3/repo/oss/suse main\r\n\r\nzypper ar http://download.opensuse.org/distribution/11.3/repo/non-oss/suse/ nonoss\r\n\r\nzypper ar http://download.opensuse.org/update/11.3/suse update\r\n```\r\n添加好以后需要先刷新：\r\n```\r\nzypper refresh\r\n```\r\n\r\n## 常用命令\r\n\r\n### 安装某个软件包\r\n```\r\nzypper install package_name\r\n```\r\n### 安装某个版本的软件包\r\n```\r\nzypper install package_name=version\r\n```\r\n### 安装以某个单词名字开头的所有软件包\r\n```\r\nzypper install package_name*\r\n```\r\n### 卸载某个软件包\r\n```\r\nzypper remove package_name\r\n```\r\n### 升级某个软件包\r\n```\r\nzypper update package_name\r\n```\r\n要一次安装和删除多个包，请使用 +/- 或 ~/! 修改键一次性安装和删除包：\r\n```\r\nzypper install emacs -vim\r\n```\r\n或：\r\n```\r\nzypper remove emacs +vim\r\n```\r\n可使用此命令来获取所有可用新包的列表：\r\n```\r\nzypper list-updates\r\n```\r\n类似的，要列出所有所需的包，请使用：\r\n```\r\nzypper list-patches\r\n```\r\n具体的软件管理有如下几项：\r\n```\r\ninstall, in 安装软件包。\r\nremove, rm 删除软件包。\r\nverify, ve 检验软件包的依赖关系的完整性。\r\nupdate, up 将已经安装的软件包更新到新的版本。\r\ndist-upgrade, dup 执行整个系统的升级。\r\nsource-install, si 安装源代码软件包和它们的编译依赖。\r\n```\r\n安装过程中可能会有的源连接不上，或者报错，一般只要源正常就可以安装上，或者检查安装包名是否有问题。', '1', '1', '2019-03-30 09:39:07', '2019-03-30 09:42:30');
INSERT INTO `posts` VALUES ('132', '3', '0-3', '2', 'SUSE环境下通过YaST安装软件——zypper（二）', '', '\r\n为了提升用户在云服务器上的软件安装效率，减少下载和安装软件的成本，百度云提供了YaST下载源。操作系统为SUSE10的云服务器用户可通过YaST快速安装软件。\r\n \r\n## 1. 安装步骤\r\n### 1. 列出软件源\r\n登录操作系统为Linux的云服务器后，默认已获取root权限：\r\n在root权限下，通过命令 service-list 或 sl 列出软件源，示例如下：\r\n```\r\n#zypper sl\r\n```\r\n \r\n\r\n### 2. 添加软件源\r\n如果步骤2中没有列出软件源，则需要按下面的说明手动添加软件源。\r\n在root权限下，通过命令service-add或sa添加软件源，\r\n\r\n[参考](https://www.cnblogs.com/linuxprobe/p/5340013.html)\r\n\r\n \r\n### 3. 搜索软件包\r\n通过命令search或se搜索软件包，示例如下：\r\n```\r\n#zypper se nginx\r\n```\r\n\r\n### 4. 安装软件包\r\n根据搜索到的软件包的名字（Name）安装软件。\r\n\r\n如果要安装多个软件，中间用空格隔开。\r\n\r\n注：安装软件的时候，如果需要依赖包，会自动下载安装，用户无需自己安装依赖包。\r\n \r\n通过命令install或in安装nginx软件包，示例如下：\r\n```\r\n#zypper in nginx\r\n```\r\n\r\n请按照相同的方式安装php和php-fpm等软件，示例如下：\r\n```\r\n#zypper in MySQL-server-community php5-mysql php5 php5-fpm\r\n```\r\n\r\n## 2. 安装的软件信息查看\r\n软件安装完成后，可通过命令 rpm -ql 查看软件包具体的安装目录。\r\n以查看nginx的安装目录为例：\r\n```\r\n#rpm -ql nginx\r\n``` \r\n\r\n可通过命令 rpm -q 查看软件包的版本信息。\r\n以查看nginx的版本为例：\r\n```\r\n#rpm -q nginx\r\n```\r\n结果如下（实际的版本可能和此版本不一致，请以实际查询到的版本为准）：', '1', '1', '2019-03-30 09:43:20', '2019-03-30 09:47:55');
INSERT INTO `posts` VALUES ('133', '3', '0-3', '2', 'zypper命令使用示例——zypper（三）', '', '>导读	\r\n```\r\nZypper是OpenSUSE和企业版SUSE中软件包管理器ZYpp的命令行接口。 主要用于：1.管理软件包：zypper可用来安装、删除、更新和查询本地或远程的软件包。2.管理仓库：zypper可用命令行添加、删除、启用或禁用库。\r\n```\r\n\r\n## I. 用zypper管理软件包\r\n### 1. 安装包\r\n \r\n语法： # zypper install 示例：安装Mozilla firefox\r\n\r\n```\r\n[root@linuxprobe ~]# zypper install MozillaFirefox\r\nLoading repository data...\r\nReading installed packages...\r\nResolving package dependencies...\r\nThe following NEW packages are going to be installed:\r\n  MozillaFirefox MozillaFirefox-branding-SLED\r\nThe following packages are not supported by their vendor:\r\n  MozillaFirefox MozillaFirefox-branding-SLED\r\n2 new packages to install.\r\nOverall download size: 964.0 KiB. After the operation, additional 3.4 MiB will be used.\r\nContinue? [y/n/?] (y): y\r\nRetrieving package MozillaFirefox-3.6.16-0.2.1.x86_64 (1/2), 949.0 KiB (3.4 MiB unpacked)\r\nRetrieving: MozillaFirefox-3.6.16-0.2.1.x86_64.rpm [done]\r\nInstalling: MozillaFirefox-3.6.16-0.2.1 [done]\r\nRetrieving package MozillaFirefox-branding-SLED-3.5-1.1.5.x86_64 (2/2), 15.0 KiB (34.0 KiB unpacked)\r\nRetrieving: MozillaFirefox-branding-SLED-3.5-1.1.5.x86_64.rpm [done]\r\nInstalling: MozillaFirefox-branding-SLED-3.5-1.1.5 [done]\r\n```\r\n### 2. 安装源码包\r\n语法：# zypper source-install 示例：从库中安装 apache\r\n```\r\n[root@linuxprobe ~]# zypper source-install apache2-mod_nss\r\nReading installed packages...\r\nLoading repository data...\r\nResolving package dependencies...\r\nRetrieving package mozilla-nss-devel-3.12.8-1.2.1.x86_64 (2/3), 473.0 KiB (2.6 MiB unpacked)\r\nRetrieving: mozilla-nss-devel-3.12.8-1.2.1.x86_64.rpm [done]\r\nInstalling: mozilla-nss-devel-3.12.8-1.2.1 [done]\r\nRetrieving: apache2-mod_nss-1.0.8-17.5.src.rpm [done]\r\n```\r\n### 3. 更新包\r\n\r\n更新某一软件包： # zypper update \r\n\r\n更新所有软件包： # zypper update\r\n\r\n查看所有可用的更新列表：# zypper list-updates\r\n\r\n### 4. 删除包\r\n\r\n语法：# zypper remove 示例：移除Mozilla Firefox\r\n```\r\n[root@linuxprobe ~]# zypper remove MozillaFirefox\r\nLoading repository data...\r\nReading installed packages...\r\nResolving package dependencies...\r\nThe following packages are going to be REMOVED:\r\n  MozillaFirefox MozillaFirefox-branding-SLED\r\n2 packages to remove.\r\nAfter the operation, 3.4 MiB will be freed.\r\nContinue? [y/n/?] (y): y\r\nRemoving MozillaFirefox-branding-SLED-3.5-1.1.5 [done]\r\nRemoving MozillaFirefox-3.6.16-0.2.1 [done]\r\n```\r\n### 5. 查找包\r\n\r\n语法：# zypper search 示例：查找所有usb开头的软件包\r\n```\r\n[root@linuxprobe ~]# zypper search usb*\r\nLoading repository data...\r\nReading installed packages...\r\n\r\nS | Name                | Summary                                                        | Type\r\n--+---------------------+----------------------------------------------------------------+--------\r\n  | usb_modeswitch      | A mode switching tool for controlling multiple-device USB gear | package\r\n  | usb_modeswitch-data | A mode switching tool for controlling multiple-device USB gear | package\r\n  | usbip-devel         | Headers and static libraries                                   | package\r\ni | usbutils            | Tools and libraries for USB devices                            | package\r\n```\r\n### 6. 查看软件包详情\r\n\r\n语法： zypper info 示例：查看usbutils的信息\r\n```\r\n[root@linuxprobe ~]# zypper info usbutils\r\nLoading repository data...\r\nReading installed packages...\r\nInformation for package usbutils:\r\nRepository: LINUXPROBE\r\nName: usbutils\r\nVersion: 0.73-38.19\r\nArch: x86_64\r\nVendor: SUSE LINUX Products GmbH, Nuernberg, Germany\r\nSupport Level: unknown\r\nInstalled: Yes\r\nStatus: up-to-date\r\nInstalled Size: 461.0 KiB\r\nSummary: Tools and libraries for USB devices\r\nDescription:\r\nThis package contains a utility for inspecting devices connected to USB\r\nports.\r\nIt requires kernel version 2.3.99-pre7 or newer, or the USB backport\r\nwhich was introduced in 2.2.18 (supporting the /proc/bus/usb\r\ninterface).\r\n```\r\n### 7. 打补丁\r\n\r\n查看所有可打补丁: zypper patches\r\n\r\n安装指定补丁：zypper patch\r\n\r\n### 8. 锁住包\r\n\r\n软件包被锁之后将不能被移除或升级，下面演示一下如何加锁\r\n1）加al选项锁住包文件“usbutils”, al 是 add lock的缩写\r\n```\r\n[root@linuxprobe ~] # zypper al usbutils\r\nSpecified lock has been successfully added.\r\n```\r\n2) 加ll选项查看所有已被锁住的软件包, ll 是 List Locks的缩写\r\n```\r\n[root@linuxprobe ~] # zypper ll\r\n# | Name            | Type    | Repository\r\n--+-----------------+---------+-----------\r\n1 | usbutils        | package | (any)\r\n```\r\n### 9. 解锁包\r\n\r\n加rl选项解锁usbutils, rl 是 remove lock的缩写\r\n```\r\n[root@linuxprobe ~] #  zypper rl usbutils\r\n1 lock has been successfully removed.\r\n[root@linuxprobe ~]# zypper ll\r\nThere are no package locks defined.\r\n```\r\n## II. 用zypper管理仓库\r\n### 10. 用zypper添加库\r\n\r\n语法：# zypper addrepo\r\n```\r\n[root@linuxprobe ~] # zypper addrepo --check --refresh --name \"Mozilla-repo\" http://download.opensuse.org/repositories/mozilla/SLE_11/ \"Mozillarepo\"\r\nAdding repository \'Mozilla-repo\' [done]\r\nRepository \'Mozilla-repo\' successfully added\r\nEnabled: Yes\r\nAutorefresh: Yes\r\nURI: http://download.opensuse.org/repositories/mozilla/SLE_11/\r\n```\r\n### 11. 创建本地库\r\n\r\n我们可以使用zypper从本地目录中创建一个包含所有rpm文件的本地库\r\n语法： # zypper addrepo\r\n\r\n示例：创建一个名为Linuxprobe_Repo的本地目录，包含所有rpm文件\r\n```\r\n[root@linuxprobe ~] # zypper addrepo /var/stormgt/dsminst Linuxprobe_Repo\r\nAdding repository \'Linuxprobe_Repo\' [done]\r\nRepository \'Linuxprobe_Repo\' successfully added\r\nEnabled: Yes\r\nAutorefresh: No\r\nURI: dir:///var/stormgt/dsminst\r\n[root@linuxprobe ~] # zypper search --repo Linuxprobe_Repo\r\nLoading repository data...\r\nReading installed packages...\r\nS | Name        | Summary                                 | Type\r\n--+-------------+-----------------------------------------+--------\r\ni | TIVsm-API   | the API                                 | package\r\ni | TIVsm-API64 | the API                                 | package\r\ni | TIVsm-BA    | the Backup Archive Client               | package\r\ni | gskcrypt32  | IBM GSKit Cryptography Runtime          | package\r\ni | gskcrypt64  | IBM GSKit Cryptography Runtime          | package\r\ni | gskssl32    | IBM GSKit SSL Runtime With Acme Toolkit | package\r\ni | gskssl64    | IBM GSKit SSL Runtime With Acme Toolkit | package\r\n```\r\n注：你也可以通过此命令添加NFS或FTP路径\r\n\r\n### 12. 查看库\r\n```\r\n[root@linuxprobe ~] # zypper lr\r\n# | Alias                                            | Name                                             | Enabled | Refresh\r\n--+--------------------------------------------------+--------------------------------------------------+---------+--------\r\n1 | Mozillarepo                                      | Mozilla-repo                                     | Yes     | Yes\r\n2 | SUSE-Linux-Enterprise-Server-11-SP1 11.1.1-1.152 | SUSE-Linux-Enterprise-Server-11-SP1 11.1.1-1.152 | Yes     | Yes\r\n查看repo完整的URI：\r\n\r\n[root@linuxprobe ~] # zypper lr --uri\r\n# | Alias                                            | Name                                             | Enabled | Refresh | URI\r\n--+--------------------------------------------------+--------------------------------------------------+---------+---------+----------------------------------------------------------\r\n1 | Mozillarepo                                      | Mozilla-repo                                     | Yes     | Yes     | http://download.opensuse.org/repositories/mozilla/SLE_11/\r\n2 | SUSE-Linux-Enterprise-Server-11-SP1 11.1.1-1.152 | SUSE-Linux-Enterprise-Server-11-SP1 11.1.1-1.152 | Yes     | Yes     | http://19.106.65.64/FUSELinux/600RC0\r\n```\r\n### 13. 在库中搜索包\r\n列出指定库Mozillarepo的所有软件包\r\n```\r\n[root@linuxprobe ~] # zypper search --repo Mozillarepo\r\nLoading repository data...\r\nReading installed packages...\r\n\r\nS | Name                                 | Summary                                                                 | Type\r\n--+--------------------------------------+-------------------------------------------------------------------------+-----------\r\ni | MozillaFirefox                       | Mozilla Firefox Web Browser                                             | package\r\ni | MozillaFirefox-branding-SLED         | SLED branding of MozillaFirefox                                         | package  \r\n  | MozillaFirefox-branding-openSUSE     | openSUSE branding of MozillaFirefox                                     | package\r\n  | MozillaFirefox-branding-openSUSE     | openSUSE branding of MozillaFirefox                                     | srcpackage\r\n```\r\n### 14. 库重命名\r\n\r\n重命名库可以用 renamerepo 选项\r\n示例：将库\"Linuxprobe_Repo\"的名字改成\"MyLinuxRepo\"\r\n```\r\n[root@linuxprobe ~] # zypper renamerepo Linuxprobe_Repo MyLinuxRepo\r\nRepository \'Linuxprobe_Repo\' renamed to \'MyLinuxRepo\'.\r\n```\r\n### 15. 删除库\r\n\r\n用removerepo选项来移除库\r\n```\r\n[root@linuxprobe ~] # zypper removerepo MyLinuxRepo\r\nRemoving repository \'MyLinuxRepo\' [done]\r\nRepository \'MyLinuxRepo has been removed.\r\n```\r\n### 16. 备份库\r\n\r\n用export选项可以备份一系列库文件\r\n```\r\n[root@linuxprobe ~] # zypper lr --export /var/tmp/backup.repo\r\nRepositories have been successfully exported to /var/tmp/backup.repo.\r\n```\r\n### 17. 从备份文件中添加库\r\n```\r\n[root@linuxprobe ~] # zypper addrepo /var/tmp/backup.rep\r\n```\r\n### 18. 禁用/使用库\r\n\r\n示例： 用 modifyrepo 选项的 -d 参数来禁用Mozilla库\r\n```\r\n[root@linuxprobe ~] # zypper modifyrepo -d Mozillarepo\r\nRepository \'Mozillarepo\' has been successfully disabled.\r\n```\r\n示例： 用 modifyrepo选项 -e 参数来允许使用Mozilla库\r\n```\r\n[root@linuxprobe ~] # zypper modifyrepo -e Mozillarepo\r\nRepository \'Mozillarepo\' has been successfully enabled.\r\n```\r\n### 19. 刷新库\r\n\r\n示例： 刷新Mozilla库\r\n```\r\n[root@linuxprobe ~] # zypper refresh Mozillarepo\r\nRepository \'Mozilla-repo\' is up to date.\r\nSpecified repositories have been refreshed.\r\n```\r\n示例： 自动刷新指定库\r\n```\r\n[root@linuxprobe ~] # zypper modifyrepo --refresh Linuxprobe_Repo\r\nAutorefresh has been enabled for repository \'Linuxprobe_Repo\'.\r\n```\r\n  ', '1', '1', '2019-03-30 09:51:35', '2019-03-30 09:58:17');
INSERT INTO `posts` VALUES ('134', '3', '0-3', '2', 'PHP大文件分割上传 PHP分片上传', '', '服务端为什么不能直接传大文件？跟php.ini里面的几个配置有关\r\n```\r\nupload_max_filesize = 2M //PHP最大能接受的文件大小\r\npost_max_size = 8M //PHP能收到的最大POST值\'\r\nmemory_limit = 128M //内存上限\r\nmax_execution_time = 30 //最大执行时间\r\n```\r\n当然不能简单粗暴的把上面几个值调大，否则服务器内存资源吃光是迟早的问题。\r\n\r\n## 解决思路\r\n\r\n好在HTML5开放了新的FILE API，也可以直接操作二进制对象，我们可以直接在浏览器端实现文件切割，按照以前的做法就得用Flash的方案，实现起来会麻烦很多。\r\n\r\n### JS思路\r\n1.监听上传按钮的onchange事件\r\n2.获取文件的FILE对象\r\n3.把文件的FILE对象进行切割，并且附加到FORMDATA对象中\r\n4.把FORMDATA对象通过AJAX发送到服务器\r\n5.重复3、4步骤，直到文件发送完。\r\n\r\n### PHP思路\r\n1.建立上传文件夹\r\n2.把文件从上传临时目录移动到上传文件夹\r\n3.所有的文件块上传完成后，进行文件合成\r\n4.删除文件夹\r\n5.返回上传后的文件路径\r\n\r\n## DEMO代码\r\n\r\n前端部分代码\r\n```\r\n<!doctype html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\"\r\n     content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n  <title>Document</title>\r\n  <style>\r\n    #progress{\r\n      width: 300px;\r\n      height: 20px;\r\n      background-color:#f7f7f7;\r\n      box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);\r\n      border-radius:4px;\r\n      background-image:linear-gradient(to bottom,#f5f5f5,#f9f9f9);\r\n    }\r\n \r\n    #finish{\r\n      background-color: #149bdf;\r\n      background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);\r\n      background-size:40px 40px;\r\n      height: 100%;\r\n    }\r\n    form{\r\n      margin-top: 50px;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n<div id=\"progress\">\r\n  <div id=\"finish\" style=\"width: 0%;\" progress=\"0\"></div>\r\n</div>\r\n<form action=\"./upload.php\">\r\n  <input type=\"file\" name=\"file\" id=\"file\">\r\n  <input type=\"button\" value=\"停止\" id=\"stop\">\r\n</form>\r\n<script>\r\n  var fileForm = document.getElementById(\"file\");\r\n  var stopBtn = document.getElementById(\'stop\');\r\n  var upload = new Upload();\r\n \r\n  fileForm.onchange = function(){\r\n    upload.addFileAndSend(this);\r\n  }\r\n \r\n  stopBtn.onclick = function(){\r\n    this.value = \"停止中\";\r\n    upload.stop();\r\n    this.value = \"已停止\";\r\n  }\r\n \r\n  function Upload(){\r\n    var xhr = new XMLHttpRequest();\r\n    var form_data = new FormData();\r\n    const LENGTH = 1024 * 1024;\r\n    var start = 0;\r\n    var end = start + LENGTH;\r\n    var blob;\r\n    var blob_num = 1;\r\n    var is_stop = 0\r\n    //对外方法，传入文件对象\r\n    this.addFileAndSend = function(that){\r\n      var file = that.files[0];\r\n      blob = cutFile(file);\r\n      sendFile(blob,file);\r\n      blob_num += 1;\r\n    }\r\n    //停止文件上传\r\n    this.stop = function(){\r\n      xhr.abort();\r\n      is_stop = 1;\r\n    }\r\n    //切割文件\r\n    function cutFile(file){\r\n      var file_blob = file.slice(start,end);\r\n      start = end;\r\n      end = start + LENGTH;\r\n      return file_blob;\r\n    };\r\n    //发送文件\r\n    function sendFile(blob,file){\r\n      var total_blob_num = Math.ceil(file.size / LENGTH);\r\n      form_data.append(\'file\',blob);\r\n      form_data.append(\'blob_num\',blob_num);\r\n      form_data.append(\'total_blob_num\',total_blob_num);\r\n      form_data.append(\'file_name\',file.name);\r\n \r\n      xhr.open(\'POST\',\'./upload.php\',false);\r\n      xhr.onreadystatechange = function () {\r\n        var progress;\r\n        var progressObj = document.getElementById(\'finish\');\r\n        if(total_blob_num == 1){\r\n          progress = \'100%\';\r\n        }else{\r\n          progress = Math.min(100,(blob_num/total_blob_num)* 100 ) +\'%\';\r\n        }\r\n        progressObj.style.width = progress;\r\n        var t = setTimeout(function(){\r\n          if(start < file.size && is_stop === 0){\r\n            blob = cutFile(file);\r\n            sendFile(blob,file);\r\n            blob_num += 1;\r\n          }else{\r\n            setTimeout(t);\r\n          }\r\n        },1000);\r\n      }\r\n      xhr.send(form_data);\r\n    }\r\n  }\r\n \r\n</script>\r\n</body>\r\n</html>\r\n```\r\nPHP部分代码\r\n```\r\n<?php\r\nclass Upload{\r\n  private $filepath = \'./upload\'; //上传目录\r\n  private $tmpPath; //PHP文件临时目录\r\n  private $blobNum; //第几个文件块\r\n  private $totalBlobNum; //文件块总数\r\n  private $fileName; //文件名\r\n \r\n  public function __construct($tmpPath,$blobNum,$totalBlobNum,$fileName){\r\n    $this->tmpPath = $tmpPath;\r\n    $this->blobNum = $blobNum;\r\n    $this->totalBlobNum = $totalBlobNum;\r\n    $this->fileName = $fileName;\r\n     \r\n    $this->moveFile();\r\n    $this->fileMerge();\r\n  }\r\n   \r\n  //判断是否是最后一块，如果是则进行文件合成并且删除文件块\r\n  private function fileMerge(){\r\n    if($this->blobNum == $this->totalBlobNum){\r\n      $blob = \'\';\r\n      for($i=1; $i<= $this->totalBlobNum; $i++){\r\n        $blob .= file_get_contents($this->filepath.\'/\'. $this->fileName.\'__\'.$i);\r\n      }\r\n      file_put_contents($this->filepath.\'/\'. $this->fileName,$blob);\r\n      $this->deleteFileBlob();\r\n    }\r\n  }\r\n   \r\n  //删除文件块\r\n  private function deleteFileBlob(){\r\n    for($i=1; $i<= $this->totalBlobNum; $i++){\r\n      @unlink($this->filepath.\'/\'. $this->fileName.\'__\'.$i);\r\n    }\r\n  }\r\n   \r\n  //移动文件\r\n  private function moveFile(){\r\n    $this->touchDir();\r\n    $filename = $this->filepath.\'/\'. $this->fileName.\'__\'.$this->blobNum;\r\n    move_uploaded_file($this->tmpPath,$filename);\r\n  }\r\n   \r\n  //API返回数据\r\n  public function apiReturn(){\r\n    if($this->blobNum == $this->totalBlobNum){\r\n        if(file_exists($this->filepath.\'/\'. $this->fileName)){\r\n          $data[\'code\'] = 2;\r\n          $data[\'msg\'] = \'success\';\r\n          $data[\'file_path\'] = \'http://\'.$_SERVER[\'HTTP_HOST\'].dirname($_SERVER[\'DOCUMENT_URI\']).str_replace(\'.\',\'\',$this->filepath).\'/\'. $this->fileName;\r\n        }\r\n    }else{\r\n        if(file_exists($this->filepath.\'/\'. $this->fileName.\'__\'.$this->blobNum)){\r\n          $data[\'code\'] = 1;\r\n          $data[\'msg\'] = \'waiting for all\';\r\n          $data[\'file_path\'] = \'\';\r\n        }\r\n    }\r\n    header(\'Content-type: application/json\');\r\n    echo json_encode($data);\r\n  }\r\n   \r\n  //建立上传文件夹\r\n  private function touchDir(){\r\n    if(!file_exists($this->filepath)){\r\n      return mkdir($this->filepath);\r\n    }\r\n  }\r\n}\r\n \r\n//实例化并获取系统变量传参\r\n$upload = new Upload($_FILES[\'file\'][\'tmp_name\'],$_POST[\'blob_num\'],$_POST[\'total_blob_num\'],$_POST[\'file_name\']);\r\n//调用方法，返回结果\r\n$upload->apiReturn();\r\n```', '1', '1', '2019-04-03 16:52:37', '2019-04-03 16:54:11');
INSERT INTO `posts` VALUES ('135', '3', '0-3', '2', 'php中static、final、interface、abstract的区别', '', '## final\r\n如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\r\n\r\n注：属性不能被定义为 final，只有类和方法才能被定义为 final。\r\n\r\n## static\r\n静态变量可以是局部变量也可以是全局变量，当一个程序段执行完毕时，静态变量并没有消失，它依然存在于内存中，下次在定义时还是以前的值，常用于递归或子函数中保留之前的值，可以用来定义变量和方法；单例模式也用的是这个；\r\n```\r\n1.一般静态属性用于保存类的公有数据\r\n\r\n2、静态方法内部只能访问静态属性，包括本类和父类的\r\n\r\n3、静态成员不需要实例化对象就可以访问\r\n\r\n4、在本类内部访问静态属性用self或static关键字访问，后面带上的变量要包括$，比如: self::$a或者static::$a\r\n\r\n5、访问父类静态属性使用parent，如：parent::$name\r\n\r\n6、在类外部访问静态变量或者方法时使用类名直接访问，无需实例化。如：Me::$pan和Me::abc()\r\n```\r\n## abstract\r\n抽象类abstract class\r\n```\r\n1 ．抽象类是指在 class 前加了 abstract 关键字且存在抽象方法（在类方法 function 关键字前加了 abstract 关键字）的类。\r\n\r\n2 ．抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。\r\n\r\n3 ．如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。\r\n\r\n4 ． 如果子类实现了抽象方法，那么 子类中抽象方法的访问控制不能比父类中的抽象方法访问控制更严格，也就是说（A父类，B子类）\r\n\r\n　　(1) 如果 A 中 abstract_func() 声明为 public ，那么 B 中 abstract_func() 的声明只能是 public ，不能是 protected 或 private\r\n\r\n　　(2) 如果 A 中 abstract_func() 声明为 protected ，那么 B 中 abstract_func() 的声明可以是 public 或 protected ，但不能是 private\r\n\r\n　　(3) 如果 A 中 abstract_func() 声明为 private ，不能定义为 private ！（ Fatal error : Abstract function A::abstract_func() cannot be declared private ）\r\n```\r\n## interface\r\n```\r\n1 ．抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字 interface 来声明。\r\n\r\n2 ．interface 是完全抽象的，只能声明方法，而且只能声明 public 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也不能声明实例变量 。\r\n\r\n3 ．interface 却可以声明常量变量 。但将常量变量放在 interface 中违背了其作为接口的作用而存在的宗旨，也混淆了 interface 与类的不同价值。如果的确需要，可以将其放在相应的 abstract class 或 Class 中。\r\n\r\n4 ．任何实现接口的类都要实现接口中所定义的所有方法，否则该类必须声明为 abstract 。\r\n\r\n5 ．一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。\r\n\r\n6 ．一个类可以同时继承一个父类和实现任意多个接口。 extends 子句应该在 implements 子句之前。 PHP 只支持继承自一个父类，因此 extends 关键字后只能跟一个类名。\r\n\r\n7 ．接口不可以实现另一个接口，但可以继承多个\r\n```\r\n### 三、 抽象类和接口的异同\r\n\r\n#### 1. 相同点：\r\n\r\n　　(1) 两者都是抽象类，都不能实例化。\r\n\r\n　　(2) interface 实现类及 abstract class 的子类都必须要实现已经声明的抽象方法。\r\n\r\n#### 2. 不同点：\r\n\r\n　　(1) interface 需要实现，要用 implements ，而 abstract class 需要继承，要用 extends 。\r\n\r\n　　(2) 一个类可以实现多个 interface ，但一个类只能继承一个 abstract class 。\r\n\r\n　　(3) interface 强调特定功能的实现，而 abstract class 强调所属关系。\r\n\r\n　　(4) 尽管 interface 实现类及 abstract class 的子类都必须要实现相应的抽象方法，但实现的形式不同。 interface 中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体 ) ，实现类必须要实现。而 abstract class 的子类可以有选择地实现。\r\n\r\n　　　　这个选择有两点含义：\r\n\r\n　　　　a) abstract class 中并非所有的方法都是抽象的，只有那些冠有 abstract 的方法才是抽象的，子类必须实现。那些没有 abstract 的方法，在 abstract class 中必须定义方法体；\r\n\r\n　　　　b) abstract class 的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。\r\n\r\n　　(5) abstract class 是 interface 与 class 的中介。 abstract class 在 interface 及 class 中起到了承上启下的作用。\r\n\r\n　　　　一方面， abstract class 是抽象的，可以声明抽象方法，以规范子类必须实现的功能；\r\n\r\n　　　　另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。\r\n\r\n　　(6) 接口中的抽象方法前不用也不能加 abstract 关键字，默认隐式就是抽象方法，也不能加 final 关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上 abstract 表示显示声明为抽象方法。\r\n\r\n　　(7) 接口中的抽象方法默认是 public 的，也只能是 public 的，不能用 private ， protected 修饰符修饰。而抽象类中的抽象方法则可以用 public ，protected 来修饰，但不能用 private 。\r\n\r\n#### 3. interface 的应用场合\r\n\r\n　　(1) 类与类之间需要特定的接口进行协调，而不在乎其如何实现。\r\n\r\n　　(2) 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。\r\n\r\n　　(3) 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。\r\n\r\n　　(4) 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。\r\n\r\n#### 4. abstract class 的应用场合\r\n\r\n　　一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：\r\n\r\n　　(1) 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用 abstract class 定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。\r\n\r\n　　(2) 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。 abstract 的中介作用可以很好地满足这一点。\r\n\r\n　　(3) 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特 定的功能 。\r\n ', '1', '1', '2019-04-04 13:33:08', '2019-04-04 13:37:20');

-- ----------------------------
-- Table structure for terms
-- ----------------------------
DROP TABLE IF EXISTS `terms`;
CREATE TABLE `terms` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `pid` bigint(20) unsigned NOT NULL DEFAULT '0',
  `path` varchar(100) DEFAULT '0',
  `name` varchar(200) NOT NULL,
  `slug` varchar(200) NOT NULL,
  `group` bigint(10) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `name` (`name`(191)) USING BTREE,
  KEY `slug` (`slug`(191)) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of terms
-- ----------------------------
INSERT INTO `terms` VALUES ('1', '0', '0', '笔试准备', 'bishizunbei', '0');
INSERT INTO `terms` VALUES ('2', '0', '0', '面试准备', 'mianshizunbei', '0');
INSERT INTO `terms` VALUES ('3', '0', '0', '知识储备', 'jichuzhishichubei', '0');
INSERT INTO `terms` VALUES ('4', '0', '0', '新技能学习', 'xinjinengxuexi', '0');
INSERT INTO `terms` VALUES ('5', '0', '0', '面试的公司', 'mianshidegongshi', '0');
INSERT INTO `terms` VALUES ('6', '0', '0', '头疼的算法', 'toutendeshuanfa', '0');
INSERT INTO `terms` VALUES ('7', '0', '0', '有趣的数据结构', 'youqudeshujujiegou', '0');
INSERT INTO `terms` VALUES ('8', '7', '0-7', '无中生有', 'wuzhongshengyou', '0');
INSERT INTO `terms` VALUES ('9', '8', '0-7-8', '道生一', 'daoshengyi', '0');
INSERT INTO `terms` VALUES ('10', '1', '0-1', 'php基础', 'phpeasy', '0');
INSERT INTO `terms` VALUES ('11', '1', '0-1', 'mysql基础', 'mysqleasy', '0');
INSERT INTO `terms` VALUES ('12', '1', '0-1', 'redis基础', 'rediseasy', '0');
INSERT INTO `terms` VALUES ('13', '0', '0', '打卡', 'weixiguandaka', '0');
INSERT INTO `terms` VALUES ('14', '0', '0', '微习惯', 'weixiguan', '0');
INSERT INTO `terms` VALUES ('15', '0', '0', 'go', 'go', '0');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `gid` int(11) unsigned NOT NULL DEFAULT '0',
  `name` varchar(50) NOT NULL,
  `email` varchar(50) DEFAULT NULL,
  `phone` varchar(50) DEFAULT NULL,
  `password` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `set` varchar(255) DEFAULT NULL,
  `remember_token` varchar(100) DEFAULT NULL,
  `status` smallint(3) unsigned NOT NULL DEFAULT '1',
  `created_at` timestamp NOT NULL,
  `updated_at` timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_user_name_unique` (`name`) USING BTREE,
  UNIQUE KEY `users_user_email_unique` (`email`) USING BTREE,
  UNIQUE KEY `users_user_phone_unique` (`phone`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES ('1', '0', 'root', 'test@163.com', null, 'test', null, null, null, '1', '2019-01-12 11:02:29', '2019-01-23 11:36:01');
INSERT INTO `users` VALUES ('2', '0', 'admin', 'admin@163.com', null, 'KCbclviUUrLB30xN5c3ektC4F+xv1GYJK/Pjb0DIAbXHI3GGr3Dh2dPWGfuF85so5Ipj+/sHcSXP8dss3qWi9IrlFQYmcTKLnSUZkMHdV6kFHDm2IJNH0+HuHKsMMXxwLtllOHQ9VeuCXbVX9yqoocmU307jvzHbSp/pUR8HdNE=', null, null, null, '1', '2019-01-12 03:13:41', '2019-01-12 03:13:41');
INSERT INTO `users` VALUES ('31', '0', 'xiaowu', 'admin01@163.com', null, 'vWs1YeMDBYKhXF6gJl7pY/EjH1e4bA7Ec0c5fYenawlhzvmqNGN7nY0jSk1l5g2ip/9HhDgx8sITHNpG7FxJzX81Mhuw3xfZTXqb+bqQrsAaxtB/aG+28dp370hUP/ON3Xw8glRYIsQHQPEf5/JMs74z7gv9YjsjWu4zzJzMk0g=', null, null, null, '1', '2019-01-12 03:34:12', '2019-01-23 11:35:40');
INSERT INTO `users` VALUES ('33', '0', 'wuqingbao', 'admin02@163.com', null, 'ZYtAb5KqQ1YBenq9FMQ3Z2zZR3sxDBPh3kGlafmE80/V3/XW6asZoa41X7bguTsAdJr9V+g84t+Wno1GIVzNUYL8GC6rIDCvMPXB+/QG8yT9qrLoI/Q3EfAzRmmAWmP4Aoecid5KlsyneqHGNTFjH+E8+apAZqEDG6sqlF9Mjco=', null, null, null, '1', '2019-01-12 03:36:39', '2019-01-23 11:35:45');
INSERT INTO `users` VALUES ('34', '0', 'wuxiumu', '', null, 'kW1Tl2knHTvf9ectQw7dnJuCu+XrLseqkHbJ24ZiCGm4us6IkzQa7dQIrnMWtz1ZHvapIShCLA7coL/ji2Ae1+5DD5f8lJ14zOXtSHv6SSZgLBCeWMKoW0nWmQBNs4dV8Mxqiwg2lc72uOKutJBGA9b8Ah5l6MMq8187l8gvu6I=', null, null, null, '1', '2019-01-12 07:31:35', '2019-01-23 11:35:54');
INSERT INTO `users` VALUES ('38', '0', 'hum4q', 'hum4q@163.com', null, 'QpB2fMsoqcZ75sfWFbnmOVHb2PeYanAGktdHNb8XETOq+3V64iqquVOl4QK5oOA43vVEHQrIBHhgsQ6j65cAGCo/t96woOhOqNkw4T/hOvUEr5hZpi48rczs/YPFyhi5QpBtixpQL9h2vtSs0v2hpotosjAmW7P6F2kS/bIyl0Y=', null, null, null, '1', '2019-01-13 14:42:35', '2019-01-13 14:42:35');
INSERT INTO `users` VALUES ('39', '0', 'puf5h', 'puf5h@163.com', null, 'rF1QSGcjeugwiTAZr/JeQqvpVupuI3Wnz0gLj2P9Rmn4JlHsnCqBg0NfFLs6U8wMTI5c5BfF7+9Xb0+1ZEydZ3ohkTiSD22WsciOBMbGaTTuj5RaJz6YfIzTV8xkjo0bt1HbzpEkGj9hPrsAIn03G599SdkHGNiE86PdCNIrGqI=', null, null, null, '1', '2019-01-13 14:43:13', '2019-01-13 14:43:13');
INSERT INTO `users` VALUES ('40', '0', 'xiaobao', 'xiaobao@163.com', null, 'MaTOU8BKZnMZl8XBfQPYVMpsdqtDYrAYTjoPfVY0b0fOM79Ahjypg+3g4jK2prUwZxJIxy4V6vRhq+OZ1ky/QyfqGZKshUpElOZAdk57WfspNEsFes+WBmlxCi+pRTBpatXwnQ7Lfrp3wXPCIab1+woMDq3m5pw4ind6DELgPOc=', null, null, null, '1', '2019-01-15 16:48:21', '2019-01-15 16:48:21');
